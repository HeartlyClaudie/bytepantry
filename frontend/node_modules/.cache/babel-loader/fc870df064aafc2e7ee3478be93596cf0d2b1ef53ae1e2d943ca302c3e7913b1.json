{"ast":null,"code":"/*! @azure/msal-browser v4.5.0 2025-02-26 */\n'use strict';\n\nimport { RequestParameterBuilder, StringUtils, AuthenticationScheme, createClientAuthError, ClientAuthErrorCodes, AuthToken, buildTenantProfile, AuthError, InteractionRequiredAuthError, ServerError, ClientAuthError, OIDC_DEFAULT_SCOPES } from '@azure/msal-common/browser';\nimport { isBridgeError } from '../BridgeError.mjs';\nimport { BridgeStatusCode } from '../BridgeStatusCode.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass NestedAppAuthAdapter {\n  constructor(clientId, clientCapabilities, crypto, logger) {\n    this.clientId = clientId;\n    this.clientCapabilities = clientCapabilities;\n    this.crypto = crypto;\n    this.logger = logger;\n  }\n  toNaaTokenRequest(request) {\n    let extraParams;\n    if (request.extraQueryParameters === undefined) {\n      extraParams = new Map();\n    } else {\n      extraParams = new Map(Object.entries(request.extraQueryParameters));\n    }\n    const correlationId = request.correlationId || this.crypto.createNewGuid();\n    const requestBuilder = new RequestParameterBuilder(correlationId);\n    const claims = requestBuilder.addClientCapabilitiesToClaims(request.claims, this.clientCapabilities);\n    const scopes = request.scopes || OIDC_DEFAULT_SCOPES;\n    const tokenRequest = {\n      platformBrokerId: request.account?.homeAccountId,\n      clientId: this.clientId,\n      authority: request.authority,\n      scope: scopes.join(\" \"),\n      correlationId,\n      claims: !StringUtils.isEmptyObj(claims) ? claims : undefined,\n      state: request.state,\n      authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,\n      extraParameters: extraParams\n    };\n    return tokenRequest;\n  }\n  fromNaaTokenResponse(request, response, reqTimestamp) {\n    if (!response.token.id_token || !response.token.access_token) {\n      throw createClientAuthError(ClientAuthErrorCodes.nullOrEmptyToken);\n    }\n    const expiresOn = new Date((reqTimestamp + (response.token.expires_in || 0)) * 1000);\n    const idTokenClaims = AuthToken.extractTokenClaims(response.token.id_token, this.crypto.base64Decode);\n    const account = this.fromNaaAccountInfo(response.account, response.token.id_token, idTokenClaims);\n    const scopes = response.token.scope || request.scope;\n    const authenticationResult = {\n      authority: response.token.authority || account.environment,\n      uniqueId: account.localAccountId,\n      tenantId: account.tenantId,\n      scopes: scopes.split(\" \"),\n      account,\n      idToken: response.token.id_token,\n      idTokenClaims,\n      accessToken: response.token.access_token,\n      fromCache: false,\n      expiresOn: expiresOn,\n      tokenType: request.authenticationScheme || AuthenticationScheme.BEARER,\n      correlationId: request.correlationId,\n      extExpiresOn: expiresOn,\n      state: request.state\n    };\n    return authenticationResult;\n  }\n  /*\r\n   *  export type AccountInfo = {\r\n   *     homeAccountId: string;\r\n   *     environment: string;\r\n   *     tenantId: string;\r\n   *     username: string;\r\n   *     localAccountId: string;\r\n   *     name?: string;\r\n   *     idToken?: string;\r\n   *     idTokenClaims?: TokenClaims & {\r\n   *         [key: string]:\r\n   *             | string\r\n   *             | number\r\n   *             | string[]\r\n   *             | object\r\n   *             | undefined\r\n   *             | unknown;\r\n   *     };\r\n   *     nativeAccountId?: string;\r\n   *     authorityType?: string;\r\n   * };\r\n   */\n  fromNaaAccountInfo(fromAccount, idToken, idTokenClaims) {\n    const effectiveIdTokenClaims = idTokenClaims || fromAccount.idTokenClaims;\n    const localAccountId = fromAccount.localAccountId || effectiveIdTokenClaims?.oid || effectiveIdTokenClaims?.sub || \"\";\n    const tenantId = fromAccount.tenantId || effectiveIdTokenClaims?.tid || \"\";\n    const homeAccountId = fromAccount.homeAccountId || `${localAccountId}.${tenantId}`;\n    const username = fromAccount.username || effectiveIdTokenClaims?.preferred_username || \"\";\n    const name = fromAccount.name || effectiveIdTokenClaims?.name;\n    const tenantProfiles = new Map();\n    const tenantProfile = buildTenantProfile(homeAccountId, localAccountId, tenantId, effectiveIdTokenClaims);\n    tenantProfiles.set(tenantId, tenantProfile);\n    const account = {\n      homeAccountId,\n      environment: fromAccount.environment,\n      tenantId,\n      username,\n      localAccountId,\n      name,\n      idToken: idToken,\n      idTokenClaims: effectiveIdTokenClaims,\n      tenantProfiles\n    };\n    return account;\n  }\n  /**\r\n   *\r\n   * @param error BridgeError\r\n   * @returns AuthError, ClientAuthError, ClientConfigurationError, ServerError, InteractionRequiredError\r\n   */\n  fromBridgeError(error) {\n    if (isBridgeError(error)) {\n      switch (error.status) {\n        case BridgeStatusCode.UserCancel:\n          return new ClientAuthError(ClientAuthErrorCodes.userCanceled);\n        case BridgeStatusCode.NoNetwork:\n          return new ClientAuthError(ClientAuthErrorCodes.noNetworkConnectivity);\n        case BridgeStatusCode.AccountUnavailable:\n          return new ClientAuthError(ClientAuthErrorCodes.noAccountFound);\n        case BridgeStatusCode.Disabled:\n          return new ClientAuthError(ClientAuthErrorCodes.nestedAppAuthBridgeDisabled);\n        case BridgeStatusCode.NestedAppAuthUnavailable:\n          return new ClientAuthError(error.code || ClientAuthErrorCodes.nestedAppAuthBridgeDisabled, error.description);\n        case BridgeStatusCode.TransientError:\n        case BridgeStatusCode.PersistentError:\n          return new ServerError(error.code, error.description);\n        case BridgeStatusCode.UserInteractionRequired:\n          return new InteractionRequiredAuthError(error.code, error.description);\n        default:\n          return new AuthError(error.code, error.description);\n      }\n    } else {\n      return new AuthError(\"unknown_error\", \"An unknown error occurred\");\n    }\n  }\n  /**\r\n   * Returns an AuthenticationResult from the given cache items\r\n   *\r\n   * @param account\r\n   * @param idToken\r\n   * @param accessToken\r\n   * @param reqTimestamp\r\n   * @returns\r\n   */\n  toAuthenticationResultFromCache(account, idToken, accessToken, request, correlationId) {\n    if (!idToken || !accessToken) {\n      throw createClientAuthError(ClientAuthErrorCodes.nullOrEmptyToken);\n    }\n    const idTokenClaims = AuthToken.extractTokenClaims(idToken.secret, this.crypto.base64Decode);\n    const scopes = accessToken.target || request.scopes.join(\" \");\n    const authenticationResult = {\n      authority: accessToken.environment || account.environment,\n      uniqueId: account.localAccountId,\n      tenantId: account.tenantId,\n      scopes: scopes.split(\" \"),\n      account,\n      idToken: idToken.secret,\n      idTokenClaims: idTokenClaims || {},\n      accessToken: accessToken.secret,\n      fromCache: true,\n      expiresOn: new Date(Number(accessToken.expiresOn) * 1000),\n      tokenType: request.authenticationScheme || AuthenticationScheme.BEARER,\n      correlationId,\n      extExpiresOn: new Date(Number(accessToken.extendedExpiresOn) * 1000),\n      state: request.state\n    };\n    return authenticationResult;\n  }\n}\nexport { NestedAppAuthAdapter };","map":{"version":3,"names":["NestedAppAuthAdapter","constructor","clientId","clientCapabilities","crypto","logger","toNaaTokenRequest","request","extraParams","extraQueryParameters","undefined","Map","Object","entries","correlationId","createNewGuid","requestBuilder","RequestParameterBuilder","claims","addClientCapabilitiesToClaims","scopes","OIDC_DEFAULT_SCOPES","tokenRequest","platformBrokerId","account","homeAccountId","authority","scope","join","StringUtils","isEmptyObj","state","authenticationScheme","AuthenticationScheme","BEARER","extraParameters","fromNaaTokenResponse","response","reqTimestamp","token","id_token","access_token","createClientAuthError","ClientAuthErrorCodes","nullOrEmptyToken","expiresOn","Date","expires_in","idTokenClaims","AuthToken","extractTokenClaims","base64Decode","fromNaaAccountInfo","authenticationResult","environment","uniqueId","localAccountId","tenantId","split","idToken","accessToken","fromCache","tokenType","extExpiresOn","fromAccount","effectiveIdTokenClaims","oid","sub","tid","username","preferred_username","name","tenantProfiles","tenantProfile","buildTenantProfile","set","fromBridgeError","error","isBridgeError","status","BridgeStatusCode","UserCancel","ClientAuthError","userCanceled","NoNetwork","noNetworkConnectivity","AccountUnavailable","noAccountFound","Disabled","nestedAppAuthBridgeDisabled","NestedAppAuthUnavailable","code","description","TransientError","PersistentError","ServerError","UserInteractionRequired","InteractionRequiredAuthError","AuthError","toAuthenticationResultFromCache","secret","target","Number","extendedExpiresOn"],"sources":["C:\\bytepantry\\frontend\\node_modules\\@azure\\msal-browser\\src\\naa\\mapping\\NestedAppAuthAdapter.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { TokenRequest } from \"../TokenRequest.js\";\r\nimport { AccountInfo as NaaAccountInfo } from \"../AccountInfo.js\";\r\nimport { RedirectRequest } from \"../../request/RedirectRequest.js\";\r\nimport { PopupRequest } from \"../../request/PopupRequest.js\";\r\nimport {\r\n    AccountInfo as MsalAccountInfo,\r\n    AuthError,\r\n    ClientAuthError,\r\n    ClientConfigurationError,\r\n    InteractionRequiredAuthError,\r\n    ServerError,\r\n    ICrypto,\r\n    Logger,\r\n    AuthToken,\r\n    TokenClaims,\r\n    ClientAuthErrorCodes,\r\n    AuthenticationScheme,\r\n    RequestParameterBuilder,\r\n    StringUtils,\r\n    createClientAuthError,\r\n    OIDC_DEFAULT_SCOPES,\r\n    AccountInfo,\r\n    IdTokenEntity,\r\n    AccessTokenEntity,\r\n    TenantProfile,\r\n    buildTenantProfile,\r\n} from \"@azure/msal-common/browser\";\r\nimport { isBridgeError } from \"../BridgeError.js\";\r\nimport { BridgeStatusCode } from \"../BridgeStatusCode.js\";\r\nimport { AuthenticationResult } from \"../../response/AuthenticationResult.js\";\r\nimport {} from \"../../error/BrowserAuthErrorCodes.js\";\r\nimport { AuthResult } from \"../AuthResult.js\";\r\nimport { SsoSilentRequest } from \"../../request/SsoSilentRequest.js\";\r\nimport { SilentRequest } from \"../../request/SilentRequest.js\";\r\n\r\nexport class NestedAppAuthAdapter {\r\n    protected crypto: ICrypto;\r\n    protected logger: Logger;\r\n    protected clientId: string;\r\n    protected clientCapabilities: string[];\r\n\r\n    constructor(\r\n        clientId: string,\r\n        clientCapabilities: string[],\r\n        crypto: ICrypto,\r\n        logger: Logger\r\n    ) {\r\n        this.clientId = clientId;\r\n        this.clientCapabilities = clientCapabilities;\r\n        this.crypto = crypto;\r\n        this.logger = logger;\r\n    }\r\n\r\n    public toNaaTokenRequest(\r\n        request:\r\n            | PopupRequest\r\n            | RedirectRequest\r\n            | SilentRequest\r\n            | SsoSilentRequest\r\n    ): TokenRequest {\r\n        let extraParams: Map<string, string>;\r\n        if (request.extraQueryParameters === undefined) {\r\n            extraParams = new Map<string, string>();\r\n        } else {\r\n            extraParams = new Map<string, string>(\r\n                Object.entries(request.extraQueryParameters)\r\n            );\r\n        }\r\n\r\n        const correlationId =\r\n            request.correlationId || this.crypto.createNewGuid();\r\n        const requestBuilder = new RequestParameterBuilder(correlationId);\r\n        const claims = requestBuilder.addClientCapabilitiesToClaims(\r\n            request.claims,\r\n            this.clientCapabilities\r\n        );\r\n        const scopes = request.scopes || OIDC_DEFAULT_SCOPES;\r\n        const tokenRequest: TokenRequest = {\r\n            platformBrokerId: request.account?.homeAccountId,\r\n            clientId: this.clientId,\r\n            authority: request.authority,\r\n            scope: scopes.join(\" \"),\r\n            correlationId,\r\n            claims: !StringUtils.isEmptyObj(claims) ? claims : undefined,\r\n            state: request.state,\r\n            authenticationScheme:\r\n                request.authenticationScheme || AuthenticationScheme.BEARER,\r\n            extraParameters: extraParams,\r\n        };\r\n\r\n        return tokenRequest;\r\n    }\r\n\r\n    public fromNaaTokenResponse(\r\n        request: TokenRequest,\r\n        response: AuthResult,\r\n        reqTimestamp: number\r\n    ): AuthenticationResult {\r\n        if (!response.token.id_token || !response.token.access_token) {\r\n            throw createClientAuthError(ClientAuthErrorCodes.nullOrEmptyToken);\r\n        }\r\n\r\n        const expiresOn = new Date(\r\n            (reqTimestamp + (response.token.expires_in || 0)) * 1000\r\n        );\r\n        const idTokenClaims = AuthToken.extractTokenClaims(\r\n            response.token.id_token,\r\n            this.crypto.base64Decode\r\n        );\r\n        const account = this.fromNaaAccountInfo(\r\n            response.account,\r\n            response.token.id_token,\r\n            idTokenClaims\r\n        );\r\n        const scopes = response.token.scope || request.scope;\r\n\r\n        const authenticationResult: AuthenticationResult = {\r\n            authority: response.token.authority || account.environment,\r\n            uniqueId: account.localAccountId,\r\n            tenantId: account.tenantId,\r\n            scopes: scopes.split(\" \"),\r\n            account,\r\n            idToken: response.token.id_token,\r\n            idTokenClaims,\r\n            accessToken: response.token.access_token,\r\n            fromCache: false,\r\n            expiresOn: expiresOn,\r\n            tokenType:\r\n                request.authenticationScheme || AuthenticationScheme.BEARER,\r\n            correlationId: request.correlationId,\r\n            extExpiresOn: expiresOn,\r\n            state: request.state,\r\n        };\r\n\r\n        return authenticationResult;\r\n    }\r\n\r\n    /*\r\n     *  export type AccountInfo = {\r\n     *     homeAccountId: string;\r\n     *     environment: string;\r\n     *     tenantId: string;\r\n     *     username: string;\r\n     *     localAccountId: string;\r\n     *     name?: string;\r\n     *     idToken?: string;\r\n     *     idTokenClaims?: TokenClaims & {\r\n     *         [key: string]:\r\n     *             | string\r\n     *             | number\r\n     *             | string[]\r\n     *             | object\r\n     *             | undefined\r\n     *             | unknown;\r\n     *     };\r\n     *     nativeAccountId?: string;\r\n     *     authorityType?: string;\r\n     * };\r\n     */\r\n    public fromNaaAccountInfo(\r\n        fromAccount: NaaAccountInfo,\r\n        idToken?: string,\r\n        idTokenClaims?: TokenClaims\r\n    ): MsalAccountInfo {\r\n        const effectiveIdTokenClaims =\r\n            idTokenClaims || (fromAccount.idTokenClaims as TokenClaims);\r\n\r\n        const localAccountId =\r\n            fromAccount.localAccountId ||\r\n            effectiveIdTokenClaims?.oid ||\r\n            effectiveIdTokenClaims?.sub ||\r\n            \"\";\r\n\r\n        const tenantId =\r\n            fromAccount.tenantId || effectiveIdTokenClaims?.tid || \"\";\r\n\r\n        const homeAccountId =\r\n            fromAccount.homeAccountId || `${localAccountId}.${tenantId}`;\r\n\r\n        const username =\r\n            fromAccount.username ||\r\n            effectiveIdTokenClaims?.preferred_username ||\r\n            \"\";\r\n\r\n        const name = fromAccount.name || effectiveIdTokenClaims?.name;\r\n\r\n        const tenantProfiles = new Map<string, TenantProfile>();\r\n\r\n        const tenantProfile = buildTenantProfile(\r\n            homeAccountId,\r\n            localAccountId,\r\n            tenantId,\r\n            effectiveIdTokenClaims\r\n        );\r\n        tenantProfiles.set(tenantId, tenantProfile);\r\n\r\n        const account: MsalAccountInfo = {\r\n            homeAccountId,\r\n            environment: fromAccount.environment,\r\n            tenantId,\r\n            username,\r\n            localAccountId,\r\n            name,\r\n            idToken: idToken,\r\n            idTokenClaims: effectiveIdTokenClaims,\r\n            tenantProfiles,\r\n        };\r\n\r\n        return account;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param error BridgeError\r\n     * @returns AuthError, ClientAuthError, ClientConfigurationError, ServerError, InteractionRequiredError\r\n     */\r\n    public fromBridgeError(\r\n        error: unknown\r\n    ):\r\n        | AuthError\r\n        | ClientAuthError\r\n        | ClientConfigurationError\r\n        | ServerError\r\n        | InteractionRequiredAuthError {\r\n        if (isBridgeError(error)) {\r\n            switch (error.status) {\r\n                case BridgeStatusCode.UserCancel:\r\n                    return new ClientAuthError(\r\n                        ClientAuthErrorCodes.userCanceled\r\n                    );\r\n                case BridgeStatusCode.NoNetwork:\r\n                    return new ClientAuthError(\r\n                        ClientAuthErrorCodes.noNetworkConnectivity\r\n                    );\r\n                case BridgeStatusCode.AccountUnavailable:\r\n                    return new ClientAuthError(\r\n                        ClientAuthErrorCodes.noAccountFound\r\n                    );\r\n                case BridgeStatusCode.Disabled:\r\n                    return new ClientAuthError(\r\n                        ClientAuthErrorCodes.nestedAppAuthBridgeDisabled\r\n                    );\r\n                case BridgeStatusCode.NestedAppAuthUnavailable:\r\n                    return new ClientAuthError(\r\n                        error.code ||\r\n                            ClientAuthErrorCodes.nestedAppAuthBridgeDisabled,\r\n                        error.description\r\n                    );\r\n                case BridgeStatusCode.TransientError:\r\n                case BridgeStatusCode.PersistentError:\r\n                    return new ServerError(error.code, error.description);\r\n                case BridgeStatusCode.UserInteractionRequired:\r\n                    return new InteractionRequiredAuthError(\r\n                        error.code,\r\n                        error.description\r\n                    );\r\n                default:\r\n                    return new AuthError(error.code, error.description);\r\n            }\r\n        } else {\r\n            return new AuthError(\"unknown_error\", \"An unknown error occurred\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an AuthenticationResult from the given cache items\r\n     *\r\n     * @param account\r\n     * @param idToken\r\n     * @param accessToken\r\n     * @param reqTimestamp\r\n     * @returns\r\n     */\r\n    public toAuthenticationResultFromCache(\r\n        account: AccountInfo,\r\n        idToken: IdTokenEntity,\r\n        accessToken: AccessTokenEntity,\r\n        request: SilentRequest,\r\n        correlationId: string\r\n    ): AuthenticationResult {\r\n        if (!idToken || !accessToken) {\r\n            throw createClientAuthError(ClientAuthErrorCodes.nullOrEmptyToken);\r\n        }\r\n\r\n        const idTokenClaims = AuthToken.extractTokenClaims(\r\n            idToken.secret,\r\n            this.crypto.base64Decode\r\n        );\r\n\r\n        const scopes = accessToken.target || request.scopes.join(\" \");\r\n\r\n        const authenticationResult: AuthenticationResult = {\r\n            authority: accessToken.environment || account.environment,\r\n            uniqueId: account.localAccountId,\r\n            tenantId: account.tenantId,\r\n            scopes: scopes.split(\" \"),\r\n            account,\r\n            idToken: idToken.secret,\r\n            idTokenClaims: idTokenClaims || {},\r\n            accessToken: accessToken.secret,\r\n            fromCache: true,\r\n            expiresOn: new Date(Number(accessToken.expiresOn) * 1000),\r\n            tokenType:\r\n                request.authenticationScheme || AuthenticationScheme.BEARER,\r\n            correlationId,\r\n            extExpiresOn: new Date(\r\n                Number(accessToken.extendedExpiresOn) * 1000\r\n            ),\r\n            state: request.state,\r\n        };\r\n\r\n        return authenticationResult;\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}