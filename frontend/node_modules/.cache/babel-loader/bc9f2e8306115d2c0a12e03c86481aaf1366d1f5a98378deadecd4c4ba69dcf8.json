{"ast":null,"code":"/*! @azure/msal-browser v4.5.0 2025-02-26 */\n'use strict';\n\nimport { CacheManager, AccountEntity, invokeAsync, PerformanceEvents, CredentialType, createClientAuthError, ClientAuthErrorCodes, CacheHelpers, Constants, PersistentCacheKeys, StringUtils, ProtocolUtils, CacheError, DEFAULT_CRYPTO_IMPLEMENTATION, CcsCredentialType } from '@azure/msal-common/browser';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { BrowserCacheLocation, StaticCacheKeys, InMemoryCacheKeys, TemporaryCacheKeys } from '../utils/BrowserConstants.mjs';\nimport { LocalStorage } from './LocalStorage.mjs';\nimport { SessionStorage } from './SessionStorage.mjs';\nimport { MemoryStorage } from './MemoryStorage.mjs';\nimport { extractBrowserRequestState } from '../utils/BrowserProtocolUtils.mjs';\nimport { base64Decode } from '../encode/Base64Decode.mjs';\nimport { base64Encode } from '../encode/Base64Encode.mjs';\nimport { CookieStorage } from './CookieStorage.mjs';\nimport { getAccountKeys, getTokenKeys } from './CacheHelpers.mjs';\nimport { EventType } from '../event/EventType.mjs';\nimport { noTokenRequestCacheError, unableToParseTokenRequestCacheError, noCachedAuthorityError, interactionInProgress } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\nclass BrowserCacheManager extends CacheManager {\n  constructor(clientId, cacheConfig, cryptoImpl, logger, performanceClient, eventHandler, staticAuthorityOptions) {\n    super(clientId, cryptoImpl, logger, staticAuthorityOptions);\n    this.cacheConfig = cacheConfig;\n    this.logger = logger;\n    this.internalStorage = new MemoryStorage();\n    this.browserStorage = getStorageImplementation(clientId, cacheConfig.cacheLocation, logger, performanceClient);\n    this.temporaryCacheStorage = getStorageImplementation(clientId, cacheConfig.temporaryCacheLocation, logger, performanceClient);\n    this.cookieStorage = new CookieStorage();\n    this.performanceClient = performanceClient;\n    this.eventHandler = eventHandler;\n  }\n  async initialize(correlationId) {\n    await this.browserStorage.initialize(correlationId);\n  }\n  /**\r\n   * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n   * @param input\r\n   */\n  validateAndParseJson(jsonValue) {\n    try {\n      const parsedJson = JSON.parse(jsonValue);\n      /**\r\n       * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n       * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n       * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n       *\r\n       */\n      return parsedJson && typeof parsedJson === \"object\" ? parsedJson : null;\n    } catch (error) {\n      return null;\n    }\n  }\n  /**\r\n   * Reads account from cache, deserializes it into an account entity and returns it.\r\n   * If account is not found from the key, returns null and removes key from map.\r\n   * @param accountKey\r\n   * @returns\r\n   */\n  getAccount(accountKey) {\n    this.logger.trace(\"BrowserCacheManager.getAccount called\");\n    const serializedAccount = this.browserStorage.getUserData(accountKey);\n    if (!serializedAccount) {\n      this.removeAccountKeyFromMap(accountKey);\n      return null;\n    }\n    const parsedAccount = this.validateAndParseJson(serializedAccount);\n    if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n      this.removeAccountKeyFromMap(accountKey);\n      return null;\n    }\n    return CacheManager.toObject(new AccountEntity(), parsedAccount);\n  }\n  /**\r\n   * set account entity in the platform cache\r\n   * @param account\r\n   */\n  async setAccount(account, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setAccount called\");\n    const key = account.generateAccountKey();\n    await invokeAsync(this.browserStorage.setUserData.bind(this.browserStorage), PerformanceEvents.SetUserData, this.logger, this.performanceClient)(key, JSON.stringify(account), correlationId);\n    const wasAdded = this.addAccountKeyToMap(key);\n    /**\r\n     * @deprecated - Remove this in next major version in favor of more consistent LOGIN event\r\n     */\n    if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage && wasAdded) {\n      this.eventHandler.emitEvent(EventType.ACCOUNT_ADDED, undefined, account.getAccountInfo());\n    }\n  }\n  /**\r\n   * Returns the array of account keys currently cached\r\n   * @returns\r\n   */\n  getAccountKeys() {\n    return getAccountKeys(this.browserStorage);\n  }\n  /**\r\n   * Add a new account to the key map\r\n   * @param key\r\n   */\n  addAccountKeyToMap(key) {\n    this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\n    this.logger.tracePii(`BrowserCacheManager.addAccountKeyToMap called with key: ${key}`);\n    const accountKeys = this.getAccountKeys();\n    if (accountKeys.indexOf(key) === -1) {\n      // Only add key if it does not already exist in the map\n      accountKeys.push(key);\n      this.browserStorage.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key added\");\n      return true;\n    } else {\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key already exists in map\");\n      return false;\n    }\n  }\n  /**\r\n   * Remove an account from the key map\r\n   * @param key\r\n   */\n  removeAccountKeyFromMap(key) {\n    this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\n    this.logger.tracePii(`BrowserCacheManager.removeAccountKeyFromMap called with key: ${key}`);\n    const accountKeys = this.getAccountKeys();\n    const removalIndex = accountKeys.indexOf(key);\n    if (removalIndex > -1) {\n      accountKeys.splice(removalIndex, 1);\n      this.browserStorage.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap account key removed\");\n    } else {\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\");\n    }\n  }\n  /**\r\n   * Extends inherited removeAccount function to include removal of the account key from the map\r\n   * @param key\r\n   */\n  async removeAccount(key) {\n    void super.removeAccount(key);\n    this.removeAccountKeyFromMap(key);\n  }\n  /**\r\n   * Removes credentials associated with the provided account\r\n   * @param account\r\n   */\n  async removeAccountContext(account) {\n    await super.removeAccountContext(account);\n    /**\r\n     * @deprecated - Remove this in next major version in favor of more consistent LOGOUT event\r\n     */\n    if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n      this.eventHandler.emitEvent(EventType.ACCOUNT_REMOVED, undefined, account.getAccountInfo());\n    }\n  }\n  /**\r\n   * Removes given idToken from the cache and from the key map\r\n   * @param key\r\n   */\n  removeIdToken(key) {\n    super.removeIdToken(key);\n    this.removeTokenKey(key, CredentialType.ID_TOKEN);\n  }\n  /**\r\n   * Removes given accessToken from the cache and from the key map\r\n   * @param key\r\n   */\n  async removeAccessToken(key) {\n    void super.removeAccessToken(key);\n    this.removeTokenKey(key, CredentialType.ACCESS_TOKEN);\n  }\n  /**\r\n   * Removes given refreshToken from the cache and from the key map\r\n   * @param key\r\n   */\n  removeRefreshToken(key) {\n    super.removeRefreshToken(key);\n    this.removeTokenKey(key, CredentialType.REFRESH_TOKEN);\n  }\n  /**\r\n   * Gets the keys for the cached tokens associated with this clientId\r\n   * @returns\r\n   */\n  getTokenKeys() {\n    return getTokenKeys(this.clientId, this.browserStorage);\n  }\n  /**\r\n   * Adds the given key to the token key map\r\n   * @param key\r\n   * @param type\r\n   */\n  addTokenKey(key, type) {\n    this.logger.trace(\"BrowserCacheManager addTokenKey called\");\n    const tokenKeys = this.getTokenKeys();\n    switch (type) {\n      case CredentialType.ID_TOKEN:\n        if (tokenKeys.idToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - idToken added to map\");\n          tokenKeys.idToken.push(key);\n        }\n        break;\n      case CredentialType.ACCESS_TOKEN:\n        if (tokenKeys.accessToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - accessToken added to map\");\n          tokenKeys.accessToken.push(key);\n        }\n        break;\n      case CredentialType.REFRESH_TOKEN:\n        if (tokenKeys.refreshToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - refreshToken added to map\");\n          tokenKeys.refreshToken.push(key);\n        }\n        break;\n      default:\n        this.logger.error(`BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: ${type}`);\n        throw createClientAuthError(ClientAuthErrorCodes.unexpectedCredentialType);\n    }\n    this.browserStorage.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));\n  }\n  /**\r\n   * Removes the given key from the token key map\r\n   * @param key\r\n   * @param type\r\n   */\n  removeTokenKey(key, type) {\n    this.logger.trace(\"BrowserCacheManager removeTokenKey called\");\n    const tokenKeys = this.getTokenKeys();\n    switch (type) {\n      case CredentialType.ID_TOKEN:\n        this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: ${key} from map`);\n        const idRemoval = tokenKeys.idToken.indexOf(key);\n        if (idRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken removed from map\");\n          tokenKeys.idToken.splice(idRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      case CredentialType.ACCESS_TOKEN:\n        this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: ${key} from map`);\n        const accessRemoval = tokenKeys.accessToken.indexOf(key);\n        if (accessRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken removed from map\");\n          tokenKeys.accessToken.splice(accessRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      case CredentialType.REFRESH_TOKEN:\n        this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: ${key} from map`);\n        const refreshRemoval = tokenKeys.refreshToken.indexOf(key);\n        if (refreshRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken removed from map\");\n          tokenKeys.refreshToken.splice(refreshRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      default:\n        this.logger.error(`BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: ${type}`);\n        throw createClientAuthError(ClientAuthErrorCodes.unexpectedCredentialType);\n    }\n    this.browserStorage.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));\n  }\n  /**\r\n   * generates idToken entity from a string\r\n   * @param idTokenKey\r\n   */\n  getIdTokenCredential(idTokenKey) {\n    const value = this.browserStorage.getUserData(idTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n      return null;\n    }\n    const parsedIdToken = this.validateAndParseJson(value);\n    if (!parsedIdToken || !CacheHelpers.isIdTokenEntity(parsedIdToken)) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\n    return parsedIdToken;\n  }\n  /**\r\n   * set IdToken credential to the platform cache\r\n   * @param idToken\r\n   */\n  async setIdTokenCredential(idToken, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n    const idTokenKey = CacheHelpers.generateCredentialKey(idToken);\n    await invokeAsync(this.browserStorage.setUserData.bind(this.browserStorage), PerformanceEvents.SetUserData, this.logger, this.performanceClient)(idTokenKey, JSON.stringify(idToken), correlationId);\n    this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n  }\n  /**\r\n   * generates accessToken entity from a string\r\n   * @param key\r\n   */\n  getAccessTokenCredential(accessTokenKey) {\n    const value = this.browserStorage.getUserData(accessTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n      return null;\n    }\n    const parsedAccessToken = this.validateAndParseJson(value);\n    if (!parsedAccessToken || !CacheHelpers.isAccessTokenEntity(parsedAccessToken)) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\n    return parsedAccessToken;\n  }\n  /**\r\n   * set accessToken credential to the platform cache\r\n   * @param accessToken\r\n   */\n  async setAccessTokenCredential(accessToken, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\n    const accessTokenKey = CacheHelpers.generateCredentialKey(accessToken);\n    await invokeAsync(this.browserStorage.setUserData.bind(this.browserStorage), PerformanceEvents.SetUserData, this.logger, this.performanceClient)(accessTokenKey, JSON.stringify(accessToken), correlationId);\n    this.addTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n  }\n  /**\r\n   * generates refreshToken entity from a string\r\n   * @param refreshTokenKey\r\n   */\n  getRefreshTokenCredential(refreshTokenKey) {\n    const value = this.browserStorage.getUserData(refreshTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n      return null;\n    }\n    const parsedRefreshToken = this.validateAndParseJson(value);\n    if (!parsedRefreshToken || !CacheHelpers.isRefreshTokenEntity(parsedRefreshToken)) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\n    return parsedRefreshToken;\n  }\n  /**\r\n   * set refreshToken credential to the platform cache\r\n   * @param refreshToken\r\n   */\n  async setRefreshTokenCredential(refreshToken, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\n    const refreshTokenKey = CacheHelpers.generateCredentialKey(refreshToken);\n    await invokeAsync(this.browserStorage.setUserData.bind(this.browserStorage), PerformanceEvents.SetUserData, this.logger, this.performanceClient)(refreshTokenKey, JSON.stringify(refreshToken), correlationId);\n    this.addTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n  }\n  /**\r\n   * fetch appMetadata entity from the platform cache\r\n   * @param appMetadataKey\r\n   */\n  getAppMetadata(appMetadataKey) {\n    const value = this.browserStorage.getItem(appMetadataKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    const parsedMetadata = this.validateAndParseJson(value);\n    if (!parsedMetadata || !CacheHelpers.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n    return parsedMetadata;\n  }\n  /**\r\n   * set appMetadata entity to the platform cache\r\n   * @param appMetadata\r\n   */\n  setAppMetadata(appMetadata) {\n    this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n    const appMetadataKey = CacheHelpers.generateAppMetadataKey(appMetadata);\n    this.browserStorage.setItem(appMetadataKey, JSON.stringify(appMetadata));\n  }\n  /**\r\n   * fetch server telemetry entity from the platform cache\r\n   * @param serverTelemetryKey\r\n   */\n  getServerTelemetry(serverTelemetryKey) {\n    const value = this.browserStorage.getItem(serverTelemetryKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    const parsedEntity = this.validateAndParseJson(value);\n    if (!parsedEntity || !CacheHelpers.isServerTelemetryEntity(serverTelemetryKey, parsedEntity)) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n    return parsedEntity;\n  }\n  /**\r\n   * set server telemetry entity to the platform cache\r\n   * @param serverTelemetryKey\r\n   * @param serverTelemetry\r\n   */\n  setServerTelemetry(serverTelemetryKey, serverTelemetry) {\n    this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n    this.browserStorage.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\n  }\n  /**\r\n   *\r\n   */\n  getAuthorityMetadata(key) {\n    const value = this.internalStorage.getItem(key);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\n      return null;\n    }\n    const parsedMetadata = this.validateAndParseJson(value);\n    if (parsedMetadata && CacheHelpers.isAuthorityMetadataEntity(key, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\n      return parsedMetadata;\n    }\n    return null;\n  }\n  /**\r\n   *\r\n   */\n  getAuthorityMetadataKeys() {\n    const allKeys = this.internalStorage.getKeys();\n    return allKeys.filter(key => {\n      return this.isAuthorityMetadata(key);\n    });\n  }\n  /**\r\n   * Sets wrapper metadata in memory\r\n   * @param wrapperSKU\r\n   * @param wrapperVersion\r\n   */\n  setWrapperMetadata(wrapperSKU, wrapperVersion) {\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\n  }\n  /**\r\n   * Returns wrapper metadata from in-memory storage\r\n   */\n  getWrapperMetadata() {\n    const sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;\n    const version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;\n    return [sku, version];\n  }\n  /**\r\n   *\r\n   * @param entity\r\n   */\n  setAuthorityMetadata(key, entity) {\n    this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n    this.internalStorage.setItem(key, JSON.stringify(entity));\n  }\n  /**\r\n   * Gets the active account\r\n   */\n  getActiveAccount() {\n    const activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    const activeAccountValueFilters = this.browserStorage.getItem(activeAccountKeyFilters);\n    if (!activeAccountValueFilters) {\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account filters found\");\n      return null;\n    }\n    const activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters);\n    if (activeAccountValueObj) {\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: Active account filters schema found\");\n      return this.getAccountInfoFilteredBy({\n        homeAccountId: activeAccountValueObj.homeAccountId,\n        localAccountId: activeAccountValueObj.localAccountId,\n        tenantId: activeAccountValueObj.tenantId\n      });\n    }\n    this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n    return null;\n  }\n  /**\r\n   * Sets the active account's localAccountId in cache\r\n   * @param account\r\n   */\n  setActiveAccount(account) {\n    const activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    if (account) {\n      this.logger.verbose(\"setActiveAccount: Active account set\");\n      const activeAccountValue = {\n        homeAccountId: account.homeAccountId,\n        localAccountId: account.localAccountId,\n        tenantId: account.tenantId\n      };\n      this.browserStorage.setItem(activeAccountKey, JSON.stringify(activeAccountValue));\n    } else {\n      this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\n      this.browserStorage.removeItem(activeAccountKey);\n    }\n    this.eventHandler.emitEvent(EventType.ACTIVE_ACCOUNT_CHANGED);\n  }\n  /**\r\n   * fetch throttling entity from the platform cache\r\n   * @param throttlingCacheKey\r\n   */\n  getThrottlingCache(throttlingCacheKey) {\n    const value = this.browserStorage.getItem(throttlingCacheKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    const parsedThrottlingCache = this.validateAndParseJson(value);\n    if (!parsedThrottlingCache || !CacheHelpers.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n    return parsedThrottlingCache;\n  }\n  /**\r\n   * set throttling entity to the platform cache\r\n   * @param throttlingCacheKey\r\n   * @param throttlingCache\r\n   */\n  setThrottlingCache(throttlingCacheKey, throttlingCache) {\n    this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n    this.browserStorage.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\n  }\n  /**\r\n   * Gets cache item with given key.\r\n   * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n  getTemporaryCache(cacheKey, generateKey) {\n    const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      const itemCookie = this.cookieStorage.getItem(key);\n      if (itemCookie) {\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\n        return itemCookie;\n      }\n    }\n    const value = this.temporaryCacheStorage.getItem(key);\n    if (!value) {\n      // If temp cache item not found in session/memory, check local storage for items set by old versions\n      if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n        const item = this.browserStorage.getItem(key);\n        if (item) {\n          this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\n          return item;\n        }\n      }\n      this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\n    return value;\n  }\n  /**\r\n   * Sets the cache item with the key and value given.\r\n   * Stores in cookie if storeAuthStateInCookie is set to true.\r\n   * This can cause cookie overflow if used incorrectly.\r\n   * @param key\r\n   * @param value\r\n   */\n  setTemporaryCache(cacheKey, value, generateKey) {\n    const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    this.temporaryCacheStorage.setItem(key, value);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\n      this.cookieStorage.setItem(key, value, undefined, this.cacheConfig.secureCookies);\n    }\n  }\n  /**\r\n   * Removes the cache item with the given key.\r\n   * @param key\r\n   */\n  removeItem(key) {\n    this.browserStorage.removeItem(key);\n  }\n  /**\r\n   * Removes the temporary cache item with the given key.\r\n   * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n  removeTemporaryItem(key) {\n    this.temporaryCacheStorage.removeItem(key);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\n      this.cookieStorage.removeItem(key);\n    }\n  }\n  /**\r\n   * Gets all keys in window.\r\n   */\n  getKeys() {\n    return this.browserStorage.getKeys();\n  }\n  /**\r\n   * Clears all cache entries created by MSAL.\r\n   */\n  async clear() {\n    // Removes all accounts and their credentials\n    await this.removeAllAccounts();\n    this.removeAppMetadata();\n    // Remove temp storage first to make sure any cookies are cleared\n    this.temporaryCacheStorage.getKeys().forEach(cacheKey => {\n      if (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(this.clientId) !== -1) {\n        this.removeTemporaryItem(cacheKey);\n      }\n    });\n    // Removes all remaining MSAL cache items\n    this.browserStorage.getKeys().forEach(cacheKey => {\n      if (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(this.clientId) !== -1) {\n        this.browserStorage.removeItem(cacheKey);\n      }\n    });\n    this.internalStorage.clear();\n  }\n  /**\r\n   * Clears all access tokes that have claims prior to saving the current one\r\n   * @param performanceClient {IPerformanceClient}\r\n   * @param correlationId {string} correlation id\r\n   * @returns\r\n   */\n  async clearTokensAndKeysWithClaims(performanceClient, correlationId) {\n    performanceClient.addQueueMeasurement(PerformanceEvents.ClearTokensAndKeysWithClaims, correlationId);\n    const tokenKeys = this.getTokenKeys();\n    const removedAccessTokens = [];\n    tokenKeys.accessToken.forEach(key => {\n      // if the access token has claims in its key, remove the token key and the token\n      const credential = this.getAccessTokenCredential(key);\n      if (credential?.requestedClaimsHash && key.includes(credential.requestedClaimsHash.toLowerCase())) {\n        removedAccessTokens.push(this.removeAccessToken(key));\n      }\n    });\n    await Promise.all(removedAccessTokens);\n    // warn if any access tokens are removed\n    if (removedAccessTokens.length > 0) {\n      this.logger.warning(`${removedAccessTokens.length} access tokens with claims in the cache keys have been removed from the cache.`);\n    }\n  }\n  /**\r\n   * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n   * @param key\r\n   * @param addInstanceId\r\n   */\n  generateCacheKey(key) {\n    const generatedKey = this.validateAndParseJson(key);\n    if (!generatedKey) {\n      if (StringUtils.startsWith(key, Constants.CACHE_PREFIX)) {\n        return key;\n      }\n      return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;\n    }\n    return JSON.stringify(key);\n  }\n  /**\r\n   * Create authorityKey to cache authority\r\n   * @param state\r\n   */\n  generateAuthorityKey(stateString) {\n    const {\n      libraryState: {\n        id: stateId\n      }\n    } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n    return this.generateCacheKey(`${TemporaryCacheKeys.AUTHORITY}.${stateId}`);\n  }\n  /**\r\n   * Create Nonce key to cache nonce\r\n   * @param state\r\n   */\n  generateNonceKey(stateString) {\n    const {\n      libraryState: {\n        id: stateId\n      }\n    } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n    return this.generateCacheKey(`${TemporaryCacheKeys.NONCE_IDTOKEN}.${stateId}`);\n  }\n  /**\r\n   * Creates full cache key for the request state\r\n   * @param stateString State string for the request\r\n   */\n  generateStateKey(stateString) {\n    // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\n    const {\n      libraryState: {\n        id: stateId\n      }\n    } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n    return this.generateCacheKey(`${TemporaryCacheKeys.REQUEST_STATE}.${stateId}`);\n  }\n  /**\r\n   * Gets the cached authority based on the cached state. Returns empty if no cached state found.\r\n   */\n  getCachedAuthority(cachedState) {\n    const stateCacheKey = this.generateStateKey(cachedState);\n    const state = this.getTemporaryCache(stateCacheKey);\n    if (!state) {\n      return null;\n    }\n    const authorityCacheKey = this.generateAuthorityKey(state);\n    return this.getTemporaryCache(authorityCacheKey);\n  }\n  /**\r\n   * Updates account, authority, and state in cache\r\n   * @param serverAuthenticationRequest\r\n   * @param account\r\n   */\n  updateCacheEntries(state, nonce, authorityInstance, loginHint, account) {\n    this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\");\n    // Cache the request state\n    const stateCacheKey = this.generateStateKey(state);\n    this.setTemporaryCache(stateCacheKey, state, false);\n    // Cache the nonce\n    const nonceCacheKey = this.generateNonceKey(state);\n    this.setTemporaryCache(nonceCacheKey, nonce, false);\n    // Cache authorityKey\n    const authorityCacheKey = this.generateAuthorityKey(state);\n    this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\n    if (account) {\n      const ccsCredential = {\n        credential: account.homeAccountId,\n        type: CcsCredentialType.HOME_ACCOUNT_ID\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    } else if (loginHint) {\n      const ccsCredential = {\n        credential: loginHint,\n        type: CcsCredentialType.UPN\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    }\n  }\n  /**\r\n   * Reset all temporary cache items\r\n   * @param state\r\n   */\n  resetRequestCache(state) {\n    this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\n    // check state and remove associated cache items\n    if (state) {\n      this.temporaryCacheStorage.getKeys().forEach(key => {\n        if (key.indexOf(state) !== -1) {\n          this.removeTemporaryItem(key);\n        }\n      });\n      // delete generic interactive request parameters\n      this.removeTemporaryItem(this.generateStateKey(state));\n      this.removeTemporaryItem(this.generateNonceKey(state));\n      this.removeTemporaryItem(this.generateAuthorityKey(state));\n    }\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\n    this.setInteractionInProgress(false);\n  }\n  /**\r\n   * Removes temporary cache for the provided state\r\n   * @param stateString\r\n   */\n  cleanRequestByState(stateString) {\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\");\n    // Interaction is completed - remove interaction status.\n    if (stateString) {\n      const stateKey = this.generateStateKey(stateString);\n      const cachedState = this.temporaryCacheStorage.getItem(stateKey);\n      this.logger.infoPii(`BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: ${cachedState}`);\n      this.resetRequestCache(cachedState || Constants.EMPTY_STRING);\n    }\n  }\n  /**\r\n   * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\r\n   * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\r\n   * @param interactionType\r\n   */\n  cleanRequestByInteractionType(interactionType) {\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\");\n    // Loop through all keys to find state key\n    this.temporaryCacheStorage.getKeys().forEach(key => {\n      // If this key is not the state key, move on\n      if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\n        return;\n      }\n      // Retrieve state value, return if not a valid value\n      const stateValue = this.temporaryCacheStorage.getItem(key);\n      if (!stateValue) {\n        return;\n      }\n      // Extract state and ensure it matches given InteractionType, then clean request cache\n      const parsedState = extractBrowserRequestState(this.cryptoImpl, stateValue);\n      if (parsedState && parsedState.interactionType === interactionType) {\n        this.logger.infoPii(`BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: ${stateValue}`);\n        this.resetRequestCache(stateValue);\n      }\n    });\n    this.setInteractionInProgress(false);\n  }\n  cacheCodeRequest(authCodeRequest) {\n    this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\n    const encodedValue = base64Encode(JSON.stringify(authCodeRequest));\n    this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\n  }\n  /**\r\n   * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n   */\n  getCachedRequest(state) {\n    this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\n    // Get token request from cache and parse as TokenExchangeParameters.\n    const encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\n    if (!encodedTokenRequest) {\n      throw createBrowserAuthError(noTokenRequestCacheError);\n    }\n    let parsedRequest;\n    try {\n      parsedRequest = JSON.parse(base64Decode(encodedTokenRequest));\n    } catch (e) {\n      this.logger.errorPii(`Attempted to parse: ${encodedTokenRequest}`);\n      this.logger.error(`Parsing cached token request threw with error: ${e}`);\n      throw createBrowserAuthError(unableToParseTokenRequestCacheError);\n    }\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    // Get cached authority and use if no authority is cached with request.\n    if (!parsedRequest.authority) {\n      const authorityCacheKey = this.generateAuthorityKey(state);\n      const cachedAuthority = this.getTemporaryCache(authorityCacheKey);\n      if (!cachedAuthority) {\n        throw createBrowserAuthError(noCachedAuthorityError);\n      }\n      parsedRequest.authority = cachedAuthority;\n    }\n    return parsedRequest;\n  }\n  /**\r\n   * Gets cached native request for redirect flows\r\n   */\n  getCachedNativeRequest() {\n    this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n    const cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);\n    if (!cachedRequest) {\n      this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest: No cached native request found\");\n      return null;\n    }\n    const parsedRequest = this.validateAndParseJson(cachedRequest);\n    if (!parsedRequest) {\n      this.logger.error(\"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\");\n      return null;\n    }\n    return parsedRequest;\n  }\n  isInteractionInProgress(matchClientId) {\n    const clientId = this.getInteractionInProgress();\n    if (matchClientId) {\n      return clientId === this.clientId;\n    } else {\n      return !!clientId;\n    }\n  }\n  getInteractionInProgress() {\n    const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n    return this.getTemporaryCache(key, false);\n  }\n  setInteractionInProgress(inProgress) {\n    // Ensure we don't overwrite interaction in progress for a different clientId\n    const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n    if (inProgress) {\n      if (this.getInteractionInProgress()) {\n        throw createBrowserAuthError(interactionInProgress);\n      } else {\n        // No interaction is in progress\n        this.setTemporaryCache(key, this.clientId, false);\n      }\n    } else if (!inProgress && this.getInteractionInProgress() === this.clientId) {\n      this.removeTemporaryItem(key);\n    }\n  }\n  /**\r\n   * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache\r\n   * @param result\r\n   * @param request\r\n   */\n  async hydrateCache(result, request) {\n    const idTokenEntity = CacheHelpers.createIdTokenEntity(result.account?.homeAccountId, result.account?.environment, result.idToken, this.clientId, result.tenantId);\n    let claimsHash;\n    if (request.claims) {\n      claimsHash = await this.cryptoImpl.hashString(request.claims);\n    }\n    /**\r\n     * meta data for cache stores time in seconds from epoch\r\n     * AuthenticationResult returns expiresOn and extExpiresOn in milliseconds (as a Date object which is in ms)\r\n     * We need to map these for the cache when building tokens from AuthenticationResult\r\n     *\r\n     * The next MSAL VFuture should map these both to same value if possible\r\n     */\n    const accessTokenEntity = CacheHelpers.createAccessTokenEntity(result.account?.homeAccountId, result.account.environment, result.accessToken, this.clientId, result.tenantId, result.scopes.join(\" \"), result.expiresOn ? result.expiresOn.getTime() / 1000 : 0, result.extExpiresOn ? result.extExpiresOn.getTime() / 1000 : 0, base64Decode, undefined,\n    // refreshOn\n    result.tokenType, undefined,\n    // userAssertionHash\n    request.sshKid, request.claims, claimsHash);\n    const cacheRecord = {\n      idToken: idTokenEntity,\n      accessToken: accessTokenEntity\n    };\n    return this.saveCacheRecord(cacheRecord, result.correlationId);\n  }\n  /**\r\n   * saves a cache record\r\n   * @param cacheRecord {CacheRecord}\r\n   * @param storeInCache {?StoreInCache}\r\n   * @param correlationId {?string} correlation id\r\n   */\n  async saveCacheRecord(cacheRecord, correlationId, storeInCache) {\n    try {\n      await super.saveCacheRecord(cacheRecord, correlationId, storeInCache);\n    } catch (e) {\n      if (e instanceof CacheError && this.performanceClient && correlationId) {\n        try {\n          const tokenKeys = this.getTokenKeys();\n          this.performanceClient.addFields({\n            cacheRtCount: tokenKeys.refreshToken.length,\n            cacheIdCount: tokenKeys.idToken.length,\n            cacheAtCount: tokenKeys.accessToken.length\n          }, correlationId);\n        } catch (e) {}\n      }\n      throw e;\n    }\n  }\n}\n/**\r\n * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n * @param cacheLocation\r\n */\nfunction getStorageImplementation(clientId, cacheLocation, logger, performanceClient) {\n  try {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n        return new LocalStorage(clientId, logger, performanceClient);\n      case BrowserCacheLocation.SessionStorage:\n        return new SessionStorage();\n      case BrowserCacheLocation.MemoryStorage:\n      default:\n        break;\n    }\n  } catch (e) {\n    logger.error(e);\n  }\n  return new MemoryStorage();\n}\nconst DEFAULT_BROWSER_CACHE_MANAGER = (clientId, logger, performanceClient, eventHandler) => {\n  const cacheOptions = {\n    cacheLocation: BrowserCacheLocation.MemoryStorage,\n    temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\n    storeAuthStateInCookie: false,\n    secureCookies: false,\n    cacheMigrationEnabled: false,\n    claimsBasedCachingEnabled: false\n  };\n  return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger, performanceClient, eventHandler);\n};\nexport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER };","map":{"version":3,"names":["BrowserCacheManager","CacheManager","constructor","clientId","cacheConfig","cryptoImpl","logger","performanceClient","eventHandler","staticAuthorityOptions","internalStorage","MemoryStorage","browserStorage","getStorageImplementation","cacheLocation","temporaryCacheStorage","temporaryCacheLocation","cookieStorage","CookieStorage","initialize","correlationId","validateAndParseJson","jsonValue","parsedJson","JSON","parse","error","getAccount","accountKey","trace","serializedAccount","getUserData","removeAccountKeyFromMap","parsedAccount","AccountEntity","isAccountEntity","toObject","setAccount","account","key","generateAccountKey","invokeAsync","setUserData","bind","PerformanceEvents","SetUserData","stringify","wasAdded","addAccountKeyToMap","BrowserCacheLocation","LocalStorage","emitEvent","EventType","ACCOUNT_ADDED","undefined","getAccountInfo","getAccountKeys","tracePii","accountKeys","indexOf","push","setItem","StaticCacheKeys","ACCOUNT_KEYS","verbose","removalIndex","splice","removeAccount","removeAccountContext","ACCOUNT_REMOVED","removeIdToken","removeTokenKey","CredentialType","ID_TOKEN","removeAccessToken","ACCESS_TOKEN","removeRefreshToken","REFRESH_TOKEN","getTokenKeys","addTokenKey","type","tokenKeys","idToken","info","accessToken","refreshToken","createClientAuthError","ClientAuthErrorCodes","unexpectedCredentialType","TOKEN_KEYS","infoPii","idRemoval","accessRemoval","refreshRemoval","getIdTokenCredential","idTokenKey","value","parsedIdToken","CacheHelpers","isIdTokenEntity","setIdTokenCredential","generateCredentialKey","getAccessTokenCredential","accessTokenKey","parsedAccessToken","isAccessTokenEntity","setAccessTokenCredential","getRefreshTokenCredential","refreshTokenKey","parsedRefreshToken","isRefreshTokenEntity","setRefreshTokenCredential","getAppMetadata","appMetadataKey","getItem","parsedMetadata","isAppMetadataEntity","setAppMetadata","appMetadata","generateAppMetadataKey","getServerTelemetry","serverTelemetryKey","parsedEntity","isServerTelemetryEntity","setServerTelemetry","serverTelemetry","getAuthorityMetadata","isAuthorityMetadataEntity","getAuthorityMetadataKeys","allKeys","getKeys","filter","isAuthorityMetadata","setWrapperMetadata","wrapperSKU","wrapperVersion","InMemoryCacheKeys","WRAPPER_SKU","WRAPPER_VER","getWrapperMetadata","sku","Constants","EMPTY_STRING","version","setAuthorityMetadata","entity","getActiveAccount","activeAccountKeyFilters","generateCacheKey","PersistentCacheKeys","ACTIVE_ACCOUNT_FILTERS","activeAccountValueFilters","activeAccountValueObj","getAccountInfoFilteredBy","homeAccountId","localAccountId","tenantId","setActiveAccount","activeAccountKey","activeAccountValue","removeItem","ACTIVE_ACCOUNT_CHANGED","getThrottlingCache","throttlingCacheKey","parsedThrottlingCache","isThrottlingEntity","setThrottlingCache","throttlingCache","getTemporaryCache","cacheKey","generateKey","storeAuthStateInCookie","itemCookie","item","setTemporaryCache","secureCookies","removeTemporaryItem","clear","removeAllAccounts","removeAppMetadata","forEach","CACHE_PREFIX","clearTokensAndKeysWithClaims","addQueueMeasurement","ClearTokensAndKeysWithClaims","removedAccessTokens","credential","requestedClaimsHash","includes","toLowerCase","Promise","all","length","warning","generatedKey","StringUtils","startsWith","generateAuthorityKey","stateString","libraryState","id","stateId","ProtocolUtils","parseRequestState","TemporaryCacheKeys","AUTHORITY","generateNonceKey","NONCE_IDTOKEN","generateStateKey","REQUEST_STATE","getCachedAuthority","cachedState","stateCacheKey","state","authorityCacheKey","updateCacheEntries","nonce","authorityInstance","loginHint","nonceCacheKey","ccsCredential","CcsCredentialType","HOME_ACCOUNT_ID","CCS_CREDENTIAL","UPN","resetRequestCache","REQUEST_PARAMS","ORIGIN_URI","URL_HASH","CORRELATION_ID","NATIVE_REQUEST","setInteractionInProgress","cleanRequestByState","stateKey","cleanRequestByInteractionType","interactionType","stateValue","parsedState","extractBrowserRequestState","cacheCodeRequest","authCodeRequest","encodedValue","base64Encode","getCachedRequest","encodedTokenRequest","createBrowserAuthError","noTokenRequestCacheError","parsedRequest","base64Decode","e","errorPii","unableToParseTokenRequestCacheError","authority","cachedAuthority","noCachedAuthorityError","getCachedNativeRequest","cachedRequest","isInteractionInProgress","matchClientId","getInteractionInProgress","INTERACTION_STATUS_KEY","inProgress","interactionInProgress","hydrateCache","result","request","idTokenEntity","createIdTokenEntity","environment","claimsHash","claims","hashString","accessTokenEntity","createAccessTokenEntity","scopes","join","expiresOn","getTime","extExpiresOn","tokenType","sshKid","cacheRecord","saveCacheRecord","storeInCache","CacheError","addFields","cacheRtCount","cacheIdCount","cacheAtCount","SessionStorage","DEFAULT_BROWSER_CACHE_MANAGER","cacheOptions","cacheMigrationEnabled","claimsBasedCachingEnabled","DEFAULT_CRYPTO_IMPLEMENTATION"],"sources":["C:\\bytepantry\\frontend\\node_modules\\@azure\\msal-browser\\src\\cache\\BrowserCacheManager.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    Constants,\r\n    PersistentCacheKeys,\r\n    StringUtils,\r\n    CommonAuthorizationCodeRequest,\r\n    ICrypto,\r\n    AccountEntity,\r\n    IdTokenEntity,\r\n    AccessTokenEntity,\r\n    RefreshTokenEntity,\r\n    AppMetadataEntity,\r\n    CacheManager,\r\n    ServerTelemetryEntity,\r\n    ThrottlingEntity,\r\n    ProtocolUtils,\r\n    Logger,\r\n    AuthorityMetadataEntity,\r\n    DEFAULT_CRYPTO_IMPLEMENTATION,\r\n    AccountInfo,\r\n    ActiveAccountFilters,\r\n    CcsCredential,\r\n    CcsCredentialType,\r\n    TokenKeys,\r\n    CredentialType,\r\n    CacheRecord,\r\n    AuthenticationScheme,\r\n    createClientAuthError,\r\n    ClientAuthErrorCodes,\r\n    PerformanceEvents,\r\n    IPerformanceClient,\r\n    StaticAuthorityOptions,\r\n    CacheHelpers,\r\n    StoreInCache,\r\n    CacheError,\r\n    invokeAsync,\r\n} from \"@azure/msal-common/browser\";\r\nimport { CacheOptions } from \"../config/Configuration.js\";\r\nimport {\r\n    createBrowserAuthError,\r\n    BrowserAuthErrorCodes,\r\n} from \"../error/BrowserAuthError.js\";\r\nimport {\r\n    BrowserCacheLocation,\r\n    InteractionType,\r\n    TemporaryCacheKeys,\r\n    InMemoryCacheKeys,\r\n    StaticCacheKeys,\r\n} from \"../utils/BrowserConstants.js\";\r\nimport { LocalStorage } from \"./LocalStorage.js\";\r\nimport { SessionStorage } from \"./SessionStorage.js\";\r\nimport { MemoryStorage } from \"./MemoryStorage.js\";\r\nimport { IWindowStorage } from \"./IWindowStorage.js\";\r\nimport { extractBrowserRequestState } from \"../utils/BrowserProtocolUtils.js\";\r\nimport { NativeTokenRequest } from \"../broker/nativeBroker/NativeRequest.js\";\r\nimport { AuthenticationResult } from \"../response/AuthenticationResult.js\";\r\nimport { SilentRequest } from \"../request/SilentRequest.js\";\r\nimport { SsoSilentRequest } from \"../request/SsoSilentRequest.js\";\r\nimport { RedirectRequest } from \"../request/RedirectRequest.js\";\r\nimport { PopupRequest } from \"../request/PopupRequest.js\";\r\nimport { base64Decode } from \"../encode/Base64Decode.js\";\r\nimport { base64Encode } from \"../encode/Base64Encode.js\";\r\nimport { CookieStorage } from \"./CookieStorage.js\";\r\nimport { getAccountKeys, getTokenKeys } from \"./CacheHelpers.js\";\r\nimport { EventType } from \"../event/EventType.js\";\r\nimport { EventHandler } from \"../event/EventHandler.js\";\r\n\r\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\r\nexport class BrowserCacheManager extends CacheManager {\r\n    // Cache configuration, either set by user or default values.\r\n    protected cacheConfig: Required<CacheOptions>;\r\n    // Window storage object (either local or sessionStorage)\r\n    protected browserStorage: IWindowStorage<string>;\r\n    // Internal in-memory storage object used for data used by msal that does not need to persist across page loads\r\n    protected internalStorage: MemoryStorage<string>;\r\n    // Temporary cache\r\n    protected temporaryCacheStorage: IWindowStorage<string>;\r\n    // Cookie storage\r\n    protected cookieStorage: CookieStorage;\r\n    // Logger instance\r\n    protected logger: Logger;\r\n    // Telemetry perf client\r\n    protected performanceClient: IPerformanceClient;\r\n    // Event Handler\r\n    private eventHandler: EventHandler;\r\n\r\n    constructor(\r\n        clientId: string,\r\n        cacheConfig: Required<CacheOptions>,\r\n        cryptoImpl: ICrypto,\r\n        logger: Logger,\r\n        performanceClient: IPerformanceClient,\r\n        eventHandler: EventHandler,\r\n        staticAuthorityOptions?: StaticAuthorityOptions\r\n    ) {\r\n        super(clientId, cryptoImpl, logger, staticAuthorityOptions);\r\n        this.cacheConfig = cacheConfig;\r\n        this.logger = logger;\r\n        this.internalStorage = new MemoryStorage();\r\n        this.browserStorage = getStorageImplementation(\r\n            clientId,\r\n            cacheConfig.cacheLocation,\r\n            logger,\r\n            performanceClient\r\n        );\r\n        this.temporaryCacheStorage = getStorageImplementation(\r\n            clientId,\r\n            cacheConfig.temporaryCacheLocation,\r\n            logger,\r\n            performanceClient\r\n        );\r\n        this.cookieStorage = new CookieStorage();\r\n\r\n        this.performanceClient = performanceClient;\r\n        this.eventHandler = eventHandler;\r\n    }\r\n\r\n    async initialize(correlationId: string): Promise<void> {\r\n        await this.browserStorage.initialize(correlationId);\r\n    }\r\n\r\n    /**\r\n     * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n     * @param input\r\n     */\r\n    protected validateAndParseJson(jsonValue: string): object | null {\r\n        try {\r\n            const parsedJson = JSON.parse(jsonValue);\r\n            /**\r\n             * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n             * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n             * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n             *\r\n             */\r\n            return parsedJson && typeof parsedJson === \"object\"\r\n                ? parsedJson\r\n                : null;\r\n        } catch (error) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reads account from cache, deserializes it into an account entity and returns it.\r\n     * If account is not found from the key, returns null and removes key from map.\r\n     * @param accountKey\r\n     * @returns\r\n     */\r\n    getAccount(accountKey: string): AccountEntity | null {\r\n        this.logger.trace(\"BrowserCacheManager.getAccount called\");\r\n        const serializedAccount = this.browserStorage.getUserData(accountKey);\r\n        if (!serializedAccount) {\r\n            this.removeAccountKeyFromMap(accountKey);\r\n            return null;\r\n        }\r\n\r\n        const parsedAccount = this.validateAndParseJson(serializedAccount);\r\n        if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\r\n            this.removeAccountKeyFromMap(accountKey);\r\n            return null;\r\n        }\r\n\r\n        return CacheManager.toObject<AccountEntity>(\r\n            new AccountEntity(),\r\n            parsedAccount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * set account entity in the platform cache\r\n     * @param account\r\n     */\r\n    async setAccount(\r\n        account: AccountEntity,\r\n        correlationId: string\r\n    ): Promise<void> {\r\n        this.logger.trace(\"BrowserCacheManager.setAccount called\");\r\n        const key = account.generateAccountKey();\r\n        await invokeAsync(\r\n            this.browserStorage.setUserData.bind(this.browserStorage),\r\n            PerformanceEvents.SetUserData,\r\n            this.logger,\r\n            this.performanceClient\r\n        )(key, JSON.stringify(account), correlationId);\r\n        const wasAdded = this.addAccountKeyToMap(key);\r\n\r\n        /**\r\n         * @deprecated - Remove this in next major version in favor of more consistent LOGIN event\r\n         */\r\n        if (\r\n            this.cacheConfig.cacheLocation ===\r\n                BrowserCacheLocation.LocalStorage &&\r\n            wasAdded\r\n        ) {\r\n            this.eventHandler.emitEvent(\r\n                EventType.ACCOUNT_ADDED,\r\n                undefined,\r\n                account.getAccountInfo()\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the array of account keys currently cached\r\n     * @returns\r\n     */\r\n    getAccountKeys(): Array<string> {\r\n        return getAccountKeys(this.browserStorage);\r\n    }\r\n\r\n    /**\r\n     * Add a new account to the key map\r\n     * @param key\r\n     */\r\n    addAccountKeyToMap(key: string): boolean {\r\n        this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\r\n        this.logger.tracePii(\r\n            `BrowserCacheManager.addAccountKeyToMap called with key: ${key}`\r\n        );\r\n        const accountKeys = this.getAccountKeys();\r\n        if (accountKeys.indexOf(key) === -1) {\r\n            // Only add key if it does not already exist in the map\r\n            accountKeys.push(key);\r\n            this.browserStorage.setItem(\r\n                StaticCacheKeys.ACCOUNT_KEYS,\r\n                JSON.stringify(accountKeys)\r\n            );\r\n            this.logger.verbose(\r\n                \"BrowserCacheManager.addAccountKeyToMap account key added\"\r\n            );\r\n            return true;\r\n        } else {\r\n            this.logger.verbose(\r\n                \"BrowserCacheManager.addAccountKeyToMap account key already exists in map\"\r\n            );\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove an account from the key map\r\n     * @param key\r\n     */\r\n    removeAccountKeyFromMap(key: string): void {\r\n        this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\r\n        this.logger.tracePii(\r\n            `BrowserCacheManager.removeAccountKeyFromMap called with key: ${key}`\r\n        );\r\n        const accountKeys = this.getAccountKeys();\r\n        const removalIndex = accountKeys.indexOf(key);\r\n        if (removalIndex > -1) {\r\n            accountKeys.splice(removalIndex, 1);\r\n            this.browserStorage.setItem(\r\n                StaticCacheKeys.ACCOUNT_KEYS,\r\n                JSON.stringify(accountKeys)\r\n            );\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.removeAccountKeyFromMap account key removed\"\r\n            );\r\n        } else {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extends inherited removeAccount function to include removal of the account key from the map\r\n     * @param key\r\n     */\r\n    async removeAccount(key: string): Promise<void> {\r\n        void super.removeAccount(key);\r\n        this.removeAccountKeyFromMap(key);\r\n    }\r\n\r\n    /**\r\n     * Removes credentials associated with the provided account\r\n     * @param account\r\n     */\r\n    async removeAccountContext(account: AccountEntity): Promise<void> {\r\n        await super.removeAccountContext(account);\r\n\r\n        /**\r\n         * @deprecated - Remove this in next major version in favor of more consistent LOGOUT event\r\n         */\r\n        if (\r\n            this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage\r\n        ) {\r\n            this.eventHandler.emitEvent(\r\n                EventType.ACCOUNT_REMOVED,\r\n                undefined,\r\n                account.getAccountInfo()\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes given idToken from the cache and from the key map\r\n     * @param key\r\n     */\r\n    removeIdToken(key: string): void {\r\n        super.removeIdToken(key);\r\n        this.removeTokenKey(key, CredentialType.ID_TOKEN);\r\n    }\r\n\r\n    /**\r\n     * Removes given accessToken from the cache and from the key map\r\n     * @param key\r\n     */\r\n    async removeAccessToken(key: string): Promise<void> {\r\n        void super.removeAccessToken(key);\r\n        this.removeTokenKey(key, CredentialType.ACCESS_TOKEN);\r\n    }\r\n\r\n    /**\r\n     * Removes given refreshToken from the cache and from the key map\r\n     * @param key\r\n     */\r\n    removeRefreshToken(key: string): void {\r\n        super.removeRefreshToken(key);\r\n        this.removeTokenKey(key, CredentialType.REFRESH_TOKEN);\r\n    }\r\n\r\n    /**\r\n     * Gets the keys for the cached tokens associated with this clientId\r\n     * @returns\r\n     */\r\n    getTokenKeys(): TokenKeys {\r\n        return getTokenKeys(this.clientId, this.browserStorage);\r\n    }\r\n\r\n    /**\r\n     * Adds the given key to the token key map\r\n     * @param key\r\n     * @param type\r\n     */\r\n    addTokenKey(key: string, type: CredentialType): void {\r\n        this.logger.trace(\"BrowserCacheManager addTokenKey called\");\r\n        const tokenKeys = this.getTokenKeys();\r\n\r\n        switch (type) {\r\n            case CredentialType.ID_TOKEN:\r\n                if (tokenKeys.idToken.indexOf(key) === -1) {\r\n                    this.logger.info(\r\n                        \"BrowserCacheManager: addTokenKey - idToken added to map\"\r\n                    );\r\n                    tokenKeys.idToken.push(key);\r\n                }\r\n                break;\r\n            case CredentialType.ACCESS_TOKEN:\r\n                if (tokenKeys.accessToken.indexOf(key) === -1) {\r\n                    this.logger.info(\r\n                        \"BrowserCacheManager: addTokenKey - accessToken added to map\"\r\n                    );\r\n                    tokenKeys.accessToken.push(key);\r\n                }\r\n                break;\r\n            case CredentialType.REFRESH_TOKEN:\r\n                if (tokenKeys.refreshToken.indexOf(key) === -1) {\r\n                    this.logger.info(\r\n                        \"BrowserCacheManager: addTokenKey - refreshToken added to map\"\r\n                    );\r\n                    tokenKeys.refreshToken.push(key);\r\n                }\r\n                break;\r\n            default:\r\n                this.logger.error(\r\n                    `BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: ${type}`\r\n                );\r\n                throw createClientAuthError(\r\n                    ClientAuthErrorCodes.unexpectedCredentialType\r\n                );\r\n        }\r\n\r\n        this.browserStorage.setItem(\r\n            `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`,\r\n            JSON.stringify(tokenKeys)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Removes the given key from the token key map\r\n     * @param key\r\n     * @param type\r\n     */\r\n    removeTokenKey(key: string, type: CredentialType): void {\r\n        this.logger.trace(\"BrowserCacheManager removeTokenKey called\");\r\n        const tokenKeys = this.getTokenKeys();\r\n\r\n        switch (type) {\r\n            case CredentialType.ID_TOKEN:\r\n                this.logger.infoPii(\r\n                    `BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: ${key} from map`\r\n                );\r\n                const idRemoval = tokenKeys.idToken.indexOf(key);\r\n                if (idRemoval > -1) {\r\n                    this.logger.info(\r\n                        \"BrowserCacheManager: removeTokenKey - idToken removed from map\"\r\n                    );\r\n                    tokenKeys.idToken.splice(idRemoval, 1);\r\n                } else {\r\n                    this.logger.info(\r\n                        \"BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.\"\r\n                    );\r\n                }\r\n                break;\r\n            case CredentialType.ACCESS_TOKEN:\r\n                this.logger.infoPii(\r\n                    `BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: ${key} from map`\r\n                );\r\n                const accessRemoval = tokenKeys.accessToken.indexOf(key);\r\n                if (accessRemoval > -1) {\r\n                    this.logger.info(\r\n                        \"BrowserCacheManager: removeTokenKey - accessToken removed from map\"\r\n                    );\r\n                    tokenKeys.accessToken.splice(accessRemoval, 1);\r\n                } else {\r\n                    this.logger.info(\r\n                        \"BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.\"\r\n                    );\r\n                }\r\n                break;\r\n            case CredentialType.REFRESH_TOKEN:\r\n                this.logger.infoPii(\r\n                    `BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: ${key} from map`\r\n                );\r\n                const refreshRemoval = tokenKeys.refreshToken.indexOf(key);\r\n                if (refreshRemoval > -1) {\r\n                    this.logger.info(\r\n                        \"BrowserCacheManager: removeTokenKey - refreshToken removed from map\"\r\n                    );\r\n                    tokenKeys.refreshToken.splice(refreshRemoval, 1);\r\n                } else {\r\n                    this.logger.info(\r\n                        \"BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.\"\r\n                    );\r\n                }\r\n                break;\r\n            default:\r\n                this.logger.error(\r\n                    `BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: ${type}`\r\n                );\r\n                throw createClientAuthError(\r\n                    ClientAuthErrorCodes.unexpectedCredentialType\r\n                );\r\n        }\r\n\r\n        this.browserStorage.setItem(\r\n            `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`,\r\n            JSON.stringify(tokenKeys)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * generates idToken entity from a string\r\n     * @param idTokenKey\r\n     */\r\n    getIdTokenCredential(idTokenKey: string): IdTokenEntity | null {\r\n        const value = this.browserStorage.getUserData(idTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getIdTokenCredential: called, no cache hit\"\r\n            );\r\n            this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\r\n            return null;\r\n        }\r\n\r\n        const parsedIdToken = this.validateAndParseJson(value);\r\n        if (!parsedIdToken || !CacheHelpers.isIdTokenEntity(parsedIdToken)) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getIdTokenCredential: called, no cache hit\"\r\n            );\r\n            this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\r\n            \"BrowserCacheManager.getIdTokenCredential: cache hit\"\r\n        );\r\n        return parsedIdToken as IdTokenEntity;\r\n    }\r\n\r\n    /**\r\n     * set IdToken credential to the platform cache\r\n     * @param idToken\r\n     */\r\n    async setIdTokenCredential(\r\n        idToken: IdTokenEntity,\r\n        correlationId: string\r\n    ): Promise<void> {\r\n        this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\r\n        const idTokenKey = CacheHelpers.generateCredentialKey(idToken);\r\n\r\n        await invokeAsync(\r\n            this.browserStorage.setUserData.bind(this.browserStorage),\r\n            PerformanceEvents.SetUserData,\r\n            this.logger,\r\n            this.performanceClient\r\n        )(idTokenKey, JSON.stringify(idToken), correlationId);\r\n\r\n        this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN);\r\n    }\r\n\r\n    /**\r\n     * generates accessToken entity from a string\r\n     * @param key\r\n     */\r\n    getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null {\r\n        const value = this.browserStorage.getUserData(accessTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\"\r\n            );\r\n            this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\r\n            return null;\r\n        }\r\n        const parsedAccessToken = this.validateAndParseJson(value);\r\n        if (\r\n            !parsedAccessToken ||\r\n            !CacheHelpers.isAccessTokenEntity(parsedAccessToken)\r\n        ) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\"\r\n            );\r\n            this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\r\n            \"BrowserCacheManager.getAccessTokenCredential: cache hit\"\r\n        );\r\n        return parsedAccessToken as AccessTokenEntity;\r\n    }\r\n\r\n    /**\r\n     * set accessToken credential to the platform cache\r\n     * @param accessToken\r\n     */\r\n    async setAccessTokenCredential(\r\n        accessToken: AccessTokenEntity,\r\n        correlationId: string\r\n    ): Promise<void> {\r\n        this.logger.trace(\r\n            \"BrowserCacheManager.setAccessTokenCredential called\"\r\n        );\r\n        const accessTokenKey = CacheHelpers.generateCredentialKey(accessToken);\r\n        await invokeAsync(\r\n            this.browserStorage.setUserData.bind(this.browserStorage),\r\n            PerformanceEvents.SetUserData,\r\n            this.logger,\r\n            this.performanceClient\r\n        )(accessTokenKey, JSON.stringify(accessToken), correlationId);\r\n\r\n        this.addTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\r\n    }\r\n\r\n    /**\r\n     * generates refreshToken entity from a string\r\n     * @param refreshTokenKey\r\n     */\r\n    getRefreshTokenCredential(\r\n        refreshTokenKey: string\r\n    ): RefreshTokenEntity | null {\r\n        const value = this.browserStorage.getUserData(refreshTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\"\r\n            );\r\n            this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\r\n            return null;\r\n        }\r\n        const parsedRefreshToken = this.validateAndParseJson(value);\r\n        if (\r\n            !parsedRefreshToken ||\r\n            !CacheHelpers.isRefreshTokenEntity(parsedRefreshToken)\r\n        ) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\"\r\n            );\r\n            this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\r\n            \"BrowserCacheManager.getRefreshTokenCredential: cache hit\"\r\n        );\r\n        return parsedRefreshToken as RefreshTokenEntity;\r\n    }\r\n\r\n    /**\r\n     * set refreshToken credential to the platform cache\r\n     * @param refreshToken\r\n     */\r\n    async setRefreshTokenCredential(\r\n        refreshToken: RefreshTokenEntity,\r\n        correlationId: string\r\n    ): Promise<void> {\r\n        this.logger.trace(\r\n            \"BrowserCacheManager.setRefreshTokenCredential called\"\r\n        );\r\n        const refreshTokenKey =\r\n            CacheHelpers.generateCredentialKey(refreshToken);\r\n        await invokeAsync(\r\n            this.browserStorage.setUserData.bind(this.browserStorage),\r\n            PerformanceEvents.SetUserData,\r\n            this.logger,\r\n            this.performanceClient\r\n        )(refreshTokenKey, JSON.stringify(refreshToken), correlationId);\r\n\r\n        this.addTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\r\n    }\r\n\r\n    /**\r\n     * fetch appMetadata entity from the platform cache\r\n     * @param appMetadataKey\r\n     */\r\n    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null {\r\n        const value = this.browserStorage.getItem(appMetadataKey);\r\n        if (!value) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getAppMetadata: called, no cache hit\"\r\n            );\r\n            return null;\r\n        }\r\n\r\n        const parsedMetadata = this.validateAndParseJson(value);\r\n        if (\r\n            !parsedMetadata ||\r\n            !CacheHelpers.isAppMetadataEntity(appMetadataKey, parsedMetadata)\r\n        ) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getAppMetadata: called, no cache hit\"\r\n            );\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\r\n        return parsedMetadata as AppMetadataEntity;\r\n    }\r\n\r\n    /**\r\n     * set appMetadata entity to the platform cache\r\n     * @param appMetadata\r\n     */\r\n    setAppMetadata(appMetadata: AppMetadataEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\r\n        const appMetadataKey = CacheHelpers.generateAppMetadataKey(appMetadata);\r\n        this.browserStorage.setItem(\r\n            appMetadataKey,\r\n            JSON.stringify(appMetadata)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * fetch server telemetry entity from the platform cache\r\n     * @param serverTelemetryKey\r\n     */\r\n    getServerTelemetry(\r\n        serverTelemetryKey: string\r\n    ): ServerTelemetryEntity | null {\r\n        const value = this.browserStorage.getItem(serverTelemetryKey);\r\n        if (!value) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getServerTelemetry: called, no cache hit\"\r\n            );\r\n            return null;\r\n        }\r\n        const parsedEntity = this.validateAndParseJson(value);\r\n        if (\r\n            !parsedEntity ||\r\n            !CacheHelpers.isServerTelemetryEntity(\r\n                serverTelemetryKey,\r\n                parsedEntity\r\n            )\r\n        ) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getServerTelemetry: called, no cache hit\"\r\n            );\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\r\n        return parsedEntity as ServerTelemetryEntity;\r\n    }\r\n\r\n    /**\r\n     * set server telemetry entity to the platform cache\r\n     * @param serverTelemetryKey\r\n     * @param serverTelemetry\r\n     */\r\n    setServerTelemetry(\r\n        serverTelemetryKey: string,\r\n        serverTelemetry: ServerTelemetryEntity\r\n    ): void {\r\n        this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\r\n        this.browserStorage.setItem(\r\n            serverTelemetryKey,\r\n            JSON.stringify(serverTelemetry)\r\n        );\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    getAuthorityMetadata(key: string): AuthorityMetadataEntity | null {\r\n        const value = this.internalStorage.getItem(key);\r\n        if (!value) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\"\r\n            );\r\n            return null;\r\n        }\r\n        const parsedMetadata = this.validateAndParseJson(value);\r\n        if (\r\n            parsedMetadata &&\r\n            CacheHelpers.isAuthorityMetadataEntity(key, parsedMetadata)\r\n        ) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getAuthorityMetadata: cache hit\"\r\n            );\r\n            return parsedMetadata as AuthorityMetadataEntity;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    getAuthorityMetadataKeys(): Array<string> {\r\n        const allKeys = this.internalStorage.getKeys();\r\n        return allKeys.filter((key) => {\r\n            return this.isAuthorityMetadata(key);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets wrapper metadata in memory\r\n     * @param wrapperSKU\r\n     * @param wrapperVersion\r\n     */\r\n    setWrapperMetadata(wrapperSKU: string, wrapperVersion: string): void {\r\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\r\n        this.internalStorage.setItem(\r\n            InMemoryCacheKeys.WRAPPER_VER,\r\n            wrapperVersion\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns wrapper metadata from in-memory storage\r\n     */\r\n    getWrapperMetadata(): [string, string] {\r\n        const sku =\r\n            this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) ||\r\n            Constants.EMPTY_STRING;\r\n        const version =\r\n            this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) ||\r\n            Constants.EMPTY_STRING;\r\n        return [sku, version];\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param entity\r\n     */\r\n    setAuthorityMetadata(key: string, entity: AuthorityMetadataEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\r\n        this.internalStorage.setItem(key, JSON.stringify(entity));\r\n    }\r\n\r\n    /**\r\n     * Gets the active account\r\n     */\r\n    getActiveAccount(): AccountInfo | null {\r\n        const activeAccountKeyFilters = this.generateCacheKey(\r\n            PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS\r\n        );\r\n        const activeAccountValueFilters = this.browserStorage.getItem(\r\n            activeAccountKeyFilters\r\n        );\r\n        if (!activeAccountValueFilters) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getActiveAccount: No active account filters found\"\r\n            );\r\n            return null;\r\n        }\r\n        const activeAccountValueObj = this.validateAndParseJson(\r\n            activeAccountValueFilters\r\n        ) as AccountInfo;\r\n        if (activeAccountValueObj) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getActiveAccount: Active account filters schema found\"\r\n            );\r\n            return this.getAccountInfoFilteredBy({\r\n                homeAccountId: activeAccountValueObj.homeAccountId,\r\n                localAccountId: activeAccountValueObj.localAccountId,\r\n                tenantId: activeAccountValueObj.tenantId,\r\n            });\r\n        }\r\n        this.logger.trace(\r\n            \"BrowserCacheManager.getActiveAccount: No active account found\"\r\n        );\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the active account's localAccountId in cache\r\n     * @param account\r\n     */\r\n    setActiveAccount(account: AccountInfo | null): void {\r\n        const activeAccountKey = this.generateCacheKey(\r\n            PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS\r\n        );\r\n        if (account) {\r\n            this.logger.verbose(\"setActiveAccount: Active account set\");\r\n            const activeAccountValue: ActiveAccountFilters = {\r\n                homeAccountId: account.homeAccountId,\r\n                localAccountId: account.localAccountId,\r\n                tenantId: account.tenantId,\r\n            };\r\n            this.browserStorage.setItem(\r\n                activeAccountKey,\r\n                JSON.stringify(activeAccountValue)\r\n            );\r\n        } else {\r\n            this.logger.verbose(\r\n                \"setActiveAccount: No account passed, active account not set\"\r\n            );\r\n            this.browserStorage.removeItem(activeAccountKey);\r\n        }\r\n        this.eventHandler.emitEvent(EventType.ACTIVE_ACCOUNT_CHANGED);\r\n    }\r\n\r\n    /**\r\n     * fetch throttling entity from the platform cache\r\n     * @param throttlingCacheKey\r\n     */\r\n    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null {\r\n        const value = this.browserStorage.getItem(throttlingCacheKey);\r\n        if (!value) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getThrottlingCache: called, no cache hit\"\r\n            );\r\n            return null;\r\n        }\r\n\r\n        const parsedThrottlingCache = this.validateAndParseJson(value);\r\n        if (\r\n            !parsedThrottlingCache ||\r\n            !CacheHelpers.isThrottlingEntity(\r\n                throttlingCacheKey,\r\n                parsedThrottlingCache\r\n            )\r\n        ) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getThrottlingCache: called, no cache hit\"\r\n            );\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\r\n        return parsedThrottlingCache as ThrottlingEntity;\r\n    }\r\n\r\n    /**\r\n     * set throttling entity to the platform cache\r\n     * @param throttlingCacheKey\r\n     * @param throttlingCache\r\n     */\r\n    setThrottlingCache(\r\n        throttlingCacheKey: string,\r\n        throttlingCache: ThrottlingEntity\r\n    ): void {\r\n        this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\r\n        this.browserStorage.setItem(\r\n            throttlingCacheKey,\r\n            JSON.stringify(throttlingCache)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets cache item with given key.\r\n     * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n     * @param key\r\n     */\r\n    getTemporaryCache(cacheKey: string, generateKey?: boolean): string | null {\r\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            const itemCookie = this.cookieStorage.getItem(key);\r\n            if (itemCookie) {\r\n                this.logger.trace(\r\n                    \"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\"\r\n                );\r\n                return itemCookie;\r\n            }\r\n        }\r\n\r\n        const value = this.temporaryCacheStorage.getItem(key);\r\n        if (!value) {\r\n            // If temp cache item not found in session/memory, check local storage for items set by old versions\r\n            if (\r\n                this.cacheConfig.cacheLocation ===\r\n                BrowserCacheLocation.LocalStorage\r\n            ) {\r\n                const item = this.browserStorage.getItem(key);\r\n                if (item) {\r\n                    this.logger.trace(\r\n                        \"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\"\r\n                    );\r\n                    return item;\r\n                }\r\n            }\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\"\r\n            );\r\n            return null;\r\n        }\r\n        this.logger.trace(\r\n            \"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\"\r\n        );\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Sets the cache item with the key and value given.\r\n     * Stores in cookie if storeAuthStateInCookie is set to true.\r\n     * This can cause cookie overflow if used incorrectly.\r\n     * @param key\r\n     * @param value\r\n     */\r\n    setTemporaryCache(\r\n        cacheKey: string,\r\n        value: string,\r\n        generateKey?: boolean\r\n    ): void {\r\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\r\n\r\n        this.temporaryCacheStorage.setItem(key, value);\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\"\r\n            );\r\n            this.cookieStorage.setItem(\r\n                key,\r\n                value,\r\n                undefined,\r\n                this.cacheConfig.secureCookies\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the cache item with the given key.\r\n     * @param key\r\n     */\r\n    removeItem(key: string): void {\r\n        this.browserStorage.removeItem(key);\r\n    }\r\n\r\n    /**\r\n     * Removes the temporary cache item with the given key.\r\n     * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n     * @param key\r\n     */\r\n    removeTemporaryItem(key: string): void {\r\n        this.temporaryCacheStorage.removeItem(key);\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\"\r\n            );\r\n            this.cookieStorage.removeItem(key);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets all keys in window.\r\n     */\r\n    getKeys(): string[] {\r\n        return this.browserStorage.getKeys();\r\n    }\r\n\r\n    /**\r\n     * Clears all cache entries created by MSAL.\r\n     */\r\n    async clear(): Promise<void> {\r\n        // Removes all accounts and their credentials\r\n        await this.removeAllAccounts();\r\n        this.removeAppMetadata();\r\n\r\n        // Remove temp storage first to make sure any cookies are cleared\r\n        this.temporaryCacheStorage.getKeys().forEach((cacheKey: string) => {\r\n            if (\r\n                cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 ||\r\n                cacheKey.indexOf(this.clientId) !== -1\r\n            ) {\r\n                this.removeTemporaryItem(cacheKey);\r\n            }\r\n        });\r\n\r\n        // Removes all remaining MSAL cache items\r\n        this.browserStorage.getKeys().forEach((cacheKey: string) => {\r\n            if (\r\n                cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 ||\r\n                cacheKey.indexOf(this.clientId) !== -1\r\n            ) {\r\n                this.browserStorage.removeItem(cacheKey);\r\n            }\r\n        });\r\n\r\n        this.internalStorage.clear();\r\n    }\r\n\r\n    /**\r\n     * Clears all access tokes that have claims prior to saving the current one\r\n     * @param performanceClient {IPerformanceClient}\r\n     * @param correlationId {string} correlation id\r\n     * @returns\r\n     */\r\n    async clearTokensAndKeysWithClaims(\r\n        performanceClient: IPerformanceClient,\r\n        correlationId: string\r\n    ): Promise<void> {\r\n        performanceClient.addQueueMeasurement(\r\n            PerformanceEvents.ClearTokensAndKeysWithClaims,\r\n            correlationId\r\n        );\r\n\r\n        const tokenKeys = this.getTokenKeys();\r\n\r\n        const removedAccessTokens: Array<Promise<void>> = [];\r\n        tokenKeys.accessToken.forEach((key: string) => {\r\n            // if the access token has claims in its key, remove the token key and the token\r\n            const credential = this.getAccessTokenCredential(key);\r\n            if (\r\n                credential?.requestedClaimsHash &&\r\n                key.includes(credential.requestedClaimsHash.toLowerCase())\r\n            ) {\r\n                removedAccessTokens.push(this.removeAccessToken(key));\r\n            }\r\n        });\r\n        await Promise.all(removedAccessTokens);\r\n\r\n        // warn if any access tokens are removed\r\n        if (removedAccessTokens.length > 0) {\r\n            this.logger.warning(\r\n                `${removedAccessTokens.length} access tokens with claims in the cache keys have been removed from the cache.`\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n     * @param key\r\n     * @param addInstanceId\r\n     */\r\n    generateCacheKey(key: string): string {\r\n        const generatedKey = this.validateAndParseJson(key);\r\n        if (!generatedKey) {\r\n            if (StringUtils.startsWith(key, Constants.CACHE_PREFIX)) {\r\n                return key;\r\n            }\r\n            return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;\r\n        }\r\n\r\n        return JSON.stringify(key);\r\n    }\r\n\r\n    /**\r\n     * Create authorityKey to cache authority\r\n     * @param state\r\n     */\r\n    generateAuthorityKey(stateString: string): string {\r\n        const {\r\n            libraryState: { id: stateId },\r\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\r\n\r\n        return this.generateCacheKey(\r\n            `${TemporaryCacheKeys.AUTHORITY}.${stateId}`\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Create Nonce key to cache nonce\r\n     * @param state\r\n     */\r\n    generateNonceKey(stateString: string): string {\r\n        const {\r\n            libraryState: { id: stateId },\r\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\r\n\r\n        return this.generateCacheKey(\r\n            `${TemporaryCacheKeys.NONCE_IDTOKEN}.${stateId}`\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates full cache key for the request state\r\n     * @param stateString State string for the request\r\n     */\r\n    generateStateKey(stateString: string): string {\r\n        // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\r\n        const {\r\n            libraryState: { id: stateId },\r\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\r\n        return this.generateCacheKey(\r\n            `${TemporaryCacheKeys.REQUEST_STATE}.${stateId}`\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the cached authority based on the cached state. Returns empty if no cached state found.\r\n     */\r\n    getCachedAuthority(cachedState: string): string | null {\r\n        const stateCacheKey = this.generateStateKey(cachedState);\r\n        const state = this.getTemporaryCache(stateCacheKey);\r\n        if (!state) {\r\n            return null;\r\n        }\r\n\r\n        const authorityCacheKey = this.generateAuthorityKey(state);\r\n        return this.getTemporaryCache(authorityCacheKey);\r\n    }\r\n\r\n    /**\r\n     * Updates account, authority, and state in cache\r\n     * @param serverAuthenticationRequest\r\n     * @param account\r\n     */\r\n    updateCacheEntries(\r\n        state: string,\r\n        nonce: string,\r\n        authorityInstance: string,\r\n        loginHint: string,\r\n        account: AccountInfo | null\r\n    ): void {\r\n        this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\");\r\n        // Cache the request state\r\n        const stateCacheKey = this.generateStateKey(state);\r\n        this.setTemporaryCache(stateCacheKey, state, false);\r\n\r\n        // Cache the nonce\r\n        const nonceCacheKey = this.generateNonceKey(state);\r\n        this.setTemporaryCache(nonceCacheKey, nonce, false);\r\n\r\n        // Cache authorityKey\r\n        const authorityCacheKey = this.generateAuthorityKey(state);\r\n        this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\r\n\r\n        if (account) {\r\n            const ccsCredential: CcsCredential = {\r\n                credential: account.homeAccountId,\r\n                type: CcsCredentialType.HOME_ACCOUNT_ID,\r\n            };\r\n            this.setTemporaryCache(\r\n                TemporaryCacheKeys.CCS_CREDENTIAL,\r\n                JSON.stringify(ccsCredential),\r\n                true\r\n            );\r\n        } else if (loginHint) {\r\n            const ccsCredential: CcsCredential = {\r\n                credential: loginHint,\r\n                type: CcsCredentialType.UPN,\r\n            };\r\n            this.setTemporaryCache(\r\n                TemporaryCacheKeys.CCS_CREDENTIAL,\r\n                JSON.stringify(ccsCredential),\r\n                true\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset all temporary cache items\r\n     * @param state\r\n     */\r\n    resetRequestCache(state: string): void {\r\n        this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\r\n        // check state and remove associated cache items\r\n        if (state) {\r\n            this.temporaryCacheStorage.getKeys().forEach((key) => {\r\n                if (key.indexOf(state) !== -1) {\r\n                    this.removeTemporaryItem(key);\r\n                }\r\n            });\r\n\r\n            // delete generic interactive request parameters\r\n            this.removeTemporaryItem(this.generateStateKey(state));\r\n            this.removeTemporaryItem(this.generateNonceKey(state));\r\n            this.removeTemporaryItem(this.generateAuthorityKey(state));\r\n        }\r\n        this.removeTemporaryItem(\r\n            this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS)\r\n        );\r\n        this.removeTemporaryItem(\r\n            this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI)\r\n        );\r\n        this.removeTemporaryItem(\r\n            this.generateCacheKey(TemporaryCacheKeys.URL_HASH)\r\n        );\r\n        this.removeTemporaryItem(\r\n            this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID)\r\n        );\r\n        this.removeTemporaryItem(\r\n            this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL)\r\n        );\r\n        this.removeTemporaryItem(\r\n            this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST)\r\n        );\r\n        this.setInteractionInProgress(false);\r\n    }\r\n\r\n    /**\r\n     * Removes temporary cache for the provided state\r\n     * @param stateString\r\n     */\r\n    cleanRequestByState(stateString: string): void {\r\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\");\r\n        // Interaction is completed - remove interaction status.\r\n        if (stateString) {\r\n            const stateKey = this.generateStateKey(stateString);\r\n            const cachedState = this.temporaryCacheStorage.getItem(stateKey);\r\n            this.logger.infoPii(\r\n                `BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: ${cachedState}`\r\n            );\r\n            this.resetRequestCache(cachedState || Constants.EMPTY_STRING);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\r\n     * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\r\n     * @param interactionType\r\n     */\r\n    cleanRequestByInteractionType(interactionType: InteractionType): void {\r\n        this.logger.trace(\r\n            \"BrowserCacheManager.cleanRequestByInteractionType called\"\r\n        );\r\n        // Loop through all keys to find state key\r\n        this.temporaryCacheStorage.getKeys().forEach((key) => {\r\n            // If this key is not the state key, move on\r\n            if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\r\n                return;\r\n            }\r\n\r\n            // Retrieve state value, return if not a valid value\r\n            const stateValue = this.temporaryCacheStorage.getItem(key);\r\n            if (!stateValue) {\r\n                return;\r\n            }\r\n            // Extract state and ensure it matches given InteractionType, then clean request cache\r\n            const parsedState = extractBrowserRequestState(\r\n                this.cryptoImpl,\r\n                stateValue\r\n            );\r\n            if (\r\n                parsedState &&\r\n                parsedState.interactionType === interactionType\r\n            ) {\r\n                this.logger.infoPii(\r\n                    `BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: ${stateValue}`\r\n                );\r\n                this.resetRequestCache(stateValue);\r\n            }\r\n        });\r\n        this.setInteractionInProgress(false);\r\n    }\r\n\r\n    cacheCodeRequest(authCodeRequest: CommonAuthorizationCodeRequest): void {\r\n        this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\r\n\r\n        const encodedValue = base64Encode(JSON.stringify(authCodeRequest));\r\n        this.setTemporaryCache(\r\n            TemporaryCacheKeys.REQUEST_PARAMS,\r\n            encodedValue,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n     */\r\n    getCachedRequest(state: string): CommonAuthorizationCodeRequest {\r\n        this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\r\n        // Get token request from cache and parse as TokenExchangeParameters.\r\n        const encodedTokenRequest = this.getTemporaryCache(\r\n            TemporaryCacheKeys.REQUEST_PARAMS,\r\n            true\r\n        );\r\n        if (!encodedTokenRequest) {\r\n            throw createBrowserAuthError(\r\n                BrowserAuthErrorCodes.noTokenRequestCacheError\r\n            );\r\n        }\r\n\r\n        let parsedRequest: CommonAuthorizationCodeRequest;\r\n        try {\r\n            parsedRequest = JSON.parse(base64Decode(encodedTokenRequest));\r\n        } catch (e) {\r\n            this.logger.errorPii(`Attempted to parse: ${encodedTokenRequest}`);\r\n            this.logger.error(\r\n                `Parsing cached token request threw with error: ${e}`\r\n            );\r\n            throw createBrowserAuthError(\r\n                BrowserAuthErrorCodes.unableToParseTokenRequestCacheError\r\n            );\r\n        }\r\n        this.removeTemporaryItem(\r\n            this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS)\r\n        );\r\n\r\n        // Get cached authority and use if no authority is cached with request.\r\n        if (!parsedRequest.authority) {\r\n            const authorityCacheKey: string = this.generateAuthorityKey(state);\r\n            const cachedAuthority = this.getTemporaryCache(authorityCacheKey);\r\n            if (!cachedAuthority) {\r\n                throw createBrowserAuthError(\r\n                    BrowserAuthErrorCodes.noCachedAuthorityError\r\n                );\r\n            }\r\n            parsedRequest.authority = cachedAuthority;\r\n        }\r\n\r\n        return parsedRequest;\r\n    }\r\n\r\n    /**\r\n     * Gets cached native request for redirect flows\r\n     */\r\n    getCachedNativeRequest(): NativeTokenRequest | null {\r\n        this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\r\n        const cachedRequest = this.getTemporaryCache(\r\n            TemporaryCacheKeys.NATIVE_REQUEST,\r\n            true\r\n        );\r\n        if (!cachedRequest) {\r\n            this.logger.trace(\r\n                \"BrowserCacheManager.getCachedNativeRequest: No cached native request found\"\r\n            );\r\n            return null;\r\n        }\r\n\r\n        const parsedRequest = this.validateAndParseJson(\r\n            cachedRequest\r\n        ) as NativeTokenRequest;\r\n        if (!parsedRequest) {\r\n            this.logger.error(\r\n                \"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\"\r\n            );\r\n            return null;\r\n        }\r\n\r\n        return parsedRequest;\r\n    }\r\n\r\n    isInteractionInProgress(matchClientId?: boolean): boolean {\r\n        const clientId = this.getInteractionInProgress();\r\n\r\n        if (matchClientId) {\r\n            return clientId === this.clientId;\r\n        } else {\r\n            return !!clientId;\r\n        }\r\n    }\r\n\r\n    getInteractionInProgress(): string | null {\r\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\r\n        return this.getTemporaryCache(key, false);\r\n    }\r\n\r\n    setInteractionInProgress(inProgress: boolean): void {\r\n        // Ensure we don't overwrite interaction in progress for a different clientId\r\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\r\n        if (inProgress) {\r\n            if (this.getInteractionInProgress()) {\r\n                throw createBrowserAuthError(\r\n                    BrowserAuthErrorCodes.interactionInProgress\r\n                );\r\n            } else {\r\n                // No interaction is in progress\r\n                this.setTemporaryCache(key, this.clientId, false);\r\n            }\r\n        } else if (\r\n            !inProgress &&\r\n            this.getInteractionInProgress() === this.clientId\r\n        ) {\r\n            this.removeTemporaryItem(key);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache\r\n     * @param result\r\n     * @param request\r\n     */\r\n    async hydrateCache(\r\n        result: AuthenticationResult,\r\n        request:\r\n            | SilentRequest\r\n            | SsoSilentRequest\r\n            | RedirectRequest\r\n            | PopupRequest\r\n    ): Promise<void> {\r\n        const idTokenEntity = CacheHelpers.createIdTokenEntity(\r\n            result.account?.homeAccountId,\r\n            result.account?.environment,\r\n            result.idToken,\r\n            this.clientId,\r\n            result.tenantId\r\n        );\r\n\r\n        let claimsHash;\r\n        if (request.claims) {\r\n            claimsHash = await this.cryptoImpl.hashString(request.claims);\r\n        }\r\n\r\n        /**\r\n         * meta data for cache stores time in seconds from epoch\r\n         * AuthenticationResult returns expiresOn and extExpiresOn in milliseconds (as a Date object which is in ms)\r\n         * We need to map these for the cache when building tokens from AuthenticationResult\r\n         *\r\n         * The next MSAL VFuture should map these both to same value if possible\r\n         */\r\n\r\n        const accessTokenEntity = CacheHelpers.createAccessTokenEntity(\r\n            result.account?.homeAccountId,\r\n            result.account.environment,\r\n            result.accessToken,\r\n            this.clientId,\r\n            result.tenantId,\r\n            result.scopes.join(\" \"),\r\n            result.expiresOn ? result.expiresOn.getTime() / 1000 : 0,\r\n            result.extExpiresOn ? result.extExpiresOn.getTime() / 1000 : 0,\r\n            base64Decode,\r\n            undefined, // refreshOn\r\n            result.tokenType as AuthenticationScheme,\r\n            undefined, // userAssertionHash\r\n            request.sshKid,\r\n            request.claims,\r\n            claimsHash\r\n        );\r\n\r\n        const cacheRecord = {\r\n            idToken: idTokenEntity,\r\n            accessToken: accessTokenEntity,\r\n        };\r\n        return this.saveCacheRecord(cacheRecord, result.correlationId);\r\n    }\r\n\r\n    /**\r\n     * saves a cache record\r\n     * @param cacheRecord {CacheRecord}\r\n     * @param storeInCache {?StoreInCache}\r\n     * @param correlationId {?string} correlation id\r\n     */\r\n    async saveCacheRecord(\r\n        cacheRecord: CacheRecord,\r\n        correlationId: string,\r\n        storeInCache?: StoreInCache\r\n    ): Promise<void> {\r\n        try {\r\n            await super.saveCacheRecord(\r\n                cacheRecord,\r\n                correlationId,\r\n                storeInCache\r\n            );\r\n        } catch (e) {\r\n            if (\r\n                e instanceof CacheError &&\r\n                this.performanceClient &&\r\n                correlationId\r\n            ) {\r\n                try {\r\n                    const tokenKeys = this.getTokenKeys();\r\n\r\n                    this.performanceClient.addFields(\r\n                        {\r\n                            cacheRtCount: tokenKeys.refreshToken.length,\r\n                            cacheIdCount: tokenKeys.idToken.length,\r\n                            cacheAtCount: tokenKeys.accessToken.length,\r\n                        },\r\n                        correlationId\r\n                    );\r\n                } catch (e) {}\r\n            }\r\n\r\n            throw e;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n * @param cacheLocation\r\n */\r\nfunction getStorageImplementation(\r\n    clientId: string,\r\n    cacheLocation: BrowserCacheLocation | string,\r\n    logger: Logger,\r\n    performanceClient: IPerformanceClient\r\n): IWindowStorage<string> {\r\n    try {\r\n        switch (cacheLocation) {\r\n            case BrowserCacheLocation.LocalStorage:\r\n                return new LocalStorage(clientId, logger, performanceClient);\r\n            case BrowserCacheLocation.SessionStorage:\r\n                return new SessionStorage();\r\n            case BrowserCacheLocation.MemoryStorage:\r\n            default:\r\n                break;\r\n        }\r\n    } catch (e) {\r\n        logger.error(e as string);\r\n    }\r\n\r\n    return new MemoryStorage();\r\n}\r\n\r\nexport const DEFAULT_BROWSER_CACHE_MANAGER = (\r\n    clientId: string,\r\n    logger: Logger,\r\n    performanceClient: IPerformanceClient,\r\n    eventHandler: EventHandler\r\n): BrowserCacheManager => {\r\n    const cacheOptions: Required<CacheOptions> = {\r\n        cacheLocation: BrowserCacheLocation.MemoryStorage,\r\n        temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\r\n        storeAuthStateInCookie: false,\r\n        secureCookies: false,\r\n        cacheMigrationEnabled: false,\r\n        claimsBasedCachingEnabled: false,\r\n    };\r\n    return new BrowserCacheManager(\r\n        clientId,\r\n        cacheOptions,\r\n        DEFAULT_CRYPTO_IMPLEMENTATION,\r\n        logger,\r\n        performanceClient,\r\n        eventHandler\r\n    );\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}