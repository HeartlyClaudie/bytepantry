{"ast":null,"code":"/*! @azure/msal-browser v4.5.0 2025-02-26 */\n'use strict';\n\nimport { DEFAULT_CRYPTO_IMPLEMENTATION, buildStaticAuthorityOptions, PerformanceEvents, TimeUtils, AuthError, OIDC_DEFAULT_SCOPES, AccountEntity } from '@azure/msal-common/browser';\nimport { InteractionType, CacheLookupPolicy, DEFAULT_REQUEST } from '../utils/BrowserConstants.mjs';\nimport { CryptoOps } from '../crypto/CryptoOps.mjs';\nimport { NestedAppAuthAdapter } from '../naa/mapping/NestedAppAuthAdapter.mjs';\nimport { NestedAppAuthError } from '../error/NestedAppAuthError.mjs';\nimport { EventHandler } from '../event/EventHandler.mjs';\nimport { EventType } from '../event/EventType.mjs';\nimport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER } from '../cache/BrowserCacheManager.mjs';\nimport { getAccount, getAllAccounts, getAccountByUsername, getAccountByHomeId, getAccountByLocalId, setActiveAccount, getActiveAccount } from '../cache/AccountManager.mjs';\nimport { createNewGuid } from '../crypto/BrowserCrypto.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass NestedAppAuthController {\n  constructor(operatingContext) {\n    this.operatingContext = operatingContext;\n    const proxy = this.operatingContext.getBridgeProxy();\n    if (proxy !== undefined) {\n      this.bridgeProxy = proxy;\n    } else {\n      throw new Error(\"unexpected: bridgeProxy is undefined\");\n    }\n    // Set the configuration.\n    this.config = operatingContext.getConfig();\n    // Initialize logger\n    this.logger = this.operatingContext.getLogger();\n    // Initialize performance client\n    this.performanceClient = this.config.telemetry.client;\n    // Initialize the crypto class.\n    this.browserCrypto = operatingContext.isBrowserEnvironment() ? new CryptoOps(this.logger, this.performanceClient, true) : DEFAULT_CRYPTO_IMPLEMENTATION;\n    this.eventHandler = new EventHandler(this.logger);\n    // Initialize the browser storage class.\n    this.browserStorage = this.operatingContext.isBrowserEnvironment() ? new BrowserCacheManager(this.config.auth.clientId, this.config.cache, this.browserCrypto, this.logger, this.performanceClient, this.eventHandler, buildStaticAuthorityOptions(this.config.auth)) : DEFAULT_BROWSER_CACHE_MANAGER(this.config.auth.clientId, this.logger, this.performanceClient, this.eventHandler);\n    this.nestedAppAuthAdapter = new NestedAppAuthAdapter(this.config.auth.clientId, this.config.auth.clientCapabilities, this.browserCrypto, this.logger);\n    // Set the active account if available\n    const accountContext = this.bridgeProxy.getAccountContext();\n    this.currentAccountContext = accountContext ? accountContext : null;\n  }\n  /**\r\n   * Factory function to create a new instance of NestedAppAuthController\r\n   * @param operatingContext\r\n   * @returns Promise<IController>\r\n   */\n  static async createController(operatingContext) {\n    const controller = new NestedAppAuthController(operatingContext);\n    return Promise.resolve(controller);\n  }\n  /**\r\n   * Specific implementation of initialize function for NestedAppAuthController\r\n   * @returns\r\n   */\n  async initialize(request) {\n    const initCorrelationId = request?.correlationId || createNewGuid();\n    await this.browserStorage.initialize(initCorrelationId);\n    return Promise.resolve();\n  }\n  /**\r\n   * Validate the incoming request and add correlationId if not present\r\n   * @param request\r\n   * @returns\r\n   */\n  ensureValidRequest(request) {\n    if (request?.correlationId) {\n      return request;\n    }\n    return {\n      ...request,\n      correlationId: this.browserCrypto.createNewGuid()\n    };\n  }\n  /**\r\n   * Internal implementation of acquireTokenInteractive flow\r\n   * @param request\r\n   * @returns\r\n   */\n  async acquireTokenInteractive(request) {\n    const validRequest = this.ensureValidRequest(request);\n    this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Popup, validRequest);\n    const atPopupMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenPopup, validRequest.correlationId);\n    atPopupMeasurement?.add({\n      nestedAppAuthRequest: true\n    });\n    try {\n      const naaRequest = this.nestedAppAuthAdapter.toNaaTokenRequest(validRequest);\n      const reqTimestamp = TimeUtils.nowSeconds();\n      const response = await this.bridgeProxy.getTokenInteractive(naaRequest);\n      const result = {\n        ...this.nestedAppAuthAdapter.fromNaaTokenResponse(naaRequest, response, reqTimestamp)\n      };\n      // cache the tokens in the response\n      await this.hydrateCache(result, request);\n      // cache the account context in memory after successful token fetch\n      this.currentAccountContext = {\n        homeAccountId: result.account.homeAccountId,\n        environment: result.account.environment,\n        tenantId: result.account.tenantId\n      };\n      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Popup, result);\n      atPopupMeasurement.add({\n        accessTokenSize: result.accessToken.length,\n        idTokenSize: result.idToken.length\n      });\n      atPopupMeasurement.end({\n        success: true,\n        requestId: result.requestId\n      });\n      return result;\n    } catch (e) {\n      const error = e instanceof AuthError ? e : this.nestedAppAuthAdapter.fromBridgeError(e);\n      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Popup, null, e);\n      atPopupMeasurement.end({\n        success: false\n      }, e);\n      throw error;\n    }\n  }\n  /**\r\n   * Internal implementation of acquireTokenSilent flow\r\n   * @param request\r\n   * @returns\r\n   */\n  async acquireTokenSilentInternal(request) {\n    const validRequest = this.ensureValidRequest(request);\n    this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Silent, validRequest);\n    // Look for tokens in the cache first\n    const result = await this.acquireTokenFromCache(validRequest);\n    if (result) {\n      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Silent, result);\n      return result;\n    }\n    // proceed with acquiring tokens via the host\n    const ssoSilentMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.SsoSilent, validRequest.correlationId);\n    ssoSilentMeasurement?.increment({\n      visibilityChangeCount: 0\n    });\n    ssoSilentMeasurement?.add({\n      nestedAppAuthRequest: true\n    });\n    try {\n      const naaRequest = this.nestedAppAuthAdapter.toNaaTokenRequest(validRequest);\n      const reqTimestamp = TimeUtils.nowSeconds();\n      const response = await this.bridgeProxy.getTokenSilent(naaRequest);\n      const result = this.nestedAppAuthAdapter.fromNaaTokenResponse(naaRequest, response, reqTimestamp);\n      // cache the tokens in the response\n      await this.hydrateCache(result, request);\n      // cache the account context in memory after successful token fetch\n      this.currentAccountContext = {\n        homeAccountId: result.account.homeAccountId,\n        environment: result.account.environment,\n        tenantId: result.account.tenantId\n      };\n      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Silent, result);\n      ssoSilentMeasurement?.add({\n        accessTokenSize: result.accessToken.length,\n        idTokenSize: result.idToken.length\n      });\n      ssoSilentMeasurement?.end({\n        success: true,\n        requestId: result.requestId\n      });\n      return result;\n    } catch (e) {\n      const error = e instanceof AuthError ? e : this.nestedAppAuthAdapter.fromBridgeError(e);\n      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Silent, null, e);\n      ssoSilentMeasurement?.end({\n        success: false\n      }, e);\n      throw error;\n    }\n  }\n  /**\r\n   * acquires tokens from cache\r\n   * @param request\r\n   * @returns\r\n   */\n  async acquireTokenFromCache(request) {\n    const atsMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenSilent, request.correlationId);\n    atsMeasurement?.add({\n      nestedAppAuthRequest: true\n    });\n    // if the request has claims, we cannot look up in the cache\n    if (request.claims) {\n      this.logger.verbose(\"Claims are present in the request, skipping cache lookup\");\n      return null;\n    }\n    // if the request has forceRefresh, we cannot look up in the cache\n    if (request.forceRefresh) {\n      this.logger.verbose(\"forceRefresh is set to true, skipping cache lookup\");\n      return null;\n    }\n    // respect cache lookup policy\n    let result = null;\n    if (!request.cacheLookupPolicy) {\n      request.cacheLookupPolicy = CacheLookupPolicy.Default;\n    }\n    switch (request.cacheLookupPolicy) {\n      case CacheLookupPolicy.Default:\n      case CacheLookupPolicy.AccessToken:\n      case CacheLookupPolicy.AccessTokenAndRefreshToken:\n        result = await this.acquireTokenFromCacheInternal(request);\n        break;\n      default:\n        return null;\n    }\n    if (result) {\n      this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Silent, result);\n      atsMeasurement?.add({\n        accessTokenSize: result?.accessToken.length,\n        idTokenSize: result?.idToken.length\n      });\n      atsMeasurement?.end({\n        success: true\n      });\n      return result;\n    }\n    this.logger.error(\"Cached tokens are not found for the account, proceeding with silent token request.\");\n    this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Silent, null);\n    atsMeasurement?.end({\n      success: false\n    });\n    return null;\n  }\n  /**\r\n   *\r\n   * @param request\r\n   * @returns\r\n   */\n  async acquireTokenFromCacheInternal(request) {\n    // always prioritize the account context from the bridge\n    const accountContext = this.bridgeProxy.getAccountContext() || this.currentAccountContext;\n    let currentAccount = null;\n    if (accountContext) {\n      currentAccount = getAccount(accountContext, this.logger, this.browserStorage);\n    }\n    // fall back to brokering if no cached account is found\n    if (!currentAccount) {\n      this.logger.verbose(\"No active account found, falling back to the host\");\n      return Promise.resolve(null);\n    }\n    this.logger.verbose(\"active account found, attempting to acquire token silently\");\n    const authRequest = {\n      ...request,\n      correlationId: request.correlationId || this.browserCrypto.createNewGuid(),\n      authority: request.authority || currentAccount.environment,\n      scopes: request.scopes?.length ? request.scopes : [...OIDC_DEFAULT_SCOPES]\n    };\n    // fetch access token and check for expiry\n    const tokenKeys = this.browserStorage.getTokenKeys();\n    const cachedAccessToken = this.browserStorage.getAccessToken(currentAccount, authRequest, tokenKeys, currentAccount.tenantId, this.performanceClient, authRequest.correlationId);\n    // If there is no access token, log it and return null\n    if (!cachedAccessToken) {\n      this.logger.verbose(\"No cached access token found\");\n      return Promise.resolve(null);\n    } else if (TimeUtils.wasClockTurnedBack(cachedAccessToken.cachedAt) || TimeUtils.isTokenExpired(cachedAccessToken.expiresOn, this.config.system.tokenRenewalOffsetSeconds)) {\n      this.logger.verbose(\"Cached access token has expired\");\n      return Promise.resolve(null);\n    }\n    const cachedIdToken = this.browserStorage.getIdToken(currentAccount, tokenKeys, currentAccount.tenantId, this.performanceClient, authRequest.correlationId);\n    if (!cachedIdToken) {\n      this.logger.verbose(\"No cached id token found\");\n      return Promise.resolve(null);\n    }\n    return this.nestedAppAuthAdapter.toAuthenticationResultFromCache(currentAccount, cachedIdToken, cachedAccessToken, authRequest, authRequest.correlationId);\n  }\n  /**\r\n   * acquireTokenPopup flow implementation\r\n   * @param request\r\n   * @returns\r\n   */\n  async acquireTokenPopup(request) {\n    return this.acquireTokenInteractive(request);\n  }\n  /**\r\n   * acquireTokenRedirect flow is not supported in nested app auth\r\n   * @param request\r\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  acquireTokenRedirect(request) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  /**\r\n   * acquireTokenSilent flow implementation\r\n   * @param silentRequest\r\n   * @returns\r\n   */\n  async acquireTokenSilent(silentRequest) {\n    return this.acquireTokenSilentInternal(silentRequest);\n  }\n  /**\r\n   * Hybrid flow is not currently supported in nested app auth\r\n   * @param request\r\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  acquireTokenByCode(request // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  /**\r\n   * acquireTokenNative flow is not currently supported in nested app auth\r\n   * @param request\r\n   * @param apiId\r\n   * @param accountId\r\n   */\n  acquireTokenNative(request, apiId,\n  // eslint-disable-line @typescript-eslint/no-unused-vars\n  accountId // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  /**\r\n   * acquireTokenByRefreshToken flow is not currently supported in nested app auth\r\n   * @param commonRequest\r\n   * @param silentRequest\r\n   */\n  acquireTokenByRefreshToken(commonRequest,\n  // eslint-disable-line @typescript-eslint/no-unused-vars\n  silentRequest // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  /**\r\n   * Adds event callbacks to array\r\n   * @param callback\r\n   * @param eventTypes\r\n   */\n  addEventCallback(callback, eventTypes) {\n    return this.eventHandler.addEventCallback(callback, eventTypes);\n  }\n  /**\r\n   * Removes callback with provided id from callback array\r\n   * @param callbackId\r\n   */\n  removeEventCallback(callbackId) {\n    this.eventHandler.removeEventCallback(callbackId);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  addPerformanceCallback(callback) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  removePerformanceCallback(callbackId) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  enableAccountStorageEvents() {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  disableAccountStorageEvents() {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  // #region Account APIs\n  /**\r\n   * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.\r\n   * @param accountFilter - (Optional) filter to narrow down the accounts returned\r\n   * @returns Array of AccountInfo objects in cache\r\n   */\n  getAllAccounts(accountFilter) {\n    return getAllAccounts(this.logger, this.browserStorage, this.isBrowserEnv(), accountFilter);\n  }\n  /**\r\n   * Returns the first account found in the cache that matches the account filter passed in.\r\n   * @param accountFilter\r\n   * @returns The first account found in the cache matching the provided filter or null if no account could be found.\r\n   */\n  getAccount(accountFilter) {\n    return getAccount(accountFilter, this.logger, this.browserStorage);\n  }\n  /**\r\n   * Returns the signed in account matching username.\r\n   * (the account object is created at the time of successful login)\r\n   * or null when no matching account is found.\r\n   * This API is provided for convenience but getAccountById should be used for best reliability\r\n   * @param username\r\n   * @returns The account object stored in MSAL\r\n   */\n  getAccountByUsername(username) {\n    return getAccountByUsername(username, this.logger, this.browserStorage);\n  }\n  /**\r\n   * Returns the signed in account matching homeAccountId.\r\n   * (the account object is created at the time of successful login)\r\n   * or null when no matching account is found\r\n   * @param homeAccountId\r\n   * @returns The account object stored in MSAL\r\n   */\n  getAccountByHomeId(homeAccountId) {\n    return getAccountByHomeId(homeAccountId, this.logger, this.browserStorage);\n  }\n  /**\r\n   * Returns the signed in account matching localAccountId.\r\n   * (the account object is created at the time of successful login)\r\n   * or null when no matching account is found\r\n   * @param localAccountId\r\n   * @returns The account object stored in MSAL\r\n   */\n  getAccountByLocalId(localAccountId) {\n    return getAccountByLocalId(localAccountId, this.logger, this.browserStorage);\n  }\n  /**\r\n   * Sets the account to use as the active account. If no account is passed to the acquireToken APIs, then MSAL will use this active account.\r\n   * @param account\r\n   */\n  setActiveAccount(account) {\n    /*\r\n     * StandardController uses this to allow the developer to set the active account\r\n     * in the nested app auth scenario the active account is controlled by the app hosting the nested app\r\n     */\n    return setActiveAccount(account, this.browserStorage);\n  }\n  /**\r\n   * Gets the currently active account\r\n   */\n  getActiveAccount() {\n    return getActiveAccount(this.browserStorage);\n  }\n  // #endregion\n  handleRedirectPromise(hash // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    return Promise.resolve(null);\n  }\n  loginPopup(request // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    return this.acquireTokenInteractive(request || DEFAULT_REQUEST);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  loginRedirect(request) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  logout(logoutRequest) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  logoutRedirect(logoutRequest // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  logoutPopup(logoutRequest // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  ssoSilent(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  request) {\n    return this.acquireTokenSilentInternal(request);\n  }\n  getTokenCache() {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  /**\r\n   * Returns the logger instance\r\n   */\n  getLogger() {\n    return this.logger;\n  }\n  /**\r\n   * Replaces the default logger set in configurations with new Logger with new configurations\r\n   * @param logger Logger instance\r\n   */\n  setLogger(logger) {\n    this.logger = logger;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  initializeWrapperLibrary(sku, version) {\n    /*\r\n     * Standard controller uses this to set the sku and version of the wrapper library in the storage\r\n     * we do nothing here\r\n     */\n    return;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  setNavigationClient(navigationClient) {\n    this.logger.warning(\"setNavigationClient is not supported in nested app auth\");\n  }\n  getConfiguration() {\n    return this.config;\n  }\n  isBrowserEnv() {\n    return this.operatingContext.isBrowserEnvironment();\n  }\n  getBrowserCrypto() {\n    return this.browserCrypto;\n  }\n  getPerformanceClient() {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  getRedirectResponse() {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async clearCache(logoutRequest) {\n    throw NestedAppAuthError.createUnsupportedError();\n  }\n  async hydrateCache(result, request) {\n    this.logger.verbose(\"hydrateCache called\");\n    const accountEntity = AccountEntity.createFromAccountInfo(result.account, result.cloudGraphHostName, result.msGraphHost);\n    await this.browserStorage.setAccount(accountEntity, result.correlationId);\n    return this.browserStorage.hydrateCache(result, request);\n  }\n}\nexport { NestedAppAuthController };","map":{"version":3,"names":["NestedAppAuthController","constructor","operatingContext","proxy","getBridgeProxy","undefined","bridgeProxy","Error","config","getConfig","logger","getLogger","performanceClient","telemetry","client","browserCrypto","isBrowserEnvironment","CryptoOps","DEFAULT_CRYPTO_IMPLEMENTATION","eventHandler","EventHandler","browserStorage","BrowserCacheManager","auth","clientId","cache","buildStaticAuthorityOptions","DEFAULT_BROWSER_CACHE_MANAGER","nestedAppAuthAdapter","NestedAppAuthAdapter","clientCapabilities","accountContext","getAccountContext","currentAccountContext","createController","controller","Promise","resolve","initialize","request","initCorrelationId","correlationId","createNewGuid","ensureValidRequest","acquireTokenInteractive","validRequest","emitEvent","EventType","ACQUIRE_TOKEN_START","InteractionType","Popup","atPopupMeasurement","startMeasurement","PerformanceEvents","AcquireTokenPopup","add","nestedAppAuthRequest","naaRequest","toNaaTokenRequest","reqTimestamp","TimeUtils","nowSeconds","response","getTokenInteractive","result","fromNaaTokenResponse","hydrateCache","homeAccountId","account","environment","tenantId","ACQUIRE_TOKEN_SUCCESS","accessTokenSize","accessToken","length","idTokenSize","idToken","end","success","requestId","e","error","AuthError","fromBridgeError","ACQUIRE_TOKEN_FAILURE","acquireTokenSilentInternal","Silent","acquireTokenFromCache","ssoSilentMeasurement","SsoSilent","increment","visibilityChangeCount","getTokenSilent","atsMeasurement","AcquireTokenSilent","claims","verbose","forceRefresh","cacheLookupPolicy","CacheLookupPolicy","Default","AccessToken","AccessTokenAndRefreshToken","acquireTokenFromCacheInternal","currentAccount","getAccount","authRequest","authority","scopes","OIDC_DEFAULT_SCOPES","tokenKeys","getTokenKeys","cachedAccessToken","getAccessToken","wasClockTurnedBack","cachedAt","isTokenExpired","expiresOn","system","tokenRenewalOffsetSeconds","cachedIdToken","getIdToken","toAuthenticationResultFromCache","acquireTokenPopup","acquireTokenRedirect","NestedAppAuthError","createUnsupportedError","acquireTokenSilent","silentRequest","acquireTokenByCode","acquireTokenNative","apiId","accountId","acquireTokenByRefreshToken","commonRequest","addEventCallback","callback","eventTypes","removeEventCallback","callbackId","addPerformanceCallback","removePerformanceCallback","enableAccountStorageEvents","disableAccountStorageEvents","getAllAccounts","accountFilter","isBrowserEnv","getAccountByUsername","username","getAccountByHomeId","getAccountByLocalId","localAccountId","setActiveAccount","getActiveAccount","handleRedirectPromise","hash","loginPopup","DEFAULT_REQUEST","loginRedirect","logout","logoutRequest","logoutRedirect","logoutPopup","ssoSilent","getTokenCache","setLogger","initializeWrapperLibrary","sku","version","setNavigationClient","navigationClient","warning","getConfiguration","getBrowserCrypto","getPerformanceClient","getRedirectResponse","clearCache","accountEntity","AccountEntity","createFromAccountInfo","cloudGraphHostName","msGraphHost","setAccount"],"sources":["C:\\bytepantry\\frontend\\node_modules\\@azure\\msal-browser\\src\\controllers\\NestedAppAuthController.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    CommonAuthorizationUrlRequest,\r\n    CommonSilentFlowRequest,\r\n    PerformanceCallbackFunction,\r\n    AccountInfo,\r\n    Logger,\r\n    ICrypto,\r\n    IPerformanceClient,\r\n    DEFAULT_CRYPTO_IMPLEMENTATION,\r\n    PerformanceEvents,\r\n    TimeUtils,\r\n    buildStaticAuthorityOptions,\r\n    AccountEntity,\r\n    OIDC_DEFAULT_SCOPES,\r\n    BaseAuthRequest,\r\n    AccountFilter,\r\n    AuthError,\r\n} from \"@azure/msal-common/browser\";\r\nimport { ITokenCache } from \"../cache/ITokenCache.js\";\r\nimport { BrowserConfiguration } from \"../config/Configuration.js\";\r\nimport { INavigationClient } from \"../navigation/INavigationClient.js\";\r\nimport { AuthorizationCodeRequest } from \"../request/AuthorizationCodeRequest.js\";\r\nimport { EndSessionPopupRequest } from \"../request/EndSessionPopupRequest.js\";\r\nimport { EndSessionRequest } from \"../request/EndSessionRequest.js\";\r\nimport { PopupRequest } from \"../request/PopupRequest.js\";\r\nimport { RedirectRequest } from \"../request/RedirectRequest.js\";\r\nimport { SilentRequest } from \"../request/SilentRequest.js\";\r\nimport { SsoSilentRequest } from \"../request/SsoSilentRequest.js\";\r\nimport {\r\n    ApiId,\r\n    WrapperSKU,\r\n    InteractionType,\r\n    DEFAULT_REQUEST,\r\n    CacheLookupPolicy,\r\n} from \"../utils/BrowserConstants.js\";\r\nimport { IController } from \"./IController.js\";\r\nimport { NestedAppOperatingContext } from \"../operatingcontext/NestedAppOperatingContext.js\";\r\nimport { IBridgeProxy } from \"../naa/IBridgeProxy.js\";\r\nimport { CryptoOps } from \"../crypto/CryptoOps.js\";\r\nimport { NestedAppAuthAdapter } from \"../naa/mapping/NestedAppAuthAdapter.js\";\r\nimport { NestedAppAuthError } from \"../error/NestedAppAuthError.js\";\r\nimport { EventHandler } from \"../event/EventHandler.js\";\r\nimport { EventType } from \"../event/EventType.js\";\r\nimport { EventCallbackFunction, EventError } from \"../event/EventMessage.js\";\r\nimport { AuthenticationResult } from \"../response/AuthenticationResult.js\";\r\nimport {\r\n    BrowserCacheManager,\r\n    DEFAULT_BROWSER_CACHE_MANAGER,\r\n} from \"../cache/BrowserCacheManager.js\";\r\nimport { ClearCacheRequest } from \"../request/ClearCacheRequest.js\";\r\nimport * as AccountManager from \"../cache/AccountManager.js\";\r\nimport { AccountContext } from \"../naa/BridgeAccountContext.js\";\r\nimport { InitializeApplicationRequest } from \"../request/InitializeApplicationRequest.js\";\r\nimport { createNewGuid } from \"../crypto/BrowserCrypto.js\";\r\n\r\nexport class NestedAppAuthController implements IController {\r\n    // OperatingContext\r\n    protected readonly operatingContext: NestedAppOperatingContext;\r\n\r\n    // BridgeProxy\r\n    protected readonly bridgeProxy: IBridgeProxy;\r\n\r\n    // Crypto interface implementation\r\n    protected readonly browserCrypto: ICrypto;\r\n\r\n    // Input configuration by developer/user\r\n    protected readonly config: BrowserConfiguration;\r\n\r\n    // Storage interface implementation\r\n    protected readonly browserStorage!: BrowserCacheManager;\r\n\r\n    // Logger\r\n    protected logger: Logger;\r\n\r\n    // Performance telemetry client\r\n    protected readonly performanceClient: IPerformanceClient;\r\n\r\n    // EventHandler\r\n    protected readonly eventHandler: EventHandler;\r\n\r\n    // NestedAppAuthAdapter\r\n    protected readonly nestedAppAuthAdapter: NestedAppAuthAdapter;\r\n\r\n    // currentAccount for NAA apps\r\n    protected currentAccountContext: AccountContext | null;\r\n\r\n    constructor(operatingContext: NestedAppOperatingContext) {\r\n        this.operatingContext = operatingContext;\r\n        const proxy = this.operatingContext.getBridgeProxy();\r\n        if (proxy !== undefined) {\r\n            this.bridgeProxy = proxy;\r\n        } else {\r\n            throw new Error(\"unexpected: bridgeProxy is undefined\");\r\n        }\r\n\r\n        // Set the configuration.\r\n        this.config = operatingContext.getConfig();\r\n\r\n        // Initialize logger\r\n        this.logger = this.operatingContext.getLogger();\r\n\r\n        // Initialize performance client\r\n        this.performanceClient = this.config.telemetry.client;\r\n\r\n        // Initialize the crypto class.\r\n        this.browserCrypto = operatingContext.isBrowserEnvironment()\r\n            ? new CryptoOps(this.logger, this.performanceClient, true)\r\n            : DEFAULT_CRYPTO_IMPLEMENTATION;\r\n\r\n        this.eventHandler = new EventHandler(this.logger);\r\n        // Initialize the browser storage class.\r\n        this.browserStorage = this.operatingContext.isBrowserEnvironment()\r\n            ? new BrowserCacheManager(\r\n                  this.config.auth.clientId,\r\n                  this.config.cache,\r\n                  this.browserCrypto,\r\n                  this.logger,\r\n                  this.performanceClient,\r\n                  this.eventHandler,\r\n                  buildStaticAuthorityOptions(this.config.auth)\r\n              )\r\n            : DEFAULT_BROWSER_CACHE_MANAGER(\r\n                  this.config.auth.clientId,\r\n                  this.logger,\r\n                  this.performanceClient,\r\n                  this.eventHandler\r\n              );\r\n\r\n        this.nestedAppAuthAdapter = new NestedAppAuthAdapter(\r\n            this.config.auth.clientId,\r\n            this.config.auth.clientCapabilities,\r\n            this.browserCrypto,\r\n            this.logger\r\n        );\r\n\r\n        // Set the active account if available\r\n        const accountContext = this.bridgeProxy.getAccountContext();\r\n        this.currentAccountContext = accountContext ? accountContext : null;\r\n    }\r\n\r\n    /**\r\n     * Factory function to create a new instance of NestedAppAuthController\r\n     * @param operatingContext\r\n     * @returns Promise<IController>\r\n     */\r\n    static async createController(\r\n        operatingContext: NestedAppOperatingContext\r\n    ): Promise<IController> {\r\n        const controller = new NestedAppAuthController(operatingContext);\r\n        return Promise.resolve(controller);\r\n    }\r\n\r\n    /**\r\n     * Specific implementation of initialize function for NestedAppAuthController\r\n     * @returns\r\n     */\r\n    async initialize(request?: InitializeApplicationRequest): Promise<void> {\r\n        const initCorrelationId = request?.correlationId || createNewGuid();\r\n        await this.browserStorage.initialize(initCorrelationId);\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Validate the incoming request and add correlationId if not present\r\n     * @param request\r\n     * @returns\r\n     */\r\n    private ensureValidRequest<\r\n        T extends\r\n            | SsoSilentRequest\r\n            | SilentRequest\r\n            | PopupRequest\r\n            | RedirectRequest\r\n    >(request: T): T {\r\n        if (request?.correlationId) {\r\n            return request;\r\n        }\r\n        return {\r\n            ...request,\r\n            correlationId: this.browserCrypto.createNewGuid(),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Internal implementation of acquireTokenInteractive flow\r\n     * @param request\r\n     * @returns\r\n     */\r\n    private async acquireTokenInteractive(\r\n        request: PopupRequest | RedirectRequest\r\n    ): Promise<AuthenticationResult> {\r\n        const validRequest = this.ensureValidRequest(request);\r\n\r\n        this.eventHandler.emitEvent(\r\n            EventType.ACQUIRE_TOKEN_START,\r\n            InteractionType.Popup,\r\n            validRequest\r\n        );\r\n\r\n        const atPopupMeasurement = this.performanceClient.startMeasurement(\r\n            PerformanceEvents.AcquireTokenPopup,\r\n            validRequest.correlationId\r\n        );\r\n\r\n        atPopupMeasurement?.add({ nestedAppAuthRequest: true });\r\n\r\n        try {\r\n            const naaRequest =\r\n                this.nestedAppAuthAdapter.toNaaTokenRequest(validRequest);\r\n            const reqTimestamp = TimeUtils.nowSeconds();\r\n            const response = await this.bridgeProxy.getTokenInteractive(\r\n                naaRequest\r\n            );\r\n            const result: AuthenticationResult = {\r\n                ...this.nestedAppAuthAdapter.fromNaaTokenResponse(\r\n                    naaRequest,\r\n                    response,\r\n                    reqTimestamp\r\n                ),\r\n            };\r\n\r\n            // cache the tokens in the response\r\n            await this.hydrateCache(result, request);\r\n\r\n            // cache the account context in memory after successful token fetch\r\n            this.currentAccountContext = {\r\n                homeAccountId: result.account.homeAccountId,\r\n                environment: result.account.environment,\r\n                tenantId: result.account.tenantId,\r\n            };\r\n\r\n            this.eventHandler.emitEvent(\r\n                EventType.ACQUIRE_TOKEN_SUCCESS,\r\n                InteractionType.Popup,\r\n                result\r\n            );\r\n\r\n            atPopupMeasurement.add({\r\n                accessTokenSize: result.accessToken.length,\r\n                idTokenSize: result.idToken.length,\r\n            });\r\n\r\n            atPopupMeasurement.end({\r\n                success: true,\r\n                requestId: result.requestId,\r\n            });\r\n\r\n            return result;\r\n        } catch (e) {\r\n            const error =\r\n                e instanceof AuthError\r\n                    ? e\r\n                    : this.nestedAppAuthAdapter.fromBridgeError(e);\r\n            this.eventHandler.emitEvent(\r\n                EventType.ACQUIRE_TOKEN_FAILURE,\r\n                InteractionType.Popup,\r\n                null,\r\n                e as EventError\r\n            );\r\n\r\n            atPopupMeasurement.end(\r\n                {\r\n                    success: false,\r\n                },\r\n                e\r\n            );\r\n\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal implementation of acquireTokenSilent flow\r\n     * @param request\r\n     * @returns\r\n     */\r\n    private async acquireTokenSilentInternal(\r\n        request: SilentRequest\r\n    ): Promise<AuthenticationResult> {\r\n        const validRequest = this.ensureValidRequest(request);\r\n        this.eventHandler.emitEvent(\r\n            EventType.ACQUIRE_TOKEN_START,\r\n            InteractionType.Silent,\r\n            validRequest\r\n        );\r\n\r\n        // Look for tokens in the cache first\r\n        const result = await this.acquireTokenFromCache(validRequest);\r\n        if (result) {\r\n            this.eventHandler.emitEvent(\r\n                EventType.ACQUIRE_TOKEN_SUCCESS,\r\n                InteractionType.Silent,\r\n                result\r\n            );\r\n            return result;\r\n        }\r\n\r\n        // proceed with acquiring tokens via the host\r\n        const ssoSilentMeasurement = this.performanceClient.startMeasurement(\r\n            PerformanceEvents.SsoSilent,\r\n            validRequest.correlationId\r\n        );\r\n\r\n        ssoSilentMeasurement?.increment({\r\n            visibilityChangeCount: 0,\r\n        });\r\n\r\n        ssoSilentMeasurement?.add({\r\n            nestedAppAuthRequest: true,\r\n        });\r\n\r\n        try {\r\n            const naaRequest =\r\n                this.nestedAppAuthAdapter.toNaaTokenRequest(validRequest);\r\n            const reqTimestamp = TimeUtils.nowSeconds();\r\n            const response = await this.bridgeProxy.getTokenSilent(naaRequest);\r\n\r\n            const result: AuthenticationResult =\r\n                this.nestedAppAuthAdapter.fromNaaTokenResponse(\r\n                    naaRequest,\r\n                    response,\r\n                    reqTimestamp\r\n                );\r\n\r\n            // cache the tokens in the response\r\n            await this.hydrateCache(result, request);\r\n\r\n            // cache the account context in memory after successful token fetch\r\n            this.currentAccountContext = {\r\n                homeAccountId: result.account.homeAccountId,\r\n                environment: result.account.environment,\r\n                tenantId: result.account.tenantId,\r\n            };\r\n\r\n            this.eventHandler.emitEvent(\r\n                EventType.ACQUIRE_TOKEN_SUCCESS,\r\n                InteractionType.Silent,\r\n                result\r\n            );\r\n            ssoSilentMeasurement?.add({\r\n                accessTokenSize: result.accessToken.length,\r\n                idTokenSize: result.idToken.length,\r\n            });\r\n            ssoSilentMeasurement?.end({\r\n                success: true,\r\n                requestId: result.requestId,\r\n            });\r\n            return result;\r\n        } catch (e) {\r\n            const error =\r\n                e instanceof AuthError\r\n                    ? e\r\n                    : this.nestedAppAuthAdapter.fromBridgeError(e);\r\n            this.eventHandler.emitEvent(\r\n                EventType.ACQUIRE_TOKEN_FAILURE,\r\n                InteractionType.Silent,\r\n                null,\r\n                e as EventError\r\n            );\r\n            ssoSilentMeasurement?.end(\r\n                {\r\n                    success: false,\r\n                },\r\n                e\r\n            );\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * acquires tokens from cache\r\n     * @param request\r\n     * @returns\r\n     */\r\n    private async acquireTokenFromCache(\r\n        request: SilentRequest\r\n    ): Promise<AuthenticationResult | null> {\r\n        const atsMeasurement = this.performanceClient.startMeasurement(\r\n            PerformanceEvents.AcquireTokenSilent,\r\n            request.correlationId\r\n        );\r\n\r\n        atsMeasurement?.add({\r\n            nestedAppAuthRequest: true,\r\n        });\r\n\r\n        // if the request has claims, we cannot look up in the cache\r\n        if (request.claims) {\r\n            this.logger.verbose(\r\n                \"Claims are present in the request, skipping cache lookup\"\r\n            );\r\n            return null;\r\n        }\r\n\r\n        // if the request has forceRefresh, we cannot look up in the cache\r\n        if (request.forceRefresh) {\r\n            this.logger.verbose(\r\n                \"forceRefresh is set to true, skipping cache lookup\"\r\n            );\r\n            return null;\r\n        }\r\n\r\n        // respect cache lookup policy\r\n        let result: AuthenticationResult | null = null;\r\n        if (!request.cacheLookupPolicy) {\r\n            request.cacheLookupPolicy = CacheLookupPolicy.Default;\r\n        }\r\n\r\n        switch (request.cacheLookupPolicy) {\r\n            case CacheLookupPolicy.Default:\r\n            case CacheLookupPolicy.AccessToken:\r\n            case CacheLookupPolicy.AccessTokenAndRefreshToken:\r\n                result = await this.acquireTokenFromCacheInternal(request);\r\n                break;\r\n            default:\r\n                return null;\r\n        }\r\n\r\n        if (result) {\r\n            this.eventHandler.emitEvent(\r\n                EventType.ACQUIRE_TOKEN_SUCCESS,\r\n                InteractionType.Silent,\r\n                result\r\n            );\r\n            atsMeasurement?.add({\r\n                accessTokenSize: result?.accessToken.length,\r\n                idTokenSize: result?.idToken.length,\r\n            });\r\n            atsMeasurement?.end({\r\n                success: true,\r\n            });\r\n            return result;\r\n        }\r\n\r\n        this.logger.error(\r\n            \"Cached tokens are not found for the account, proceeding with silent token request.\"\r\n        );\r\n\r\n        this.eventHandler.emitEvent(\r\n            EventType.ACQUIRE_TOKEN_FAILURE,\r\n            InteractionType.Silent,\r\n            null\r\n        );\r\n        atsMeasurement?.end({\r\n            success: false,\r\n        });\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param request\r\n     * @returns\r\n     */\r\n    private async acquireTokenFromCacheInternal(\r\n        request: SilentRequest\r\n    ): Promise<AuthenticationResult | null> {\r\n        // always prioritize the account context from the bridge\r\n        const accountContext =\r\n            this.bridgeProxy.getAccountContext() || this.currentAccountContext;\r\n        let currentAccount: AccountInfo | null = null;\r\n        if (accountContext) {\r\n            currentAccount = AccountManager.getAccount(\r\n                accountContext,\r\n                this.logger,\r\n                this.browserStorage\r\n            );\r\n        }\r\n\r\n        // fall back to brokering if no cached account is found\r\n        if (!currentAccount) {\r\n            this.logger.verbose(\r\n                \"No active account found, falling back to the host\"\r\n            );\r\n            return Promise.resolve(null);\r\n        }\r\n\r\n        this.logger.verbose(\r\n            \"active account found, attempting to acquire token silently\"\r\n        );\r\n\r\n        const authRequest: BaseAuthRequest = {\r\n            ...request,\r\n            correlationId:\r\n                request.correlationId || this.browserCrypto.createNewGuid(),\r\n            authority: request.authority || currentAccount.environment,\r\n            scopes: request.scopes?.length\r\n                ? request.scopes\r\n                : [...OIDC_DEFAULT_SCOPES],\r\n        };\r\n\r\n        // fetch access token and check for expiry\r\n        const tokenKeys = this.browserStorage.getTokenKeys();\r\n        const cachedAccessToken = this.browserStorage.getAccessToken(\r\n            currentAccount,\r\n            authRequest,\r\n            tokenKeys,\r\n            currentAccount.tenantId,\r\n            this.performanceClient,\r\n            authRequest.correlationId\r\n        );\r\n\r\n        // If there is no access token, log it and return null\r\n        if (!cachedAccessToken) {\r\n            this.logger.verbose(\"No cached access token found\");\r\n            return Promise.resolve(null);\r\n        } else if (\r\n            TimeUtils.wasClockTurnedBack(cachedAccessToken.cachedAt) ||\r\n            TimeUtils.isTokenExpired(\r\n                cachedAccessToken.expiresOn,\r\n                this.config.system.tokenRenewalOffsetSeconds\r\n            )\r\n        ) {\r\n            this.logger.verbose(\"Cached access token has expired\");\r\n            return Promise.resolve(null);\r\n        }\r\n\r\n        const cachedIdToken = this.browserStorage.getIdToken(\r\n            currentAccount,\r\n            tokenKeys,\r\n            currentAccount.tenantId,\r\n            this.performanceClient,\r\n            authRequest.correlationId\r\n        );\r\n\r\n        if (!cachedIdToken) {\r\n            this.logger.verbose(\"No cached id token found\");\r\n            return Promise.resolve(null);\r\n        }\r\n\r\n        return this.nestedAppAuthAdapter.toAuthenticationResultFromCache(\r\n            currentAccount,\r\n            cachedIdToken,\r\n            cachedAccessToken,\r\n            authRequest,\r\n            authRequest.correlationId\r\n        );\r\n    }\r\n\r\n    /**\r\n     * acquireTokenPopup flow implementation\r\n     * @param request\r\n     * @returns\r\n     */\r\n    async acquireTokenPopup(\r\n        request: PopupRequest\r\n    ): Promise<AuthenticationResult> {\r\n        return this.acquireTokenInteractive(request);\r\n    }\r\n\r\n    /**\r\n     * acquireTokenRedirect flow is not supported in nested app auth\r\n     * @param request\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    acquireTokenRedirect(request: RedirectRequest): Promise<void> {\r\n        throw NestedAppAuthError.createUnsupportedError();\r\n    }\r\n\r\n    /**\r\n     * acquireTokenSilent flow implementation\r\n     * @param silentRequest\r\n     * @returns\r\n     */\r\n    async acquireTokenSilent(\r\n        silentRequest: SilentRequest\r\n    ): Promise<AuthenticationResult> {\r\n        return this.acquireTokenSilentInternal(silentRequest);\r\n    }\r\n\r\n    /**\r\n     * Hybrid flow is not currently supported in nested app auth\r\n     * @param request\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    acquireTokenByCode(\r\n        request: AuthorizationCodeRequest // eslint-disable-line @typescript-eslint/no-unused-vars\r\n    ): Promise<AuthenticationResult> {\r\n        throw NestedAppAuthError.createUnsupportedError();\r\n    }\r\n\r\n    /**\r\n     * acquireTokenNative flow is not currently supported in nested app auth\r\n     * @param request\r\n     * @param apiId\r\n     * @param accountId\r\n     */\r\n    acquireTokenNative(\r\n        request: // eslint-disable-line @typescript-eslint/no-unused-vars\r\n        | SilentRequest\r\n            | Partial<\r\n                  Omit<\r\n                      CommonAuthorizationUrlRequest,\r\n                      | \"requestedClaimsHash\"\r\n                      | \"responseMode\"\r\n                      | \"codeChallenge\"\r\n                      | \"codeChallengeMethod\"\r\n                      | \"platformBroker\"\r\n                  >\r\n              >\r\n            | PopupRequest,\r\n        apiId: ApiId, // eslint-disable-line @typescript-eslint/no-unused-vars\r\n        accountId?: string | undefined // eslint-disable-line @typescript-eslint/no-unused-vars\r\n    ): Promise<AuthenticationResult> {\r\n        throw NestedAppAuthError.createUnsupportedError();\r\n    }\r\n\r\n    /**\r\n     * acquireTokenByRefreshToken flow is not currently supported in nested app auth\r\n     * @param commonRequest\r\n     * @param silentRequest\r\n     */\r\n    acquireTokenByRefreshToken(\r\n        commonRequest: CommonSilentFlowRequest, // eslint-disable-line @typescript-eslint/no-unused-vars\r\n        silentRequest: SilentRequest // eslint-disable-line @typescript-eslint/no-unused-vars\r\n    ): Promise<AuthenticationResult> {\r\n        throw NestedAppAuthError.createUnsupportedError();\r\n    }\r\n\r\n    /**\r\n     * Adds event callbacks to array\r\n     * @param callback\r\n     * @param eventTypes\r\n     */\r\n    addEventCallback(\r\n        callback: EventCallbackFunction,\r\n        eventTypes?: Array<EventType>\r\n    ): string | null {\r\n        return this.eventHandler.addEventCallback(callback, eventTypes);\r\n    }\r\n\r\n    /**\r\n     * Removes callback with provided id from callback array\r\n     * @param callbackId\r\n     */\r\n    removeEventCallback(callbackId: string): void {\r\n        this.eventHandler.removeEventCallback(callbackId);\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    addPerformanceCallback(callback: PerformanceCallbackFunction): string {\r\n        throw NestedAppAuthError.createUnsupportedError();\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    removePerformanceCallback(callbackId: string): boolean {\r\n        throw NestedAppAuthError.createUnsupportedError();\r\n    }\r\n\r\n    enableAccountStorageEvents(): void {\r\n        throw NestedAppAuthError.createUnsupportedError();\r\n    }\r\n\r\n    disableAccountStorageEvents(): void {\r\n        throw NestedAppAuthError.createUnsupportedError();\r\n    }\r\n\r\n    // #region Account APIs\r\n\r\n    /**\r\n     * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.\r\n     * @param accountFilter - (Optional) filter to narrow down the accounts returned\r\n     * @returns Array of AccountInfo objects in cache\r\n     */\r\n    getAllAccounts(accountFilter?: AccountFilter): AccountInfo[] {\r\n        return AccountManager.getAllAccounts(\r\n            this.logger,\r\n            this.browserStorage,\r\n            this.isBrowserEnv(),\r\n            accountFilter\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the first account found in the cache that matches the account filter passed in.\r\n     * @param accountFilter\r\n     * @returns The first account found in the cache matching the provided filter or null if no account could be found.\r\n     */\r\n    getAccount(accountFilter: AccountFilter): AccountInfo | null {\r\n        return AccountManager.getAccount(\r\n            accountFilter,\r\n            this.logger,\r\n            this.browserStorage\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the signed in account matching username.\r\n     * (the account object is created at the time of successful login)\r\n     * or null when no matching account is found.\r\n     * This API is provided for convenience but getAccountById should be used for best reliability\r\n     * @param username\r\n     * @returns The account object stored in MSAL\r\n     */\r\n    getAccountByUsername(username: string): AccountInfo | null {\r\n        return AccountManager.getAccountByUsername(\r\n            username,\r\n            this.logger,\r\n            this.browserStorage\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the signed in account matching homeAccountId.\r\n     * (the account object is created at the time of successful login)\r\n     * or null when no matching account is found\r\n     * @param homeAccountId\r\n     * @returns The account object stored in MSAL\r\n     */\r\n    getAccountByHomeId(homeAccountId: string): AccountInfo | null {\r\n        return AccountManager.getAccountByHomeId(\r\n            homeAccountId,\r\n            this.logger,\r\n            this.browserStorage\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the signed in account matching localAccountId.\r\n     * (the account object is created at the time of successful login)\r\n     * or null when no matching account is found\r\n     * @param localAccountId\r\n     * @returns The account object stored in MSAL\r\n     */\r\n    getAccountByLocalId(localAccountId: string): AccountInfo | null {\r\n        return AccountManager.getAccountByLocalId(\r\n            localAccountId,\r\n            this.logger,\r\n            this.browserStorage\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sets the account to use as the active account. If no account is passed to the acquireToken APIs, then MSAL will use this active account.\r\n     * @param account\r\n     */\r\n    setActiveAccount(account: AccountInfo | null): void {\r\n        /*\r\n         * StandardController uses this to allow the developer to set the active account\r\n         * in the nested app auth scenario the active account is controlled by the app hosting the nested app\r\n         */\r\n        return AccountManager.setActiveAccount(account, this.browserStorage);\r\n    }\r\n\r\n    /**\r\n     * Gets the currently active account\r\n     */\r\n    getActiveAccount(): AccountInfo | null {\r\n        return AccountManager.getActiveAccount(this.browserStorage);\r\n    }\r\n\r\n    // #endregion\r\n\r\n    handleRedirectPromise(\r\n        hash?: string | undefined // eslint-disable-line @typescript-eslint/no-unused-vars\r\n    ): Promise<AuthenticationResult | null> {\r\n        return Promise.resolve(null);\r\n    }\r\n    loginPopup(\r\n        request?: PopupRequest | undefined // eslint-disable-line @typescript-eslint/no-unused-vars\r\n    ): Promise<AuthenticationResult> {\r\n        return this.acquireTokenInteractive(request || DEFAULT_REQUEST);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    loginRedirect(request?: RedirectRequest | undefined): Promise<void> {\r\n        throw NestedAppAuthError.createUnsupportedError();\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    logout(logoutRequest?: EndSessionRequest | undefined): Promise<void> {\r\n        throw NestedAppAuthError.createUnsupportedError();\r\n    }\r\n    logoutRedirect(\r\n        logoutRequest?: EndSessionRequest | undefined // eslint-disable-line @typescript-eslint/no-unused-vars\r\n    ): Promise<void> {\r\n        throw NestedAppAuthError.createUnsupportedError();\r\n    }\r\n    logoutPopup(\r\n        logoutRequest?: EndSessionPopupRequest | undefined // eslint-disable-line @typescript-eslint/no-unused-vars\r\n    ): Promise<void> {\r\n        throw NestedAppAuthError.createUnsupportedError();\r\n    }\r\n    ssoSilent(\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        request: Partial<\r\n            Omit<\r\n                CommonAuthorizationUrlRequest,\r\n                | \"requestedClaimsHash\"\r\n                | \"responseMode\"\r\n                | \"codeChallenge\"\r\n                | \"codeChallengeMethod\"\r\n                | \"platformBroker\"\r\n            >\r\n        >\r\n    ): Promise<AuthenticationResult> {\r\n        return this.acquireTokenSilentInternal(request as SilentRequest);\r\n    }\r\n    getTokenCache(): ITokenCache {\r\n        throw NestedAppAuthError.createUnsupportedError();\r\n    }\r\n\r\n    /**\r\n     * Returns the logger instance\r\n     */\r\n    public getLogger(): Logger {\r\n        return this.logger;\r\n    }\r\n\r\n    /**\r\n     * Replaces the default logger set in configurations with new Logger with new configurations\r\n     * @param logger Logger instance\r\n     */\r\n    setLogger(logger: Logger): void {\r\n        this.logger = logger;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    initializeWrapperLibrary(sku: WrapperSKU, version: string): void {\r\n        /*\r\n         * Standard controller uses this to set the sku and version of the wrapper library in the storage\r\n         * we do nothing here\r\n         */\r\n        return;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    setNavigationClient(navigationClient: INavigationClient): void {\r\n        this.logger.warning(\r\n            \"setNavigationClient is not supported in nested app auth\"\r\n        );\r\n    }\r\n\r\n    getConfiguration(): BrowserConfiguration {\r\n        return this.config;\r\n    }\r\n\r\n    isBrowserEnv(): boolean {\r\n        return this.operatingContext.isBrowserEnvironment();\r\n    }\r\n\r\n    getBrowserCrypto(): ICrypto {\r\n        return this.browserCrypto;\r\n    }\r\n\r\n    getPerformanceClient(): IPerformanceClient {\r\n        throw NestedAppAuthError.createUnsupportedError();\r\n    }\r\n\r\n    getRedirectResponse(): Map<string, Promise<AuthenticationResult | null>> {\r\n        throw NestedAppAuthError.createUnsupportedError();\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    async clearCache(logoutRequest?: ClearCacheRequest): Promise<void> {\r\n        throw NestedAppAuthError.createUnsupportedError();\r\n    }\r\n\r\n    async hydrateCache(\r\n        result: AuthenticationResult,\r\n        request:\r\n            | SilentRequest\r\n            | SsoSilentRequest\r\n            | RedirectRequest\r\n            | PopupRequest\r\n    ): Promise<void> {\r\n        this.logger.verbose(\"hydrateCache called\");\r\n\r\n        const accountEntity = AccountEntity.createFromAccountInfo(\r\n            result.account,\r\n            result.cloudGraphHostName,\r\n            result.msGraphHost\r\n        );\r\n        await this.browserStorage.setAccount(\r\n            accountEntity,\r\n            result.correlationId\r\n        );\r\n        return this.browserStorage.hydrateCache(result, request);\r\n    }\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;AAAA;;;AAGG;MAyDUA,uBAAuB;EA+BhCC,YAAYC,gBAA2C;IACnD,IAAI,CAACA,gBAAgB,GAAGA,gBAAgB;IACxC,MAAMC,KAAK,GAAG,IAAI,CAACD,gBAAgB,CAACE,cAAc,EAAE;IACpD,IAAID,KAAK,KAAKE,SAAS,EAAE;MACrB,IAAI,CAACC,WAAW,GAAGH,KAAK;IAC3B,OAAM;MACH,MAAM,IAAII,KAAK,CAAC,sCAAsC,CAAC;IAC1D;;IAGD,IAAI,CAACC,MAAM,GAAGN,gBAAgB,CAACO,SAAS,EAAE;;IAG1C,IAAI,CAACC,MAAM,GAAG,IAAI,CAACR,gBAAgB,CAACS,SAAS,EAAE;;IAG/C,IAAI,CAACC,iBAAiB,GAAG,IAAI,CAACJ,MAAM,CAACK,SAAS,CAACC,MAAM;;IAGrD,IAAI,CAACC,aAAa,GAAGb,gBAAgB,CAACc,oBAAoB,EAAE,GACtD,IAAIC,SAAS,CAAC,IAAI,CAACP,MAAM,EAAE,IAAI,CAACE,iBAAiB,EAAE,IAAI,CAAC,GACxDM,6BAA6B;IAEnC,IAAI,CAACC,YAAY,GAAG,IAAIC,YAAY,CAAC,IAAI,CAACV,MAAM,CAAC;;IAEjD,IAAI,CAACW,cAAc,GAAG,IAAI,CAACnB,gBAAgB,CAACc,oBAAoB,EAAE,GAC5D,IAAIM,mBAAmB,CACnB,IAAI,CAACd,MAAM,CAACe,IAAI,CAACC,QAAQ,EACzB,IAAI,CAAChB,MAAM,CAACiB,KAAK,EACjB,IAAI,CAACV,aAAa,EAClB,IAAI,CAACL,MAAM,EACX,IAAI,CAACE,iBAAiB,EACtB,IAAI,CAACO,YAAY,EACjBO,2BAA2B,CAAC,IAAI,CAAClB,MAAM,CAACe,IAAI,CAAC,CAChD,GACDI,6BAA6B,CACzB,IAAI,CAACnB,MAAM,CAACe,IAAI,CAACC,QAAQ,EACzB,IAAI,CAACd,MAAM,EACX,IAAI,CAACE,iBAAiB,EACtB,IAAI,CAACO,YAAY,CACpB;IAEP,IAAI,CAACS,oBAAoB,GAAG,IAAIC,oBAAoB,CAChD,IAAI,CAACrB,MAAM,CAACe,IAAI,CAACC,QAAQ,EACzB,IAAI,CAAChB,MAAM,CAACe,IAAI,CAACO,kBAAkB,EACnC,IAAI,CAACf,aAAa,EAClB,IAAI,CAACL,MAAM,CACd;;IAGD,MAAMqB,cAAc,GAAG,IAAI,CAACzB,WAAW,CAAC0B,iBAAiB,EAAE;IAC3D,IAAI,CAACC,qBAAqB,GAAGF,cAAc,GAAGA,cAAc,GAAG,IAAI;;EAGvE;;;;AAIG;EACH,aAAaG,gBAAgBA,CACzBhC,gBAA2C;IAE3C,MAAMiC,UAAU,GAAG,IAAInC,uBAAuB,CAACE,gBAAgB,CAAC;IAChE,OAAOkC,OAAO,CAACC,OAAO,CAACF,UAAU,CAAC;;EAGtC;;;AAGG;EACH,MAAMG,UAAUA,CAACC,OAAsC;IACnD,MAAMC,iBAAiB,GAAGD,OAAO,EAAEE,aAAa,IAAIC,aAAa,EAAE;IACnE,MAAM,IAAI,CAACrB,cAAc,CAACiB,UAAU,CAACE,iBAAiB,CAAC;IACvD,OAAOJ,OAAO,CAACC,OAAO,EAAE;;EAG5B;;;;AAIG;EACKM,kBAAkBA,CAMxBJ,OAAU;IACR,IAAIA,OAAO,EAAEE,aAAa,EAAE;MACxB,OAAOF,OAAO;IACjB;IACD,OAAO;MACH,GAAGA,OAAO;MACVE,aAAa,EAAE,IAAI,CAAC1B,aAAa,CAAC2B,aAAa;KAClD;;EAGL;;;;AAIG;EACK,MAAME,uBAAuBA,CACjCL,OAAuC;IAEvC,MAAMM,YAAY,GAAG,IAAI,CAACF,kBAAkB,CAACJ,OAAO,CAAC;IAErD,IAAI,CAACpB,YAAY,CAAC2B,SAAS,CACvBC,SAAS,CAACC,mBAAmB,EAC7BC,eAAe,CAACC,KAAK,EACrBL,YAAY,CACf;IAED,MAAMM,kBAAkB,GAAG,IAAI,CAACvC,iBAAiB,CAACwC,gBAAgB,CAC9DC,iBAAiB,CAACC,iBAAiB,EACnCT,YAAY,CAACJ,aAAa,CAC7B;IAEDU,kBAAkB,EAAEI,GAAG,CAAC;MAAEC,oBAAoB,EAAE;IAAI,CAAE,CAAC;IAEvD,IAAI;MACA,MAAMC,UAAU,GACZ,IAAI,CAAC7B,oBAAoB,CAAC8B,iBAAiB,CAACb,YAAY,CAAC;MAC7D,MAAMc,YAAY,GAAGC,SAAS,CAACC,UAAU,EAAE;MAC3C,MAAMC,QAAQ,GAAG,MAAM,IAAI,CAACxD,WAAW,CAACyD,mBAAmB,CACvDN,UAAU,CACb;MACD,MAAMO,MAAM,GAAyB;QACjC,GAAG,IAAI,CAACpC,oBAAoB,CAACqC,oBAAoB,CAC7CR,UAAU,EACVK,QAAQ,EACRH,YAAY;OAEnB;;MAGD,MAAM,IAAI,CAACO,YAAY,CAACF,MAAM,EAAEzB,OAAO,CAAC;;MAGxC,IAAI,CAACN,qBAAqB,GAAG;QACzBkC,aAAa,EAAEH,MAAM,CAACI,OAAO,CAACD,aAAa;QAC3CE,WAAW,EAAEL,MAAM,CAACI,OAAO,CAACC,WAAW;QACvCC,QAAQ,EAAEN,MAAM,CAACI,OAAO,CAACE;OAC5B;MAED,IAAI,CAACnD,YAAY,CAAC2B,SAAS,CACvBC,SAAS,CAACwB,qBAAqB,EAC/BtB,eAAe,CAACC,KAAK,EACrBc,MAAM,CACT;MAEDb,kBAAkB,CAACI,GAAG,CAAC;QACnBiB,eAAe,EAAER,MAAM,CAACS,WAAW,CAACC,MAAM;QAC1CC,WAAW,EAAEX,MAAM,CAACY,OAAO,CAACF;MAC/B,EAAC;MAEFvB,kBAAkB,CAAC0B,GAAG,CAAC;QACnBC,OAAO,EAAE,IAAI;QACbC,SAAS,EAAEf,MAAM,CAACe;MACrB,EAAC;MAEF,OAAOf,MAAM;IAChB,EAAC,OAAOgB,CAAC,EAAE;MACR,MAAMC,KAAK,GACPD,CAAC,YAAYE,SAAS,GAChBF,CAAC,GACD,IAAI,CAACpD,oBAAoB,CAACuD,eAAe,CAACH,CAAC,CAAC;MACtD,IAAI,CAAC7D,YAAY,CAAC2B,SAAS,CACvBC,SAAS,CAACqC,qBAAqB,EAC/BnC,eAAe,CAACC,KAAK,EACrB,IAAI,EACJ8B,CAAe,CAClB;MAED7B,kBAAkB,CAAC0B,GAAG,CAClB;QACIC,OAAO,EAAE;OACZ,EACDE,CAAC,CACJ;MAED,MAAMC,KAAK;IACd;;EAGL;;;;AAIG;EACK,MAAMI,0BAA0BA,CACpC9C,OAAsB;IAEtB,MAAMM,YAAY,GAAG,IAAI,CAACF,kBAAkB,CAACJ,OAAO,CAAC;IACrD,IAAI,CAACpB,YAAY,CAAC2B,SAAS,CACvBC,SAAS,CAACC,mBAAmB,EAC7BC,eAAe,CAACqC,MAAM,EACtBzC,YAAY,CACf;;IAGD,MAAMmB,MAAM,GAAG,MAAM,IAAI,CAACuB,qBAAqB,CAAC1C,YAAY,CAAC;IAC7D,IAAImB,MAAM,EAAE;MACR,IAAI,CAAC7C,YAAY,CAAC2B,SAAS,CACvBC,SAAS,CAACwB,qBAAqB,EAC/BtB,eAAe,CAACqC,MAAM,EACtBtB,MAAM,CACT;MACD,OAAOA,MAAM;IAChB;;IAGD,MAAMwB,oBAAoB,GAAG,IAAI,CAAC5E,iBAAiB,CAACwC,gBAAgB,CAChEC,iBAAiB,CAACoC,SAAS,EAC3B5C,YAAY,CAACJ,aAAa,CAC7B;IAED+C,oBAAoB,EAAEE,SAAS,CAAC;MAC5BC,qBAAqB,EAAE;IAC1B,EAAC;IAEFH,oBAAoB,EAAEjC,GAAG,CAAC;MACtBC,oBAAoB,EAAE;IACzB,EAAC;IAEF,IAAI;MACA,MAAMC,UAAU,GACZ,IAAI,CAAC7B,oBAAoB,CAAC8B,iBAAiB,CAACb,YAAY,CAAC;MAC7D,MAAMc,YAAY,GAAGC,SAAS,CAACC,UAAU,EAAE;MAC3C,MAAMC,QAAQ,GAAG,MAAM,IAAI,CAACxD,WAAW,CAACsF,cAAc,CAACnC,UAAU,CAAC;MAElE,MAAMO,MAAM,GACR,IAAI,CAACpC,oBAAoB,CAACqC,oBAAoB,CAC1CR,UAAU,EACVK,QAAQ,EACRH,YAAY,CACf;;MAGL,MAAM,IAAI,CAACO,YAAY,CAACF,MAAM,EAAEzB,OAAO,CAAC;;MAGxC,IAAI,CAACN,qBAAqB,GAAG;QACzBkC,aAAa,EAAEH,MAAM,CAACI,OAAO,CAACD,aAAa;QAC3CE,WAAW,EAAEL,MAAM,CAACI,OAAO,CAACC,WAAW;QACvCC,QAAQ,EAAEN,MAAM,CAACI,OAAO,CAACE;OAC5B;MAED,IAAI,CAACnD,YAAY,CAAC2B,SAAS,CACvBC,SAAS,CAACwB,qBAAqB,EAC/BtB,eAAe,CAACqC,MAAM,EACtBtB,MAAM,CACT;MACDwB,oBAAoB,EAAEjC,GAAG,CAAC;QACtBiB,eAAe,EAAER,MAAM,CAACS,WAAW,CAACC,MAAM;QAC1CC,WAAW,EAAEX,MAAM,CAACY,OAAO,CAACF;MAC/B,EAAC;MACFc,oBAAoB,EAAEX,GAAG,CAAC;QACtBC,OAAO,EAAE,IAAI;QACbC,SAAS,EAAEf,MAAM,CAACe;MACrB,EAAC;MACF,OAAOf,MAAM;IAChB,EAAC,OAAOgB,CAAC,EAAE;MACR,MAAMC,KAAK,GACPD,CAAC,YAAYE,SAAS,GAChBF,CAAC,GACD,IAAI,CAACpD,oBAAoB,CAACuD,eAAe,CAACH,CAAC,CAAC;MACtD,IAAI,CAAC7D,YAAY,CAAC2B,SAAS,CACvBC,SAAS,CAACqC,qBAAqB,EAC/BnC,eAAe,CAACqC,MAAM,EACtB,IAAI,EACJN,CAAe,CAClB;MACDQ,oBAAoB,EAAEX,GAAG,CACrB;QACIC,OAAO,EAAE;OACZ,EACDE,CAAC,CACJ;MACD,MAAMC,KAAK;IACd;;EAGL;;;;AAIG;EACK,MAAMM,qBAAqBA,CAC/BhD,OAAsB;IAEtB,MAAMsD,cAAc,GAAG,IAAI,CAACjF,iBAAiB,CAACwC,gBAAgB,CAC1DC,iBAAiB,CAACyC,kBAAkB,EACpCvD,OAAO,CAACE,aAAa,CACxB;IAEDoD,cAAc,EAAEtC,GAAG,CAAC;MAChBC,oBAAoB,EAAE;IACzB,EAAC;;IAGF,IAAIjB,OAAO,CAACwD,MAAM,EAAE;MAChB,IAAI,CAACrF,MAAM,CAACsF,OAAO,CACf,0DAA0D,CAC7D;MACD,OAAO,IAAI;IACd;;IAGD,IAAIzD,OAAO,CAAC0D,YAAY,EAAE;MACtB,IAAI,CAACvF,MAAM,CAACsF,OAAO,CACf,oDAAoD,CACvD;MACD,OAAO,IAAI;IACd;;IAGD,IAAIhC,MAAM,GAAgC,IAAI;IAC9C,IAAI,CAACzB,OAAO,CAAC2D,iBAAiB,EAAE;MAC5B3D,OAAO,CAAC2D,iBAAiB,GAAGC,iBAAiB,CAACC,OAAO;IACxD;IAED,QAAQ7D,OAAO,CAAC2D,iBAAiB;MAC7B,KAAKC,iBAAiB,CAACC,OAAO;MAC9B,KAAKD,iBAAiB,CAACE,WAAW;MAClC,KAAKF,iBAAiB,CAACG,0BAA0B;QAC7CtC,MAAM,GAAG,MAAM,IAAI,CAACuC,6BAA6B,CAAChE,OAAO,CAAC;QAC1D;MACJ;QACI,OAAO,IAAI;IAClB;IAED,IAAIyB,MAAM,EAAE;MACR,IAAI,CAAC7C,YAAY,CAAC2B,SAAS,CACvBC,SAAS,CAACwB,qBAAqB,EAC/BtB,eAAe,CAACqC,MAAM,EACtBtB,MAAM,CACT;MACD6B,cAAc,EAAEtC,GAAG,CAAC;QAChBiB,eAAe,EAAER,MAAM,EAAES,WAAW,CAACC,MAAM;QAC3CC,WAAW,EAAEX,MAAM,EAAEY,OAAO,CAACF;MAChC,EAAC;MACFmB,cAAc,EAAEhB,GAAG,CAAC;QAChBC,OAAO,EAAE;MACZ,EAAC;MACF,OAAOd,MAAM;IAChB;IAED,IAAI,CAACtD,MAAM,CAACuE,KAAK,CACb,oFAAoF,CACvF;IAED,IAAI,CAAC9D,YAAY,CAAC2B,SAAS,CACvBC,SAAS,CAACqC,qBAAqB,EAC/BnC,eAAe,CAACqC,MAAM,EACtB,IAAI,CACP;IACDO,cAAc,EAAEhB,GAAG,CAAC;MAChBC,OAAO,EAAE;IACZ,EAAC;IAEF,OAAO,IAAI;;EAGf;;;;AAIG;EACK,MAAMyB,6BAA6BA,CACvChE,OAAsB;;IAGtB,MAAMR,cAAc,GAChB,IAAI,CAACzB,WAAW,CAAC0B,iBAAiB,EAAE,IAAI,IAAI,CAACC,qBAAqB;IACtE,IAAIuE,cAAc,GAAuB,IAAI;IAC7C,IAAIzE,cAAc,EAAE;MAChByE,cAAc,GAAGC,UAAyB,CACtC1E,cAAc,EACd,IAAI,CAACrB,MAAM,EACX,IAAI,CAACW,cAAc,CACtB;IACJ;;IAGD,IAAI,CAACmF,cAAc,EAAE;MACjB,IAAI,CAAC9F,MAAM,CAACsF,OAAO,CACf,mDAAmD,CACtD;MACD,OAAO5D,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;IAC/B;IAED,IAAI,CAAC3B,MAAM,CAACsF,OAAO,CACf,4DAA4D,CAC/D;IAED,MAAMU,WAAW,GAAoB;MACjC,GAAGnE,OAAO;MACVE,aAAa,EACTF,OAAO,CAACE,aAAa,IAAI,IAAI,CAAC1B,aAAa,CAAC2B,aAAa,EAAE;MAC/DiE,SAAS,EAAEpE,OAAO,CAACoE,SAAS,IAAIH,cAAc,CAACnC,WAAW;MAC1DuC,MAAM,EAAErE,OAAO,CAACqE,MAAM,EAAElC,MAAM,GACxBnC,OAAO,CAACqE,MAAM,GACd,CAAC,GAAGC,mBAAmB;KAChC;;IAGD,MAAMC,SAAS,GAAG,IAAI,CAACzF,cAAc,CAAC0F,YAAY,EAAE;IACpD,MAAMC,iBAAiB,GAAG,IAAI,CAAC3F,cAAc,CAAC4F,cAAc,CACxDT,cAAc,EACdE,WAAW,EACXI,SAAS,EACTN,cAAc,CAAClC,QAAQ,EACvB,IAAI,CAAC1D,iBAAiB,EACtB8F,WAAW,CAACjE,aAAa,CAC5B;;IAGD,IAAI,CAACuE,iBAAiB,EAAE;MACpB,IAAI,CAACtG,MAAM,CAACsF,OAAO,CAAC,8BAA8B,CAAC;MACnD,OAAO5D,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;IAC/B,OAAM,IACHuB,SAAS,CAACsD,kBAAkB,CAACF,iBAAiB,CAACG,QAAQ,CAAC,IACxDvD,SAAS,CAACwD,cAAc,CACpBJ,iBAAiB,CAACK,SAAS,EAC3B,IAAI,CAAC7G,MAAM,CAAC8G,MAAM,CAACC,yBAAyB,CAC/C,EACH;MACE,IAAI,CAAC7G,MAAM,CAACsF,OAAO,CAAC,iCAAiC,CAAC;MACtD,OAAO5D,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;IAC/B;IAED,MAAMmF,aAAa,GAAG,IAAI,CAACnG,cAAc,CAACoG,UAAU,CAChDjB,cAAc,EACdM,SAAS,EACTN,cAAc,CAAClC,QAAQ,EACvB,IAAI,CAAC1D,iBAAiB,EACtB8F,WAAW,CAACjE,aAAa,CAC5B;IAED,IAAI,CAAC+E,aAAa,EAAE;MAChB,IAAI,CAAC9G,MAAM,CAACsF,OAAO,CAAC,0BAA0B,CAAC;MAC/C,OAAO5D,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;IAC/B;IAED,OAAO,IAAI,CAACT,oBAAoB,CAAC8F,+BAA+B,CAC5DlB,cAAc,EACdgB,aAAa,EACbR,iBAAiB,EACjBN,WAAW,EACXA,WAAW,CAACjE,aAAa,CAC5B;;EAGL;;;;AAIG;EACH,MAAMkF,iBAAiBA,CACnBpF,OAAqB;IAErB,OAAO,IAAI,CAACK,uBAAuB,CAACL,OAAO,CAAC;;EAGhD;;;AAGG;;EAEHqF,oBAAoBA,CAACrF,OAAwB;IACzC,MAAMsF,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrD;;;;AAIG;EACH,MAAMC,kBAAkBA,CACpBC,aAA4B;IAE5B,OAAO,IAAI,CAAC3C,0BAA0B,CAAC2C,aAAa,CAAC;;EAGzD;;;AAGG;;EAEHC,kBAAkBA,CACd1F,OAAiC;EAAA,E;IAEjC,MAAMsF,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrD;;;;;AAKG;EACHI,kBAAkBA,CACd3F,OAYkB,EAClB4F,KAAY;EAAA;EACZC,SAA8B;EAAA,E;IAE9B,MAAMP,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrD;;;;AAIG;EACHO,0BAA0BA,CACtBC,aAAsC;EAAA;EACtCN,aAA4B;EAAA,E;IAE5B,MAAMH,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrD;;;;AAIG;EACHS,gBAAgBA,CACZC,QAA+B,EAC/BC,UAA6B;IAE7B,OAAO,IAAI,CAACtH,YAAY,CAACoH,gBAAgB,CAACC,QAAQ,EAAEC,UAAU,CAAC;;EAGnE;;;AAGG;EACHC,mBAAmBA,CAACC,UAAkB;IAClC,IAAI,CAACxH,YAAY,CAACuH,mBAAmB,CAACC,UAAU,CAAC;;;EAIrDC,sBAAsBA,CAACJ,QAAqC;IACxD,MAAMX,kBAAkB,CAACC,sBAAsB,EAAE;;;EAIrDe,yBAAyBA,CAACF,UAAkB;IACxC,MAAMd,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrDgB,0BAA0BA,CAAA;IACtB,MAAMjB,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrDiB,2BAA2BA,CAAA;IACvB,MAAMlB,kBAAkB,CAACC,sBAAsB,EAAE;;;EAKrD;;;;AAIG;EACHkB,cAAcA,CAACC,aAA6B;IACxC,OAAOD,cAA6B,CAChC,IAAI,CAACtI,MAAM,EACX,IAAI,CAACW,cAAc,EACnB,IAAI,CAAC6H,YAAY,EAAE,EACnBD,aAAa,CAChB;;EAGL;;;;AAIG;EACHxC,UAAUA,CAACwC,aAA4B;IACnC,OAAOxC,UAAyB,CAC5BwC,aAAa,EACb,IAAI,CAACvI,MAAM,EACX,IAAI,CAACW,cAAc,CACtB;;EAGL;;;;;;;AAOG;EACH8H,oBAAoBA,CAACC,QAAgB;IACjC,OAAOD,oBAAmC,CACtCC,QAAQ,EACR,IAAI,CAAC1I,MAAM,EACX,IAAI,CAACW,cAAc,CACtB;;EAGL;;;;;;AAMG;EACHgI,kBAAkBA,CAAClF,aAAqB;IACpC,OAAOkF,kBAAiC,CACpClF,aAAa,EACb,IAAI,CAACzD,MAAM,EACX,IAAI,CAACW,cAAc,CACtB;;EAGL;;;;;;AAMG;EACHiI,mBAAmBA,CAACC,cAAsB;IACtC,OAAOD,mBAAkC,CACrCC,cAAc,EACd,IAAI,CAAC7I,MAAM,EACX,IAAI,CAACW,cAAc,CACtB;;EAGL;;;AAGG;EACHmI,gBAAgBA,CAACpF,OAA2B;IACxC;;;AAGG;IACH,OAAOoF,gBAA+B,CAACpF,OAAO,EAAE,IAAI,CAAC/C,cAAc,CAAC;;EAGxE;;AAEG;EACHoI,gBAAgBA,CAAA;IACZ,OAAOA,gBAA+B,CAAC,IAAI,CAACpI,cAAc,CAAC;;;EAK/DqI,qBAAqBA,CACjBC,IAAyB;EAAA,E;IAEzB,OAAOvH,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;;EAEhCuH,UAAUA,CACNrH,OAAkC;EAAA,E;IAElC,OAAO,IAAI,CAACK,uBAAuB,CAACL,OAAO,IAAIsH,eAAe,CAAC;;;EAGnEC,aAAaA,CAACvH,OAAqC;IAC/C,MAAMsF,kBAAkB,CAACC,sBAAsB,EAAE;;;EAGrDiC,MAAMA,CAACC,aAA6C;IAChD,MAAMnC,kBAAkB,CAACC,sBAAsB,EAAE;;EAErDmC,cAAcA,CACVD,aAA6C;EAAA,E;IAE7C,MAAMnC,kBAAkB,CAACC,sBAAsB,EAAE;;EAErDoC,WAAWA,CACPF,aAAkD;EAAA,E;IAElD,MAAMnC,kBAAkB,CAACC,sBAAsB,EAAE;;EAErDqC,SAASA;;EAEL5H,OASC;IAED,OAAO,IAAI,CAAC8C,0BAA0B,CAAC9C,OAAwB,CAAC;;EAEpE6H,aAAaA,CAAA;IACT,MAAMvC,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrD;;AAEG;EACInH,SAASA,CAAA;IACZ,OAAO,IAAI,CAACD,MAAM;;EAGtB;;;AAGG;EACH2J,SAASA,CAAC3J,MAAc;IACpB,IAAI,CAACA,MAAM,GAAGA,MAAM;;;EAIxB4J,wBAAwBA,CAACC,GAAe,EAAEC,OAAe;IACrD;;;AAGG;IACH;;;EAIJC,mBAAmBA,CAACC,gBAAmC;IACnD,IAAI,CAAChK,MAAM,CAACiK,OAAO,CACf,yDAAyD,CAC5D;;EAGLC,gBAAgBA,CAAA;IACZ,OAAO,IAAI,CAACpK,MAAM;;EAGtB0I,YAAYA,CAAA;IACR,OAAO,IAAI,CAAChJ,gBAAgB,CAACc,oBAAoB,EAAE;;EAGvD6J,gBAAgBA,CAAA;IACZ,OAAO,IAAI,CAAC9J,aAAa;;EAG7B+J,oBAAoBA,CAAA;IAChB,MAAMjD,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrDiD,mBAAmBA,CAAA;IACf,MAAMlD,kBAAkB,CAACC,sBAAsB,EAAE;;;EAIrD,MAAMkD,UAAUA,CAAChB,aAAiC;IAC9C,MAAMnC,kBAAkB,CAACC,sBAAsB,EAAE;;EAGrD,MAAM5D,YAAYA,CACdF,MAA4B,EAC5BzB,OAIkB;IAElB,IAAI,CAAC7B,MAAM,CAACsF,OAAO,CAAC,qBAAqB,CAAC;IAE1C,MAAMiF,aAAa,GAAGC,aAAa,CAACC,qBAAqB,CACrDnH,MAAM,CAACI,OAAO,EACdJ,MAAM,CAACoH,kBAAkB,EACzBpH,MAAM,CAACqH,WAAW,CACrB;IACD,MAAM,IAAI,CAAChK,cAAc,CAACiK,UAAU,CAChCL,aAAa,EACbjH,MAAM,CAACvB,aAAa,CACvB;IACD,OAAO,IAAI,CAACpB,cAAc,CAAC6C,YAAY,CAACF,MAAM,EAAEzB,OAAO,CAAC;;AAE/D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}