{"ast":null,"code":"/*! @azure/msal-common v15.2.0 2025-02-18 */\n'use strict';\n\nimport { IntFields, PerformanceEventAbbreviations, PerformanceEventStatus } from './PerformanceEvent.mjs';\nimport { StubPerformanceMeasurement } from './StubPerformanceClient.mjs';\nimport { AuthError } from '../../error/AuthError.mjs';\nimport { CacheError } from '../../error/CacheError.mjs';\nimport { ServerError } from '../../error/ServerError.mjs';\nimport { InteractionRequiredAuthError } from '../../error/InteractionRequiredAuthError.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Starts context by adding payload to the stack\r\n * @param event {PerformanceEvent}\r\n * @param abbreviations {Map<string, string>} event name abbreviations\r\n * @param stack {?PerformanceEventStackedContext[]} stack\r\n */\nfunction startContext(event, abbreviations, stack) {\n  if (!stack) {\n    return;\n  }\n  stack.push({\n    name: abbreviations.get(event.name) || event.name\n  });\n}\n/**\r\n * Ends context by removing payload from the stack and returning parent or self, if stack is empty, payload\r\n *\r\n * @param event {PerformanceEvent}\r\n * @param abbreviations {Map<string, string>} event name abbreviations\r\n * @param stack {?PerformanceEventStackedContext[]} stack\r\n * @param error {?unknown} error\r\n */\nfunction endContext(event, abbreviations, stack, error) {\n  if (!stack?.length) {\n    return;\n  }\n  const peek = stack => {\n    return stack.length ? stack[stack.length - 1] : undefined;\n  };\n  const abbrEventName = abbreviations.get(event.name) || event.name;\n  const top = peek(stack);\n  if (top?.name !== abbrEventName) {\n    return;\n  }\n  const current = stack?.pop();\n  if (!current) {\n    return;\n  }\n  const errorCode = error instanceof AuthError ? error.errorCode : error instanceof Error ? error.name : undefined;\n  const subErr = error instanceof AuthError ? error.subError : undefined;\n  if (errorCode && current.childErr !== errorCode) {\n    current.err = errorCode;\n    if (subErr) {\n      current.subErr = subErr;\n    }\n  }\n  delete current.name;\n  delete current.childErr;\n  const context = {\n    ...current,\n    dur: event.durationMs\n  };\n  if (!event.success) {\n    context.fail = 1;\n  }\n  const parent = peek(stack);\n  if (!parent) {\n    return {\n      [abbrEventName]: context\n    };\n  }\n  if (errorCode) {\n    parent.childErr = errorCode;\n  }\n  let childName;\n  if (!parent[abbrEventName]) {\n    childName = abbrEventName;\n  } else {\n    const siblings = Object.keys(parent).filter(key => key.startsWith(abbrEventName)).length;\n    childName = `${abbrEventName}_${siblings + 1}`;\n  }\n  parent[childName] = context;\n  return parent;\n}\n/**\r\n * Adds error name and stack trace to the telemetry event\r\n * @param error {Error}\r\n * @param logger {Logger}\r\n * @param event {PerformanceEvent}\r\n * @param stackMaxSize {number} max error stack size to capture\r\n */\nfunction addError(error, logger, event, stackMaxSize = 5) {\n  if (!(error instanceof Error)) {\n    logger.trace(\"PerformanceClient.addErrorStack: Input error is not instance of Error\", event.correlationId);\n    return;\n  } else if (error instanceof AuthError) {\n    event.errorCode = error.errorCode;\n    event.subErrorCode = error.subError;\n    if (error instanceof ServerError || error instanceof InteractionRequiredAuthError) {\n      event.serverErrorNo = error.errorNo;\n    }\n    return;\n  } else if (error instanceof CacheError) {\n    event.errorCode = error.errorCode;\n    return;\n  } else if (event.errorStack?.length) {\n    logger.trace(\"PerformanceClient.addErrorStack: Stack already exist\", event.correlationId);\n    return;\n  } else if (!error.stack?.length) {\n    logger.trace(\"PerformanceClient.addErrorStack: Input stack is empty\", event.correlationId);\n    return;\n  }\n  if (error.stack) {\n    event.errorStack = compactStack(error.stack, stackMaxSize);\n  }\n  event.errorName = error.name;\n}\n/**\r\n * Compacts error stack into array by fetching N first entries\r\n * @param stack {string} error stack\r\n * @param stackMaxSize {number} max error stack size to capture\r\n * @returns {string[]}\r\n */\nfunction compactStack(stack, stackMaxSize) {\n  if (stackMaxSize < 0) {\n    return [];\n  }\n  const stackArr = stack.split(\"\\n\") || [];\n  const res = [];\n  // Check for a handful of known, common runtime errors and log them (with redaction where applicable).\n  const firstLine = stackArr[0];\n  if (firstLine.startsWith(\"TypeError: Cannot read property\") || firstLine.startsWith(\"TypeError: Cannot read properties of\") || firstLine.startsWith(\"TypeError: Cannot set property\") || firstLine.startsWith(\"TypeError: Cannot set properties of\") || firstLine.endsWith(\"is not a function\")) {\n    // These types of errors are not at risk of leaking PII. They will indicate unavailable APIs\n    res.push(compactStackLine(firstLine));\n  } else if (firstLine.startsWith(\"SyntaxError\") || firstLine.startsWith(\"TypeError\")) {\n    // Prevent unintentional leaking of arbitrary info by redacting contents between both single and double quotes\n    res.push(compactStackLine(\n    // Example: SyntaxError: Unexpected token 'e', \"test\" is not valid JSON -> SyntaxError: Unexpected token <redacted>, <redacted> is not valid JSON\n    firstLine.replace(/['].*[']|[\"].*[\"]/g, \"<redacted>\")));\n  }\n  // Get top N stack lines\n  for (let ix = 1; ix < stackArr.length; ix++) {\n    if (res.length >= stackMaxSize) {\n      break;\n    }\n    const line = stackArr[ix];\n    res.push(compactStackLine(line));\n  }\n  return res;\n}\n/**\r\n * Compacts error stack line by shortening file path\r\n * Example: https://localhost/msal-common/src/authority/Authority.js:100:1 -> Authority.js:100:1\r\n * @param line {string} stack line\r\n * @returns {string}\r\n */\nfunction compactStackLine(line) {\n  const filePathIx = line.lastIndexOf(\" \") + 1;\n  if (filePathIx < 1) {\n    return line;\n  }\n  const filePath = line.substring(filePathIx);\n  let fileNameIx = filePath.lastIndexOf(\"/\");\n  fileNameIx = fileNameIx < 0 ? filePath.lastIndexOf(\"\\\\\") : fileNameIx;\n  if (fileNameIx >= 0) {\n    return (line.substring(0, filePathIx) + \"(\" + filePath.substring(fileNameIx + 1) + (filePath.charAt(filePath.length - 1) === \")\" ? \"\" : \")\")).trimStart();\n  }\n  return line.trimStart();\n}\nclass PerformanceClient {\n  /**\r\n   * Creates an instance of PerformanceClient,\r\n   * an abstract class containing core performance telemetry logic.\r\n   *\r\n   * @constructor\r\n   * @param {string} clientId Client ID of the application\r\n   * @param {string} authority Authority used by the application\r\n   * @param {Logger} logger Logger used by the application\r\n   * @param {string} libraryName Name of the library\r\n   * @param {string} libraryVersion Version of the library\r\n   * @param {ApplicationTelemetry} applicationTelemetry application name and version\r\n   * @param {Set<String>} intFields integer fields to be truncated\r\n   * @param {Map<string, string>} abbreviations event name abbreviations\r\n   */\n  constructor(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry, intFields, abbreviations) {\n    this.authority = authority;\n    this.libraryName = libraryName;\n    this.libraryVersion = libraryVersion;\n    this.applicationTelemetry = applicationTelemetry;\n    this.clientId = clientId;\n    this.logger = logger;\n    this.callbacks = new Map();\n    this.eventsByCorrelationId = new Map();\n    this.eventStack = new Map();\n    this.queueMeasurements = new Map();\n    this.preQueueTimeByCorrelationId = new Map();\n    this.intFields = intFields || new Set();\n    for (const item of IntFields) {\n      this.intFields.add(item);\n    }\n    this.abbreviations = abbreviations || new Map();\n    for (const [key, value] of PerformanceEventAbbreviations) {\n      this.abbreviations.set(key, value);\n    }\n  }\n  /**\r\n   * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n   * Note: this function can be changed to abstract at the next major version bump.\r\n   *\r\n   * @param {string} measureName\r\n   * @param {string} correlationId\r\n   * @returns {IPerformanceMeasurement}\r\n   * @deprecated This method will be removed in the next major version\r\n   */\n  startPerformanceMeasurement(measureName,\n  // eslint-disable-line @typescript-eslint/no-unused-vars\n  correlationId // eslint-disable-line @typescript-eslint/no-unused-vars\n  ) {\n    return {};\n  }\n  /**\r\n   * Gets map of pre-queue times by correlation Id\r\n   *\r\n   * @param {PerformanceEvents} eventName\r\n   * @param {string} correlationId\r\n   * @returns {number}\r\n   */\n  getPreQueueTime(eventName, correlationId) {\n    const preQueueEvent = this.preQueueTimeByCorrelationId.get(correlationId);\n    if (!preQueueEvent) {\n      this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: ${correlationId}, unable to add queue measurement`);\n      return;\n    } else if (preQueueEvent.name !== eventName) {\n      this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue time found for ${eventName}, unable to add queue measurement`);\n      return;\n    }\n    return preQueueEvent.time;\n  }\n  /**\r\n   * Calculates the difference between current time and time when function was queued.\r\n   * Note: It is possible to have 0 as the queue time if the current time and the queued time was the same.\r\n   *\r\n   * @param {number} preQueueTime\r\n   * @param {number} currentTime\r\n   * @returns {number}\r\n   */\n  calculateQueuedTime(preQueueTime, currentTime) {\n    if (preQueueTime < 1) {\n      this.logger.trace(`PerformanceClient: preQueueTime should be a positive integer and not ${preQueueTime}`);\n      return 0;\n    }\n    if (currentTime < 1) {\n      this.logger.trace(`PerformanceClient: currentTime should be a positive integer and not ${currentTime}`);\n      return 0;\n    }\n    if (currentTime < preQueueTime) {\n      this.logger.trace(\"PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved\");\n      return 0;\n    }\n    return currentTime - preQueueTime;\n  }\n  /**\r\n   * Adds queue measurement time to QueueMeasurements array for given correlation ID.\r\n   *\r\n   * @param {PerformanceEvents} eventName\r\n   * @param {?string} correlationId\r\n   * @param {?number} queueTime\r\n   * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\r\n   * @returns\r\n   */\n  addQueueMeasurement(eventName, correlationId, queueTime, manuallyCompleted) {\n    if (!correlationId) {\n      this.logger.trace(`PerformanceClient.addQueueMeasurement: correlationId not provided for ${eventName}, cannot add queue measurement`);\n      return;\n    }\n    if (queueTime === 0) {\n      // Possible for there to be no queue time after calculation\n      this.logger.trace(`PerformanceClient.addQueueMeasurement: queue time provided for ${eventName} is ${queueTime}`);\n    } else if (!queueTime) {\n      this.logger.trace(`PerformanceClient.addQueueMeasurement: no queue time provided for ${eventName}`);\n      return;\n    }\n    const queueMeasurement = {\n      eventName,\n      // Always default queue time to 0 for manually completed (improperly instrumented)\n      queueTime: manuallyCompleted ? 0 : queueTime,\n      manuallyCompleted\n    };\n    // Adds to existing correlation Id if present in queueMeasurements\n    const existingMeasurements = this.queueMeasurements.get(correlationId);\n    if (existingMeasurements) {\n      existingMeasurements.push(queueMeasurement);\n      this.queueMeasurements.set(correlationId, existingMeasurements);\n    } else {\n      // Sets new correlation Id if not present in queueMeasurements\n      this.logger.trace(`PerformanceClient.addQueueMeasurement: adding correlationId ${correlationId} to queue measurements`);\n      const measurementArray = [queueMeasurement];\n      this.queueMeasurements.set(correlationId, measurementArray);\n    }\n    // Delete processed pre-queue event.\n    this.preQueueTimeByCorrelationId.delete(correlationId);\n  }\n  /**\r\n   * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\r\n   *\r\n   * @param {PerformanceEvents} measureName\r\n   * @param {?string} [correlationId]\r\n   * @returns {InProgressPerformanceEvent}\r\n   */\n  startMeasurement(measureName, correlationId) {\n    // Generate a placeholder correlation if the request does not provide one\n    const eventCorrelationId = correlationId || this.generateId();\n    if (!correlationId) {\n      this.logger.info(`PerformanceClient: No correlation id provided for ${measureName}, generating`, eventCorrelationId);\n    }\n    this.logger.trace(`PerformanceClient: Performance measurement started for ${measureName}`, eventCorrelationId);\n    const inProgressEvent = {\n      eventId: this.generateId(),\n      status: PerformanceEventStatus.InProgress,\n      authority: this.authority,\n      libraryName: this.libraryName,\n      libraryVersion: this.libraryVersion,\n      clientId: this.clientId,\n      name: measureName,\n      startTimeMs: Date.now(),\n      correlationId: eventCorrelationId,\n      appName: this.applicationTelemetry?.appName,\n      appVersion: this.applicationTelemetry?.appVersion\n    };\n    // Store in progress events so they can be discarded if not ended properly\n    this.cacheEventByCorrelationId(inProgressEvent);\n    startContext(inProgressEvent, this.abbreviations, this.eventStack.get(eventCorrelationId));\n    // Return the event and functions the caller can use to properly end/flush the measurement\n    return {\n      end: (event, error) => {\n        return this.endMeasurement({\n          // Initial set of event properties\n          ...inProgressEvent,\n          // Properties set when event ends\n          ...event\n        }, error);\n      },\n      discard: () => {\n        return this.discardMeasurements(inProgressEvent.correlationId);\n      },\n      add: fields => {\n        return this.addFields(fields, inProgressEvent.correlationId);\n      },\n      increment: fields => {\n        return this.incrementFields(fields, inProgressEvent.correlationId);\n      },\n      event: inProgressEvent,\n      measurement: new StubPerformanceMeasurement()\n    };\n  }\n  /**\r\n   * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\r\n   * as consumers should instead use the function returned by startMeasurement.\r\n   * Adds a new field named as \"[event name]DurationMs\" for sub-measurements, completes and emits an event\r\n   * otherwise.\r\n   *\r\n   * @param {PerformanceEvent} event\r\n   * @param {unknown} error\r\n   * @returns {(PerformanceEvent | null)}\r\n   */\n  endMeasurement(event, error) {\n    const rootEvent = this.eventsByCorrelationId.get(event.correlationId);\n    if (!rootEvent) {\n      this.logger.trace(`PerformanceClient: Measurement not found for ${event.eventId}`, event.correlationId);\n      return null;\n    }\n    const isRoot = event.eventId === rootEvent.eventId;\n    let queueInfo = {\n      totalQueueTime: 0,\n      totalQueueCount: 0,\n      manuallyCompletedCount: 0\n    };\n    event.durationMs = Math.round(event.durationMs || this.getDurationMs(event.startTimeMs));\n    const context = JSON.stringify(endContext(event, this.abbreviations, this.eventStack.get(rootEvent.correlationId), error));\n    if (isRoot) {\n      queueInfo = this.getQueueInfo(event.correlationId);\n      this.discardMeasurements(rootEvent.correlationId);\n    } else {\n      rootEvent.incompleteSubMeasurements?.delete(event.eventId);\n    }\n    this.logger.trace(`PerformanceClient: Performance measurement ended for ${event.name}: ${event.durationMs} ms`, event.correlationId);\n    if (error) {\n      addError(error, this.logger, rootEvent);\n    }\n    // Add sub-measurement attribute to root event.\n    if (!isRoot) {\n      rootEvent[event.name + \"DurationMs\"] = Math.floor(event.durationMs);\n      return {\n        ...rootEvent\n      };\n    }\n    if (isRoot && !error && (rootEvent.errorCode || rootEvent.subErrorCode)) {\n      this.logger.trace(`PerformanceClient: Remove error and sub-error codes for root event ${event.name} as intermediate error was successfully handled`, event.correlationId);\n      rootEvent.errorCode = undefined;\n      rootEvent.subErrorCode = undefined;\n    }\n    let finalEvent = {\n      ...rootEvent,\n      ...event\n    };\n    let incompleteSubsCount = 0;\n    // Incomplete sub-measurements are discarded. They are likely an instrumentation bug that should be fixed.\n    finalEvent.incompleteSubMeasurements?.forEach(subMeasurement => {\n      this.logger.trace(`PerformanceClient: Incomplete submeasurement ${subMeasurement.name} found for ${event.name}`, finalEvent.correlationId);\n      incompleteSubsCount++;\n    });\n    finalEvent.incompleteSubMeasurements = undefined;\n    finalEvent = {\n      ...finalEvent,\n      queuedTimeMs: queueInfo.totalQueueTime,\n      queuedCount: queueInfo.totalQueueCount,\n      queuedManuallyCompletedCount: queueInfo.manuallyCompletedCount,\n      status: PerformanceEventStatus.Completed,\n      incompleteSubsCount,\n      context\n    };\n    this.truncateIntegralFields(finalEvent);\n    this.emitEvents([finalEvent], event.correlationId);\n    return finalEvent;\n  }\n  /**\r\n   * Saves extra information to be emitted when the measurements are flushed\r\n   * @param fields\r\n   * @param correlationId\r\n   */\n  addFields(fields, correlationId) {\n    this.logger.trace(\"PerformanceClient: Updating static fields\");\n    const event = this.eventsByCorrelationId.get(correlationId);\n    if (event) {\n      this.eventsByCorrelationId.set(correlationId, {\n        ...event,\n        ...fields\n      });\n    } else {\n      this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\n    }\n  }\n  /**\r\n   * Increment counters to be emitted when the measurements are flushed\r\n   * @param fields {string[]}\r\n   * @param correlationId {string} correlation identifier\r\n   */\n  incrementFields(fields, correlationId) {\n    this.logger.trace(\"PerformanceClient: Updating counters\");\n    const event = this.eventsByCorrelationId.get(correlationId);\n    if (event) {\n      for (const counter in fields) {\n        if (!event.hasOwnProperty(counter)) {\n          event[counter] = 0;\n        } else if (isNaN(Number(event[counter]))) {\n          return;\n        }\n        event[counter] += fields[counter];\n      }\n    } else {\n      this.logger.trace(\"PerformanceClient: Event not found for\", correlationId);\n    }\n  }\n  /**\r\n   * Upserts event into event cache.\r\n   * First key is the correlation id, second key is the event id.\r\n   * Allows for events to be grouped by correlation id,\r\n   * and to easily allow for properties on them to be updated.\r\n   *\r\n   * @private\r\n   * @param {PerformanceEvent} event\r\n   */\n  cacheEventByCorrelationId(event) {\n    const rootEvent = this.eventsByCorrelationId.get(event.correlationId);\n    if (rootEvent) {\n      this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} added/updated`, event.correlationId);\n      rootEvent.incompleteSubMeasurements = rootEvent.incompleteSubMeasurements || new Map();\n      rootEvent.incompleteSubMeasurements.set(event.eventId, {\n        name: event.name,\n        startTimeMs: event.startTimeMs\n      });\n    } else {\n      this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} started`, event.correlationId);\n      this.eventsByCorrelationId.set(event.correlationId, {\n        ...event\n      });\n      this.eventStack.set(event.correlationId, []);\n    }\n  }\n  getQueueInfo(correlationId) {\n    const queueMeasurementForCorrelationId = this.queueMeasurements.get(correlationId);\n    if (!queueMeasurementForCorrelationId) {\n      this.logger.trace(`PerformanceClient: no queue measurements found for for correlationId: ${correlationId}`);\n    }\n    let totalQueueTime = 0;\n    let totalQueueCount = 0;\n    let manuallyCompletedCount = 0;\n    queueMeasurementForCorrelationId?.forEach(measurement => {\n      totalQueueTime += measurement.queueTime;\n      totalQueueCount++;\n      manuallyCompletedCount += measurement.manuallyCompleted ? 1 : 0;\n    });\n    return {\n      totalQueueTime,\n      totalQueueCount,\n      manuallyCompletedCount\n    };\n  }\n  /**\r\n   * Removes measurements and aux data for a given correlation id.\r\n   *\r\n   * @param {string} correlationId\r\n   */\n  discardMeasurements(correlationId) {\n    this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\n    this.eventsByCorrelationId.delete(correlationId);\n    this.logger.trace(\"PerformanceClient: QueueMeasurements discarded\", correlationId);\n    this.queueMeasurements.delete(correlationId);\n    this.logger.trace(\"PerformanceClient: Pre-queue times discarded\", correlationId);\n    this.preQueueTimeByCorrelationId.delete(correlationId);\n    this.logger.trace(\"PerformanceClient: Event stack discarded\", correlationId);\n    this.eventStack.delete(correlationId);\n  }\n  /**\r\n   * Registers a callback function to receive performance events.\r\n   *\r\n   * @param {PerformanceCallbackFunction} callback\r\n   * @returns {string}\r\n   */\n  addPerformanceCallback(callback) {\n    for (const [id, cb] of this.callbacks) {\n      if (cb.toString() === callback.toString()) {\n        this.logger.warning(`PerformanceClient: Performance callback is already registered with id: ${id}`);\n        return id;\n      }\n    }\n    const callbackId = this.generateId();\n    this.callbacks.set(callbackId, callback);\n    this.logger.verbose(`PerformanceClient: Performance callback registered with id: ${callbackId}`);\n    return callbackId;\n  }\n  /**\r\n   * Removes a callback registered with addPerformanceCallback.\r\n   *\r\n   * @param {string} callbackId\r\n   * @returns {boolean}\r\n   */\n  removePerformanceCallback(callbackId) {\n    const result = this.callbacks.delete(callbackId);\n    if (result) {\n      this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} removed.`);\n    } else {\n      this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} not removed.`);\n    }\n    return result;\n  }\n  /**\r\n   * Emits events to all registered callbacks.\r\n   *\r\n   * @param {PerformanceEvent[]} events\r\n   * @param {?string} [correlationId]\r\n   */\n  emitEvents(events, correlationId) {\n    this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\n    this.callbacks.forEach((callback, callbackId) => {\n      this.logger.trace(`PerformanceClient: Emitting event to callback ${callbackId}`, correlationId);\n      callback.apply(null, [events]);\n    });\n  }\n  /**\r\n   * Enforce truncation of integral fields in performance event.\r\n   * @param {PerformanceEvent} event performance event to update.\r\n   */\n  truncateIntegralFields(event) {\n    this.intFields.forEach(key => {\n      if (key in event && typeof event[key] === \"number\") {\n        event[key] = Math.floor(event[key]);\n      }\n    });\n  }\n  /**\r\n   * Returns event duration in milliseconds\r\n   * @param startTimeMs {number}\r\n   * @returns {number}\r\n   */\n  getDurationMs(startTimeMs) {\n    const durationMs = Date.now() - startTimeMs;\n    // Handle clock skew\n    return durationMs < 0 ? durationMs : 0;\n  }\n}\nexport { PerformanceClient, addError, compactStack, compactStackLine, endContext, startContext };","map":{"version":3,"names":["startContext","event","abbreviations","stack","push","name","get","endContext","error","length","peek","undefined","abbrEventName","top","current","pop","errorCode","AuthError","Error","subErr","subError","childErr","err","context","dur","durationMs","success","fail","parent","childName","siblings","Object","keys","filter","key","startsWith","addError","logger","stackMaxSize","trace","correlationId","subErrorCode","ServerError","InteractionRequiredAuthError","serverErrorNo","errorNo","CacheError","errorStack","compactStack","errorName","stackArr","split","res","firstLine","endsWith","compactStackLine","replace","ix","line","filePathIx","lastIndexOf","filePath","substring","fileNameIx","charAt","trimStart","PerformanceClient","constructor","clientId","authority","libraryName","libraryVersion","applicationTelemetry","intFields","callbacks","Map","eventsByCorrelationId","eventStack","queueMeasurements","preQueueTimeByCorrelationId","Set","item","IntFields","add","value","PerformanceEventAbbreviations","set","startPerformanceMeasurement","measureName","getPreQueueTime","eventName","preQueueEvent","time","calculateQueuedTime","preQueueTime","currentTime","addQueueMeasurement","queueTime","manuallyCompleted","queueMeasurement","existingMeasurements","measurementArray","delete","startMeasurement","eventCorrelationId","generateId","info","inProgressEvent","eventId","status","PerformanceEventStatus","InProgress","startTimeMs","Date","now","appName","appVersion","cacheEventByCorrelationId","end","endMeasurement","discard","discardMeasurements","fields","addFields","increment","incrementFields","measurement","StubPerformanceMeasurement","rootEvent","isRoot","queueInfo","totalQueueTime","totalQueueCount","manuallyCompletedCount","Math","round","getDurationMs","JSON","stringify","getQueueInfo","incompleteSubMeasurements","floor","finalEvent","incompleteSubsCount","forEach","subMeasurement","queuedTimeMs","queuedCount","queuedManuallyCompletedCount","Completed","truncateIntegralFields","emitEvents","counter","hasOwnProperty","isNaN","Number","queueMeasurementForCorrelationId","addPerformanceCallback","callback","id","cb","toString","warning","callbackId","verbose","removePerformanceCallback","result","events","apply"],"sources":["C:\\bytepantry\\frontend\\node_modules\\@azure\\msal-common\\src\\telemetry\\performance\\PerformanceClient.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ApplicationTelemetry } from \"../../config/ClientConfiguration.js\";\r\nimport { Logger } from \"../../logger/Logger.js\";\r\nimport {\r\n    InProgressPerformanceEvent,\r\n    IPerformanceClient,\r\n    PerformanceCallbackFunction,\r\n    QueueMeasurement,\r\n} from \"./IPerformanceClient.js\";\r\nimport {\r\n    IntFields,\r\n    PerformanceEvent,\r\n    PerformanceEventAbbreviations,\r\n    PerformanceEventContext,\r\n    PerformanceEvents,\r\n    PerformanceEventStackedContext,\r\n    PerformanceEventStatus,\r\n} from \"./PerformanceEvent.js\";\r\nimport { IPerformanceMeasurement } from \"./IPerformanceMeasurement.js\";\r\nimport { StubPerformanceMeasurement } from \"./StubPerformanceClient.js\";\r\nimport { AuthError } from \"../../error/AuthError.js\";\r\nimport { CacheError } from \"../../error/CacheError.js\";\r\nimport { ServerError } from \"../../error/ServerError.js\";\r\nimport { InteractionRequiredAuthError } from \"../../error/InteractionRequiredAuthError.js\";\r\n\r\nexport interface PreQueueEvent {\r\n    name: PerformanceEvents;\r\n    time: number;\r\n}\r\n\r\n/**\r\n * Starts context by adding payload to the stack\r\n * @param event {PerformanceEvent}\r\n * @param abbreviations {Map<string, string>} event name abbreviations\r\n * @param stack {?PerformanceEventStackedContext[]} stack\r\n */\r\nexport function startContext(\r\n    event: PerformanceEvent,\r\n    abbreviations: Map<string, string>,\r\n    stack?: PerformanceEventStackedContext[]\r\n): void {\r\n    if (!stack) {\r\n        return;\r\n    }\r\n\r\n    stack.push({\r\n        name: abbreviations.get(event.name) || event.name,\r\n    });\r\n}\r\n\r\n/**\r\n * Ends context by removing payload from the stack and returning parent or self, if stack is empty, payload\r\n *\r\n * @param event {PerformanceEvent}\r\n * @param abbreviations {Map<string, string>} event name abbreviations\r\n * @param stack {?PerformanceEventStackedContext[]} stack\r\n * @param error {?unknown} error\r\n */\r\nexport function endContext(\r\n    event: PerformanceEvent,\r\n    abbreviations: Map<string, string>,\r\n    stack?: PerformanceEventStackedContext[],\r\n    error?: unknown\r\n): PerformanceEventContext | undefined {\r\n    if (!stack?.length) {\r\n        return;\r\n    }\r\n\r\n    const peek = (stack: PerformanceEventStackedContext[]) => {\r\n        return stack.length ? stack[stack.length - 1] : undefined;\r\n    };\r\n\r\n    const abbrEventName = abbreviations.get(event.name) || event.name;\r\n    const top = peek(stack);\r\n    if (top?.name !== abbrEventName) {\r\n        return;\r\n    }\r\n\r\n    const current = stack?.pop();\r\n    if (!current) {\r\n        return;\r\n    }\r\n\r\n    const errorCode =\r\n        error instanceof AuthError\r\n            ? error.errorCode\r\n            : error instanceof Error\r\n            ? error.name\r\n            : undefined;\r\n    const subErr = error instanceof AuthError ? error.subError : undefined;\r\n\r\n    if (errorCode && current.childErr !== errorCode) {\r\n        current.err = errorCode;\r\n        if (subErr) {\r\n            current.subErr = subErr;\r\n        }\r\n    }\r\n\r\n    delete current.name;\r\n    delete current.childErr;\r\n\r\n    const context: PerformanceEventContext = {\r\n        ...current,\r\n        dur: event.durationMs,\r\n    };\r\n\r\n    if (!event.success) {\r\n        context.fail = 1;\r\n    }\r\n\r\n    const parent = peek(stack);\r\n    if (!parent) {\r\n        return { [abbrEventName]: context };\r\n    }\r\n\r\n    if (errorCode) {\r\n        parent.childErr = errorCode;\r\n    }\r\n\r\n    let childName: string;\r\n    if (!parent[abbrEventName]) {\r\n        childName = abbrEventName;\r\n    } else {\r\n        const siblings = Object.keys(parent).filter((key) =>\r\n            key.startsWith(abbrEventName)\r\n        ).length;\r\n        childName = `${abbrEventName}_${siblings + 1}`;\r\n    }\r\n    parent[childName] = context;\r\n    return parent;\r\n}\r\n\r\n/**\r\n * Adds error name and stack trace to the telemetry event\r\n * @param error {Error}\r\n * @param logger {Logger}\r\n * @param event {PerformanceEvent}\r\n * @param stackMaxSize {number} max error stack size to capture\r\n */\r\nexport function addError(\r\n    error: unknown,\r\n    logger: Logger,\r\n    event: PerformanceEvent,\r\n    stackMaxSize: number = 5\r\n): void {\r\n    if (!(error instanceof Error)) {\r\n        logger.trace(\r\n            \"PerformanceClient.addErrorStack: Input error is not instance of Error\",\r\n            event.correlationId\r\n        );\r\n        return;\r\n    } else if (error instanceof AuthError) {\r\n        event.errorCode = error.errorCode;\r\n        event.subErrorCode = error.subError;\r\n        if (\r\n            error instanceof ServerError ||\r\n            error instanceof InteractionRequiredAuthError\r\n        ) {\r\n            event.serverErrorNo = error.errorNo;\r\n        }\r\n        return;\r\n    } else if (error instanceof CacheError) {\r\n        event.errorCode = error.errorCode;\r\n        return;\r\n    } else if (event.errorStack?.length) {\r\n        logger.trace(\r\n            \"PerformanceClient.addErrorStack: Stack already exist\",\r\n            event.correlationId\r\n        );\r\n        return;\r\n    } else if (!error.stack?.length) {\r\n        logger.trace(\r\n            \"PerformanceClient.addErrorStack: Input stack is empty\",\r\n            event.correlationId\r\n        );\r\n        return;\r\n    }\r\n\r\n    if (error.stack) {\r\n        event.errorStack = compactStack(error.stack, stackMaxSize);\r\n    }\r\n    event.errorName = error.name;\r\n}\r\n\r\n/**\r\n * Compacts error stack into array by fetching N first entries\r\n * @param stack {string} error stack\r\n * @param stackMaxSize {number} max error stack size to capture\r\n * @returns {string[]}\r\n */\r\nexport function compactStack(stack: string, stackMaxSize: number): string[] {\r\n    if (stackMaxSize < 0) {\r\n        return [];\r\n    }\r\n\r\n    const stackArr = stack.split(\"\\n\") || [];\r\n\r\n    const res = [];\r\n\r\n    // Check for a handful of known, common runtime errors and log them (with redaction where applicable).\r\n    const firstLine = stackArr[0];\r\n    if (\r\n        firstLine.startsWith(\"TypeError: Cannot read property\") ||\r\n        firstLine.startsWith(\"TypeError: Cannot read properties of\") ||\r\n        firstLine.startsWith(\"TypeError: Cannot set property\") ||\r\n        firstLine.startsWith(\"TypeError: Cannot set properties of\") ||\r\n        firstLine.endsWith(\"is not a function\")\r\n    ) {\r\n        // These types of errors are not at risk of leaking PII. They will indicate unavailable APIs\r\n        res.push(compactStackLine(firstLine));\r\n    } else if (\r\n        firstLine.startsWith(\"SyntaxError\") ||\r\n        firstLine.startsWith(\"TypeError\")\r\n    ) {\r\n        // Prevent unintentional leaking of arbitrary info by redacting contents between both single and double quotes\r\n        res.push(\r\n            compactStackLine(\r\n                // Example: SyntaxError: Unexpected token 'e', \"test\" is not valid JSON -> SyntaxError: Unexpected token <redacted>, <redacted> is not valid JSON\r\n                firstLine.replace(/['].*[']|[\"].*[\"]/g, \"<redacted>\")\r\n            )\r\n        );\r\n    }\r\n\r\n    // Get top N stack lines\r\n    for (let ix = 1; ix < stackArr.length; ix++) {\r\n        if (res.length >= stackMaxSize) {\r\n            break;\r\n        }\r\n        const line = stackArr[ix];\r\n        res.push(compactStackLine(line));\r\n    }\r\n    return res;\r\n}\r\n\r\n/**\r\n * Compacts error stack line by shortening file path\r\n * Example: https://localhost/msal-common/src/authority/Authority.js:100:1 -> Authority.js:100:1\r\n * @param line {string} stack line\r\n * @returns {string}\r\n */\r\nexport function compactStackLine(line: string): string {\r\n    const filePathIx = line.lastIndexOf(\" \") + 1;\r\n    if (filePathIx < 1) {\r\n        return line;\r\n    }\r\n    const filePath = line.substring(filePathIx);\r\n\r\n    let fileNameIx = filePath.lastIndexOf(\"/\");\r\n    fileNameIx = fileNameIx < 0 ? filePath.lastIndexOf(\"\\\\\") : fileNameIx;\r\n\r\n    if (fileNameIx >= 0) {\r\n        return (\r\n            line.substring(0, filePathIx) +\r\n            \"(\" +\r\n            filePath.substring(fileNameIx + 1) +\r\n            (filePath.charAt(filePath.length - 1) === \")\" ? \"\" : \")\")\r\n        ).trimStart();\r\n    }\r\n\r\n    return line.trimStart();\r\n}\r\n\r\nexport abstract class PerformanceClient implements IPerformanceClient {\r\n    protected authority: string;\r\n    protected libraryName: string;\r\n    protected libraryVersion: string;\r\n    protected applicationTelemetry: ApplicationTelemetry;\r\n    protected clientId: string;\r\n    protected logger: Logger;\r\n    protected callbacks: Map<string, PerformanceCallbackFunction>;\r\n\r\n    /**\r\n     * Multiple events with the same correlation id.\r\n     * @protected\r\n     * @type {Map<string, PerformanceEvent>}\r\n     */\r\n    protected eventsByCorrelationId: Map<string, PerformanceEvent>;\r\n\r\n    /**\r\n     * Map of pre-queue times by correlation Id\r\n     *\r\n     * @protected\r\n     * @type {Map<string, PreQueueEvent>}\r\n     */\r\n    protected preQueueTimeByCorrelationId: Map<string, PreQueueEvent>;\r\n\r\n    /**\r\n     * Map of queue measurements by correlation Id\r\n     *\r\n     * @protected\r\n     * @type {Map<string, Array<QueueMeasurement>>}\r\n     */\r\n    protected queueMeasurements: Map<string, Array<QueueMeasurement>>;\r\n\r\n    protected intFields: Set<string>;\r\n\r\n    /**\r\n     * Map of stacked events by correlation id.\r\n     *\r\n     * @protected\r\n     */\r\n    protected eventStack: Map<string, PerformanceEventStackedContext[]>;\r\n\r\n    /**\r\n     * Event name abbreviations\r\n     *\r\n     * @protected\r\n     */\r\n    protected abbreviations: Map<string, string>;\r\n\r\n    /**\r\n     * Creates an instance of PerformanceClient,\r\n     * an abstract class containing core performance telemetry logic.\r\n     *\r\n     * @constructor\r\n     * @param {string} clientId Client ID of the application\r\n     * @param {string} authority Authority used by the application\r\n     * @param {Logger} logger Logger used by the application\r\n     * @param {string} libraryName Name of the library\r\n     * @param {string} libraryVersion Version of the library\r\n     * @param {ApplicationTelemetry} applicationTelemetry application name and version\r\n     * @param {Set<String>} intFields integer fields to be truncated\r\n     * @param {Map<string, string>} abbreviations event name abbreviations\r\n     */\r\n    constructor(\r\n        clientId: string,\r\n        authority: string,\r\n        logger: Logger,\r\n        libraryName: string,\r\n        libraryVersion: string,\r\n        applicationTelemetry: ApplicationTelemetry,\r\n        intFields?: Set<string>,\r\n        abbreviations?: Map<string, string>\r\n    ) {\r\n        this.authority = authority;\r\n        this.libraryName = libraryName;\r\n        this.libraryVersion = libraryVersion;\r\n        this.applicationTelemetry = applicationTelemetry;\r\n        this.clientId = clientId;\r\n        this.logger = logger;\r\n        this.callbacks = new Map();\r\n        this.eventsByCorrelationId = new Map();\r\n        this.eventStack = new Map();\r\n        this.queueMeasurements = new Map();\r\n        this.preQueueTimeByCorrelationId = new Map();\r\n        this.intFields = intFields || new Set();\r\n        for (const item of IntFields) {\r\n            this.intFields.add(item);\r\n        }\r\n        this.abbreviations = abbreviations || new Map();\r\n        for (const [key, value] of PerformanceEventAbbreviations) {\r\n            this.abbreviations.set(key, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates and returns a unique id, typically a guid.\r\n     *\r\n     * @abstract\r\n     * @returns {string}\r\n     */\r\n    abstract generateId(): string;\r\n\r\n    /**\r\n     * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n     * Note: this function can be changed to abstract at the next major version bump.\r\n     *\r\n     * @param {string} measureName\r\n     * @param {string} correlationId\r\n     * @returns {IPerformanceMeasurement}\r\n     * @deprecated This method will be removed in the next major version\r\n     */\r\n    startPerformanceMeasurement(\r\n        measureName: string, // eslint-disable-line @typescript-eslint/no-unused-vars\r\n        correlationId: string // eslint-disable-line @typescript-eslint/no-unused-vars\r\n    ): IPerformanceMeasurement {\r\n        return {} as IPerformanceMeasurement;\r\n    }\r\n\r\n    /**\r\n     * Sets pre-queue time by correlation Id\r\n     *\r\n     * @abstract\r\n     * @param {PerformanceEvents} eventName\r\n     * @param {string} correlationId\r\n     * @returns\r\n     */\r\n    abstract setPreQueueTime(\r\n        eventName: PerformanceEvents,\r\n        correlationId?: string\r\n    ): void;\r\n\r\n    /**\r\n     * Gets map of pre-queue times by correlation Id\r\n     *\r\n     * @param {PerformanceEvents} eventName\r\n     * @param {string} correlationId\r\n     * @returns {number}\r\n     */\r\n    getPreQueueTime(eventName: string, correlationId: string): number | void {\r\n        const preQueueEvent: PreQueueEvent | undefined =\r\n            this.preQueueTimeByCorrelationId.get(correlationId);\r\n\r\n        if (!preQueueEvent) {\r\n            this.logger.trace(\r\n                `PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: ${correlationId}, unable to add queue measurement`\r\n            );\r\n            return;\r\n        } else if (preQueueEvent.name !== eventName) {\r\n            this.logger.trace(\r\n                `PerformanceClient.getPreQueueTime: no pre-queue time found for ${eventName}, unable to add queue measurement`\r\n            );\r\n            return;\r\n        }\r\n\r\n        return preQueueEvent.time;\r\n    }\r\n\r\n    /**\r\n     * Calculates the difference between current time and time when function was queued.\r\n     * Note: It is possible to have 0 as the queue time if the current time and the queued time was the same.\r\n     *\r\n     * @param {number} preQueueTime\r\n     * @param {number} currentTime\r\n     * @returns {number}\r\n     */\r\n    calculateQueuedTime(preQueueTime: number, currentTime: number): number {\r\n        if (preQueueTime < 1) {\r\n            this.logger.trace(\r\n                `PerformanceClient: preQueueTime should be a positive integer and not ${preQueueTime}`\r\n            );\r\n            return 0;\r\n        }\r\n\r\n        if (currentTime < 1) {\r\n            this.logger.trace(\r\n                `PerformanceClient: currentTime should be a positive integer and not ${currentTime}`\r\n            );\r\n            return 0;\r\n        }\r\n\r\n        if (currentTime < preQueueTime) {\r\n            this.logger.trace(\r\n                \"PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved\"\r\n            );\r\n            return 0;\r\n        }\r\n\r\n        return currentTime - preQueueTime;\r\n    }\r\n\r\n    /**\r\n     * Adds queue measurement time to QueueMeasurements array for given correlation ID.\r\n     *\r\n     * @param {PerformanceEvents} eventName\r\n     * @param {?string} correlationId\r\n     * @param {?number} queueTime\r\n     * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\r\n     * @returns\r\n     */\r\n    addQueueMeasurement(\r\n        eventName: string,\r\n        correlationId?: string,\r\n        queueTime?: number,\r\n        manuallyCompleted?: boolean\r\n    ): void {\r\n        if (!correlationId) {\r\n            this.logger.trace(\r\n                `PerformanceClient.addQueueMeasurement: correlationId not provided for ${eventName}, cannot add queue measurement`\r\n            );\r\n            return;\r\n        }\r\n\r\n        if (queueTime === 0) {\r\n            // Possible for there to be no queue time after calculation\r\n            this.logger.trace(\r\n                `PerformanceClient.addQueueMeasurement: queue time provided for ${eventName} is ${queueTime}`\r\n            );\r\n        } else if (!queueTime) {\r\n            this.logger.trace(\r\n                `PerformanceClient.addQueueMeasurement: no queue time provided for ${eventName}`\r\n            );\r\n            return;\r\n        }\r\n\r\n        const queueMeasurement: QueueMeasurement = {\r\n            eventName,\r\n            // Always default queue time to 0 for manually completed (improperly instrumented)\r\n            queueTime: manuallyCompleted ? 0 : queueTime,\r\n            manuallyCompleted,\r\n        };\r\n\r\n        // Adds to existing correlation Id if present in queueMeasurements\r\n        const existingMeasurements = this.queueMeasurements.get(correlationId);\r\n        if (existingMeasurements) {\r\n            existingMeasurements.push(queueMeasurement);\r\n            this.queueMeasurements.set(correlationId, existingMeasurements);\r\n        } else {\r\n            // Sets new correlation Id if not present in queueMeasurements\r\n            this.logger.trace(\r\n                `PerformanceClient.addQueueMeasurement: adding correlationId ${correlationId} to queue measurements`\r\n            );\r\n            const measurementArray = [queueMeasurement];\r\n            this.queueMeasurements.set(correlationId, measurementArray);\r\n        }\r\n        // Delete processed pre-queue event.\r\n        this.preQueueTimeByCorrelationId.delete(correlationId);\r\n    }\r\n\r\n    /**\r\n     * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\r\n     *\r\n     * @param {PerformanceEvents} measureName\r\n     * @param {?string} [correlationId]\r\n     * @returns {InProgressPerformanceEvent}\r\n     */\r\n    startMeasurement(\r\n        measureName: string,\r\n        correlationId?: string\r\n    ): InProgressPerformanceEvent {\r\n        // Generate a placeholder correlation if the request does not provide one\r\n        const eventCorrelationId = correlationId || this.generateId();\r\n        if (!correlationId) {\r\n            this.logger.info(\r\n                `PerformanceClient: No correlation id provided for ${measureName}, generating`,\r\n                eventCorrelationId\r\n            );\r\n        }\r\n\r\n        this.logger.trace(\r\n            `PerformanceClient: Performance measurement started for ${measureName}`,\r\n            eventCorrelationId\r\n        );\r\n\r\n        const inProgressEvent: PerformanceEvent = {\r\n            eventId: this.generateId(),\r\n            status: PerformanceEventStatus.InProgress,\r\n            authority: this.authority,\r\n            libraryName: this.libraryName,\r\n            libraryVersion: this.libraryVersion,\r\n            clientId: this.clientId,\r\n            name: measureName,\r\n            startTimeMs: Date.now(),\r\n            correlationId: eventCorrelationId,\r\n            appName: this.applicationTelemetry?.appName,\r\n            appVersion: this.applicationTelemetry?.appVersion,\r\n        };\r\n\r\n        // Store in progress events so they can be discarded if not ended properly\r\n        this.cacheEventByCorrelationId(inProgressEvent);\r\n        startContext(\r\n            inProgressEvent,\r\n            this.abbreviations,\r\n            this.eventStack.get(eventCorrelationId)\r\n        );\r\n\r\n        // Return the event and functions the caller can use to properly end/flush the measurement\r\n        return {\r\n            end: (\r\n                event?: Partial<PerformanceEvent>,\r\n                error?: unknown\r\n            ): PerformanceEvent | null => {\r\n                return this.endMeasurement(\r\n                    {\r\n                        // Initial set of event properties\r\n                        ...inProgressEvent,\r\n                        // Properties set when event ends\r\n                        ...event,\r\n                    },\r\n                    error\r\n                );\r\n            },\r\n            discard: () => {\r\n                return this.discardMeasurements(inProgressEvent.correlationId);\r\n            },\r\n            add: (fields: { [key: string]: {} | undefined }) => {\r\n                return this.addFields(fields, inProgressEvent.correlationId);\r\n            },\r\n            increment: (fields: { [key: string]: number | undefined }) => {\r\n                return this.incrementFields(\r\n                    fields,\r\n                    inProgressEvent.correlationId\r\n                );\r\n            },\r\n            event: inProgressEvent,\r\n            measurement: new StubPerformanceMeasurement(),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\r\n     * as consumers should instead use the function returned by startMeasurement.\r\n     * Adds a new field named as \"[event name]DurationMs\" for sub-measurements, completes and emits an event\r\n     * otherwise.\r\n     *\r\n     * @param {PerformanceEvent} event\r\n     * @param {unknown} error\r\n     * @returns {(PerformanceEvent | null)}\r\n     */\r\n    endMeasurement(\r\n        event: PerformanceEvent,\r\n        error?: unknown\r\n    ): PerformanceEvent | null {\r\n        const rootEvent: PerformanceEvent | undefined =\r\n            this.eventsByCorrelationId.get(event.correlationId);\r\n        if (!rootEvent) {\r\n            this.logger.trace(\r\n                `PerformanceClient: Measurement not found for ${event.eventId}`,\r\n                event.correlationId\r\n            );\r\n            return null;\r\n        }\r\n\r\n        const isRoot = event.eventId === rootEvent.eventId;\r\n        let queueInfo = {\r\n            totalQueueTime: 0,\r\n            totalQueueCount: 0,\r\n            manuallyCompletedCount: 0,\r\n        };\r\n\r\n        event.durationMs = Math.round(\r\n            event.durationMs || this.getDurationMs(event.startTimeMs)\r\n        );\r\n\r\n        const context = JSON.stringify(\r\n            endContext(\r\n                event,\r\n                this.abbreviations,\r\n                this.eventStack.get(rootEvent.correlationId),\r\n                error\r\n            )\r\n        );\r\n\r\n        if (isRoot) {\r\n            queueInfo = this.getQueueInfo(event.correlationId);\r\n            this.discardMeasurements(rootEvent.correlationId);\r\n        } else {\r\n            rootEvent.incompleteSubMeasurements?.delete(event.eventId);\r\n        }\r\n\r\n        this.logger.trace(\r\n            `PerformanceClient: Performance measurement ended for ${event.name}: ${event.durationMs} ms`,\r\n            event.correlationId\r\n        );\r\n\r\n        if (error) {\r\n            addError(error, this.logger, rootEvent);\r\n        }\r\n\r\n        // Add sub-measurement attribute to root event.\r\n        if (!isRoot) {\r\n            rootEvent[event.name + \"DurationMs\"] = Math.floor(event.durationMs);\r\n            return { ...rootEvent };\r\n        }\r\n\r\n        if (\r\n            isRoot &&\r\n            !error &&\r\n            (rootEvent.errorCode || rootEvent.subErrorCode)\r\n        ) {\r\n            this.logger.trace(\r\n                `PerformanceClient: Remove error and sub-error codes for root event ${event.name} as intermediate error was successfully handled`,\r\n                event.correlationId\r\n            );\r\n            rootEvent.errorCode = undefined;\r\n            rootEvent.subErrorCode = undefined;\r\n        }\r\n\r\n        let finalEvent: PerformanceEvent = { ...rootEvent, ...event };\r\n        let incompleteSubsCount: number = 0;\r\n        // Incomplete sub-measurements are discarded. They are likely an instrumentation bug that should be fixed.\r\n        finalEvent.incompleteSubMeasurements?.forEach((subMeasurement) => {\r\n            this.logger.trace(\r\n                `PerformanceClient: Incomplete submeasurement ${subMeasurement.name} found for ${event.name}`,\r\n                finalEvent.correlationId\r\n            );\r\n            incompleteSubsCount++;\r\n        });\r\n        finalEvent.incompleteSubMeasurements = undefined;\r\n\r\n        finalEvent = {\r\n            ...finalEvent,\r\n            queuedTimeMs: queueInfo.totalQueueTime,\r\n            queuedCount: queueInfo.totalQueueCount,\r\n            queuedManuallyCompletedCount: queueInfo.manuallyCompletedCount,\r\n            status: PerformanceEventStatus.Completed,\r\n            incompleteSubsCount,\r\n            context,\r\n        };\r\n        this.truncateIntegralFields(finalEvent);\r\n        this.emitEvents([finalEvent], event.correlationId);\r\n\r\n        return finalEvent;\r\n    }\r\n\r\n    /**\r\n     * Saves extra information to be emitted when the measurements are flushed\r\n     * @param fields\r\n     * @param correlationId\r\n     */\r\n    addFields(\r\n        fields: { [key: string]: {} | undefined },\r\n        correlationId: string\r\n    ): void {\r\n        this.logger.trace(\"PerformanceClient: Updating static fields\");\r\n        const event = this.eventsByCorrelationId.get(correlationId);\r\n        if (event) {\r\n            this.eventsByCorrelationId.set(correlationId, {\r\n                ...event,\r\n                ...fields,\r\n            });\r\n        } else {\r\n            this.logger.trace(\r\n                \"PerformanceClient: Event not found for\",\r\n                correlationId\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Increment counters to be emitted when the measurements are flushed\r\n     * @param fields {string[]}\r\n     * @param correlationId {string} correlation identifier\r\n     */\r\n    incrementFields(\r\n        fields: { [key: string]: number | undefined },\r\n        correlationId: string\r\n    ): void {\r\n        this.logger.trace(\"PerformanceClient: Updating counters\");\r\n        const event = this.eventsByCorrelationId.get(correlationId);\r\n        if (event) {\r\n            for (const counter in fields) {\r\n                if (!event.hasOwnProperty(counter)) {\r\n                    event[counter] = 0;\r\n                } else if (isNaN(Number(event[counter]))) {\r\n                    return;\r\n                }\r\n                event[counter] += fields[counter];\r\n            }\r\n        } else {\r\n            this.logger.trace(\r\n                \"PerformanceClient: Event not found for\",\r\n                correlationId\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Upserts event into event cache.\r\n     * First key is the correlation id, second key is the event id.\r\n     * Allows for events to be grouped by correlation id,\r\n     * and to easily allow for properties on them to be updated.\r\n     *\r\n     * @private\r\n     * @param {PerformanceEvent} event\r\n     */\r\n    protected cacheEventByCorrelationId(event: PerformanceEvent): void {\r\n        const rootEvent = this.eventsByCorrelationId.get(event.correlationId);\r\n        if (rootEvent) {\r\n            this.logger.trace(\r\n                `PerformanceClient: Performance measurement for ${event.name} added/updated`,\r\n                event.correlationId\r\n            );\r\n            rootEvent.incompleteSubMeasurements =\r\n                rootEvent.incompleteSubMeasurements || new Map();\r\n            rootEvent.incompleteSubMeasurements.set(event.eventId, {\r\n                name: event.name,\r\n                startTimeMs: event.startTimeMs,\r\n            });\r\n        } else {\r\n            this.logger.trace(\r\n                `PerformanceClient: Performance measurement for ${event.name} started`,\r\n                event.correlationId\r\n            );\r\n            this.eventsByCorrelationId.set(event.correlationId, { ...event });\r\n            this.eventStack.set(event.correlationId, []);\r\n        }\r\n    }\r\n\r\n    private getQueueInfo(correlationId: string): {\r\n        totalQueueTime: number;\r\n        totalQueueCount: number;\r\n        manuallyCompletedCount: number;\r\n    } {\r\n        const queueMeasurementForCorrelationId =\r\n            this.queueMeasurements.get(correlationId);\r\n        if (!queueMeasurementForCorrelationId) {\r\n            this.logger.trace(\r\n                `PerformanceClient: no queue measurements found for for correlationId: ${correlationId}`\r\n            );\r\n        }\r\n\r\n        let totalQueueTime = 0;\r\n        let totalQueueCount = 0;\r\n        let manuallyCompletedCount = 0;\r\n        queueMeasurementForCorrelationId?.forEach((measurement) => {\r\n            totalQueueTime += measurement.queueTime;\r\n            totalQueueCount++;\r\n            manuallyCompletedCount += measurement.manuallyCompleted ? 1 : 0;\r\n        });\r\n\r\n        return {\r\n            totalQueueTime,\r\n            totalQueueCount,\r\n            manuallyCompletedCount,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Removes measurements and aux data for a given correlation id.\r\n     *\r\n     * @param {string} correlationId\r\n     */\r\n    discardMeasurements(correlationId: string): void {\r\n        this.logger.trace(\r\n            \"PerformanceClient: Performance measurements discarded\",\r\n            correlationId\r\n        );\r\n        this.eventsByCorrelationId.delete(correlationId);\r\n\r\n        this.logger.trace(\r\n            \"PerformanceClient: QueueMeasurements discarded\",\r\n            correlationId\r\n        );\r\n        this.queueMeasurements.delete(correlationId);\r\n\r\n        this.logger.trace(\r\n            \"PerformanceClient: Pre-queue times discarded\",\r\n            correlationId\r\n        );\r\n        this.preQueueTimeByCorrelationId.delete(correlationId);\r\n\r\n        this.logger.trace(\r\n            \"PerformanceClient: Event stack discarded\",\r\n            correlationId\r\n        );\r\n        this.eventStack.delete(correlationId);\r\n    }\r\n\r\n    /**\r\n     * Registers a callback function to receive performance events.\r\n     *\r\n     * @param {PerformanceCallbackFunction} callback\r\n     * @returns {string}\r\n     */\r\n    addPerformanceCallback(callback: PerformanceCallbackFunction): string {\r\n        for (const [id, cb] of this.callbacks) {\r\n            if (cb.toString() === callback.toString()) {\r\n                this.logger.warning(\r\n                    `PerformanceClient: Performance callback is already registered with id: ${id}`\r\n                );\r\n                return id;\r\n            }\r\n        }\r\n\r\n        const callbackId = this.generateId();\r\n        this.callbacks.set(callbackId, callback);\r\n        this.logger.verbose(\r\n            `PerformanceClient: Performance callback registered with id: ${callbackId}`\r\n        );\r\n\r\n        return callbackId;\r\n    }\r\n\r\n    /**\r\n     * Removes a callback registered with addPerformanceCallback.\r\n     *\r\n     * @param {string} callbackId\r\n     * @returns {boolean}\r\n     */\r\n    removePerformanceCallback(callbackId: string): boolean {\r\n        const result = this.callbacks.delete(callbackId);\r\n\r\n        if (result) {\r\n            this.logger.verbose(\r\n                `PerformanceClient: Performance callback ${callbackId} removed.`\r\n            );\r\n        } else {\r\n            this.logger.verbose(\r\n                `PerformanceClient: Performance callback ${callbackId} not removed.`\r\n            );\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Emits events to all registered callbacks.\r\n     *\r\n     * @param {PerformanceEvent[]} events\r\n     * @param {?string} [correlationId]\r\n     */\r\n    emitEvents(events: PerformanceEvent[], correlationId: string): void {\r\n        this.logger.verbose(\r\n            \"PerformanceClient: Emitting performance events\",\r\n            correlationId\r\n        );\r\n\r\n        this.callbacks.forEach(\r\n            (callback: PerformanceCallbackFunction, callbackId: string) => {\r\n                this.logger.trace(\r\n                    `PerformanceClient: Emitting event to callback ${callbackId}`,\r\n                    correlationId\r\n                );\r\n                callback.apply(null, [events]);\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Enforce truncation of integral fields in performance event.\r\n     * @param {PerformanceEvent} event performance event to update.\r\n     */\r\n    private truncateIntegralFields(event: PerformanceEvent): void {\r\n        this.intFields.forEach((key) => {\r\n            if (key in event && typeof event[key] === \"number\") {\r\n                event[key] = Math.floor(event[key]);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns event duration in milliseconds\r\n     * @param startTimeMs {number}\r\n     * @returns {number}\r\n     */\r\n    private getDurationMs(startTimeMs: number): number {\r\n        const durationMs = Date.now() - startTimeMs;\r\n        // Handle clock skew\r\n        return durationMs < 0 ? durationMs : 0;\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}