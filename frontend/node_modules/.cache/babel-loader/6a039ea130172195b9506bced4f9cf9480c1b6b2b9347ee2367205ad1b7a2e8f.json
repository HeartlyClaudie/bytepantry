{"ast":null,"code":"/*! @azure/msal-browser v4.5.0 2025-02-26 */\n'use strict';\n\nimport { invokeAsync, PerformanceEvents, AuthError, Constants, UrlString, UrlUtils, ProtocolUtils, ThrottlingUtils, ProtocolMode, ServerResponseType } from '@azure/msal-common/browser';\nimport { StandardInteractionClient } from './StandardInteractionClient.mjs';\nimport { InteractionType, ApiId, TemporaryCacheKeys } from '../utils/BrowserConstants.mjs';\nimport { RedirectHandler } from '../interaction_handler/RedirectHandler.mjs';\nimport { replaceHash, isInIframe, getHomepage, clearHash, getCurrentUri } from '../utils/BrowserUtils.mjs';\nimport { EventType } from '../event/EventType.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { NativeInteractionClient } from './NativeInteractionClient.mjs';\nimport { NativeMessageHandler } from '../broker/nativeBroker/NativeMessageHandler.mjs';\nimport { validateInteractionType } from '../response/ResponseHandler.mjs';\nimport { noStateInHash, nativeConnectionNotEstablished, noCachedAuthorityError } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction getNavigationType() {\n  if (typeof window === \"undefined\" || typeof window.performance === \"undefined\" || typeof window.performance.getEntriesByType !== \"function\") {\n    return undefined;\n  }\n  const navigationEntries = window.performance.getEntriesByType(\"navigation\");\n  const navigation = navigationEntries.length ? navigationEntries[0] : undefined;\n  return navigation?.type;\n}\nclass RedirectClient extends StandardInteractionClient {\n  constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {\n    super(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId);\n    this.nativeStorage = nativeStorageImpl;\n  }\n  /**\r\n   * Redirects the page to the /authorize endpoint of the IDP\r\n   * @param request\r\n   */\n  async acquireToken(request) {\n    const validRequest = await invokeAsync(this.initializeAuthorizationRequest.bind(this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.logger, this.performanceClient, this.correlationId)(request, InteractionType.Redirect);\n    this.browserStorage.updateCacheEntries(validRequest.state, validRequest.nonce, validRequest.authority, validRequest.loginHint || \"\", validRequest.account || null);\n    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenRedirect);\n    const handleBackButton = event => {\n      // Clear temporary cache if the back button is clicked during the redirect flow.\n      if (event.persisted) {\n        this.logger.verbose(\"Page was restored from back/forward cache. Clearing temporary cache.\");\n        this.browserStorage.cleanRequestByState(validRequest.state);\n        this.eventHandler.emitEvent(EventType.RESTORE_FROM_BFCACHE, InteractionType.Redirect);\n      }\n    };\n    try {\n      // Create auth code request and generate PKCE params\n      const authCodeRequest = await invokeAsync(this.initializeAuthorizationCodeRequest.bind(this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, this.logger, this.performanceClient, this.correlationId)(validRequest);\n      // Initialize the client\n      const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, this.correlationId)({\n        serverTelemetryManager,\n        requestAuthority: validRequest.authority,\n        requestAzureCloudOptions: validRequest.azureCloudOptions,\n        requestExtraQueryParameters: validRequest.extraQueryParameters,\n        account: validRequest.account\n      });\n      // Create redirect interaction handler.\n      const interactionHandler = new RedirectHandler(authClient, this.browserStorage, authCodeRequest, this.logger, this.performanceClient);\n      // Create acquire token url.\n      const navigateUrl = await authClient.getAuthCodeUrl({\n        ...validRequest,\n        platformBroker: NativeMessageHandler.isPlatformBrokerAvailable(this.config, this.logger, this.nativeMessageHandler, request.authenticationScheme)\n      });\n      const redirectStartPage = this.getRedirectStartPage(request.redirectStartPage);\n      this.logger.verbosePii(`Redirect start page: ${redirectStartPage}`);\n      // Clear temporary cache if the back button is clicked during the redirect flow.\n      window.addEventListener(\"pageshow\", handleBackButton);\n      // Show the UI once the url has been created. Response will come back in the hash, which will be handled in the handleRedirectCallback function.\n      return await interactionHandler.initiateAuthRequest(navigateUrl, {\n        navigationClient: this.navigationClient,\n        redirectTimeout: this.config.system.redirectNavigationTimeout,\n        redirectStartPage: redirectStartPage,\n        onRedirectNavigate: request.onRedirectNavigate || this.config.auth.onRedirectNavigate\n      });\n    } catch (e) {\n      if (e instanceof AuthError) {\n        e.setCorrelationId(this.correlationId);\n        serverTelemetryManager.cacheFailedRequest(e);\n      }\n      window.removeEventListener(\"pageshow\", handleBackButton);\n      this.browserStorage.cleanRequestByState(validRequest.state);\n      throw e;\n    }\n  }\n  /**\r\n   * Checks if navigateToLoginRequestUrl is set, and:\r\n   * - if true, performs logic to cache and navigate\r\n   * - if false, handles hash string and parses response\r\n   * @param hash {string} url hash\r\n   * @param parentMeasurement {InProgressPerformanceEvent} parent measurement\r\n   */\n  async handleRedirectPromise(hash = \"\", parentMeasurement) {\n    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.handleRedirectPromise);\n    try {\n      if (!this.browserStorage.isInteractionInProgress(true)) {\n        this.logger.info(\"handleRedirectPromise called but there is no interaction in progress, returning null.\");\n        return null;\n      }\n      const [serverParams, responseString] = this.getRedirectResponse(hash || \"\");\n      if (!serverParams) {\n        // Not a recognized server response hash or hash not associated with a redirect request\n        this.logger.info(\"handleRedirectPromise did not detect a response as a result of a redirect. Cleaning temporary cache.\");\n        this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n        // Do not instrument \"no_server_response\" if user clicked back button\n        if (getNavigationType() !== \"back_forward\") {\n          parentMeasurement.event.errorCode = \"no_server_response\";\n        } else {\n          this.logger.verbose(\"Back navigation event detected. Muting no_server_response error\");\n        }\n        return null;\n      }\n      // If navigateToLoginRequestUrl is true, get the url where the redirect request was initiated\n      const loginRequestUrl = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, true) || Constants.EMPTY_STRING;\n      const loginRequestUrlNormalized = UrlString.removeHashFromUrl(loginRequestUrl);\n      const currentUrlNormalized = UrlString.removeHashFromUrl(window.location.href);\n      if (loginRequestUrlNormalized === currentUrlNormalized && this.config.auth.navigateToLoginRequestUrl) {\n        // We are on the page we need to navigate to - handle hash\n        this.logger.verbose(\"Current page is loginRequestUrl, handling response\");\n        if (loginRequestUrl.indexOf(\"#\") > -1) {\n          // Replace current hash with non-msal hash, if present\n          replaceHash(loginRequestUrl);\n        }\n        const handleHashResult = await this.handleResponse(serverParams, serverTelemetryManager);\n        return handleHashResult;\n      } else if (!this.config.auth.navigateToLoginRequestUrl) {\n        this.logger.verbose(\"NavigateToLoginRequestUrl set to false, handling response\");\n        return await this.handleResponse(serverParams, serverTelemetryManager);\n      } else if (!isInIframe() || this.config.system.allowRedirectInIframe) {\n        /*\r\n         * Returned from authority using redirect - need to perform navigation before processing response\r\n         * Cache the hash to be retrieved after the next redirect\r\n         */\n        this.browserStorage.setTemporaryCache(TemporaryCacheKeys.URL_HASH, responseString, true);\n        const navigationOptions = {\n          apiId: ApiId.handleRedirectPromise,\n          timeout: this.config.system.redirectNavigationTimeout,\n          noHistory: true\n        };\n        /**\r\n         * Default behavior is to redirect to the start page and not process the hash now.\r\n         * The start page is expected to also call handleRedirectPromise which will process the hash in one of the checks above.\r\n         */\n        let processHashOnRedirect = true;\n        if (!loginRequestUrl || loginRequestUrl === \"null\") {\n          // Redirect to home page if login request url is null (real null or the string null)\n          const homepage = getHomepage();\n          // Cache the homepage under ORIGIN_URI to ensure cached hash is processed on homepage\n          this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, homepage, true);\n          this.logger.warning(\"Unable to get valid login request url from cache, redirecting to home page\");\n          processHashOnRedirect = await this.navigationClient.navigateInternal(homepage, navigationOptions);\n        } else {\n          // Navigate to page that initiated the redirect request\n          this.logger.verbose(`Navigating to loginRequestUrl: ${loginRequestUrl}`);\n          processHashOnRedirect = await this.navigationClient.navigateInternal(loginRequestUrl, navigationOptions);\n        }\n        // If navigateInternal implementation returns false, handle the hash now\n        if (!processHashOnRedirect) {\n          return await this.handleResponse(serverParams, serverTelemetryManager);\n        }\n      }\n      return null;\n    } catch (e) {\n      if (e instanceof AuthError) {\n        e.setCorrelationId(this.correlationId);\n        serverTelemetryManager.cacheFailedRequest(e);\n      }\n      this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n      throw e;\n    }\n  }\n  /**\r\n   * Gets the response hash for a redirect request\r\n   * Returns null if interactionType in the state value is not \"redirect\" or the hash does not contain known properties\r\n   * @param hash\r\n   */\n  getRedirectResponse(userProvidedResponse) {\n    this.logger.verbose(\"getRedirectResponseHash called\");\n    // Get current location hash from window or cache.\n    let responseString = userProvidedResponse;\n    if (!responseString) {\n      if (this.config.auth.OIDCOptions.serverResponseType === ServerResponseType.QUERY) {\n        responseString = window.location.search;\n      } else {\n        responseString = window.location.hash;\n      }\n    }\n    let response = UrlUtils.getDeserializedResponse(responseString);\n    if (response) {\n      try {\n        validateInteractionType(response, this.browserCrypto, InteractionType.Redirect);\n      } catch (e) {\n        if (e instanceof AuthError) {\n          this.logger.error(`Interaction type validation failed due to ${e.errorCode}: ${e.errorMessage}`);\n        }\n        return [null, \"\"];\n      }\n      clearHash(window);\n      this.logger.verbose(\"Hash contains known properties, returning response hash\");\n      return [response, responseString];\n    }\n    const cachedHash = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.URL_HASH, true);\n    this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    if (cachedHash) {\n      response = UrlUtils.getDeserializedResponse(cachedHash);\n      if (response) {\n        this.logger.verbose(\"Hash does not contain known properties, returning cached hash\");\n        return [response, cachedHash];\n      }\n    }\n    return [null, \"\"];\n  }\n  /**\r\n   * Checks if hash exists and handles in window.\r\n   * @param hash\r\n   * @param state\r\n   */\n  async handleResponse(serverParams, serverTelemetryManager) {\n    const state = serverParams.state;\n    if (!state) {\n      throw createBrowserAuthError(noStateInHash);\n    }\n    const cachedRequest = this.browserStorage.getCachedRequest(state);\n    this.logger.verbose(\"handleResponse called, retrieved cached request\");\n    if (serverParams.accountId) {\n      this.logger.verbose(\"Account id found in hash, calling WAM for token\");\n      if (!this.nativeMessageHandler) {\n        throw createBrowserAuthError(nativeConnectionNotEstablished);\n      }\n      const nativeInteractionClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenPopup, this.performanceClient, this.nativeMessageHandler, serverParams.accountId, this.nativeStorage, cachedRequest.correlationId);\n      const {\n        userRequestState\n      } = ProtocolUtils.parseRequestState(this.browserCrypto, state);\n      return nativeInteractionClient.acquireToken({\n        ...cachedRequest,\n        state: userRequestState,\n        prompt: undefined // Server should handle the prompt, ideally native broker can do this part silently\n      }).finally(() => {\n        this.browserStorage.cleanRequestByState(state);\n      });\n    }\n    // Hash contains known properties - handle and return in callback\n    const currentAuthority = this.browserStorage.getCachedAuthority(state);\n    if (!currentAuthority) {\n      throw createBrowserAuthError(noCachedAuthorityError);\n    }\n    const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, this.correlationId)({\n      serverTelemetryManager,\n      requestAuthority: currentAuthority\n    });\n    ThrottlingUtils.removeThrottle(this.browserStorage, this.config.auth.clientId, cachedRequest);\n    const interactionHandler = new RedirectHandler(authClient, this.browserStorage, cachedRequest, this.logger, this.performanceClient);\n    return interactionHandler.handleCodeResponse(serverParams, state);\n  }\n  /**\r\n   * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n   * Default behaviour is to redirect the user to `window.location.href`.\r\n   * @param logoutRequest\r\n   */\n  async logout(logoutRequest) {\n    this.logger.verbose(\"logoutRedirect called\");\n    const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\n    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logout);\n    try {\n      this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Redirect, logoutRequest);\n      // Clear cache on logout\n      await this.clearCacheOnLogout(validLogoutRequest.account);\n      const navigationOptions = {\n        apiId: ApiId.logout,\n        timeout: this.config.system.redirectNavigationTimeout,\n        noHistory: false\n      };\n      const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, this.correlationId)({\n        serverTelemetryManager,\n        requestAuthority: logoutRequest && logoutRequest.authority,\n        requestExtraQueryParameters: logoutRequest?.extraQueryParameters,\n        account: logoutRequest && logoutRequest.account || undefined\n      });\n      if (authClient.authority.protocolMode === ProtocolMode.OIDC) {\n        try {\n          authClient.authority.endSessionEndpoint;\n        } catch {\n          if (validLogoutRequest.account?.homeAccountId) {\n            void this.browserStorage.removeAccount(validLogoutRequest.account?.homeAccountId);\n            this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);\n            return;\n          }\n        }\n      }\n      // Create logout string and navigate user window to logout.\n      const logoutUri = authClient.getLogoutUri(validLogoutRequest);\n      this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);\n      // Check if onRedirectNavigate is implemented, and invoke it if so\n      if (logoutRequest && typeof logoutRequest.onRedirectNavigate === \"function\") {\n        const navigate = logoutRequest.onRedirectNavigate(logoutUri);\n        if (navigate !== false) {\n          this.logger.verbose(\"Logout onRedirectNavigate did not return false, navigating\");\n          // Ensure interaction is in progress\n          if (!this.browserStorage.getInteractionInProgress()) {\n            this.browserStorage.setInteractionInProgress(true);\n          }\n          await this.navigationClient.navigateExternal(logoutUri, navigationOptions);\n          return;\n        } else {\n          // Ensure interaction is not in progress\n          this.browserStorage.setInteractionInProgress(false);\n          this.logger.verbose(\"Logout onRedirectNavigate returned false, stopping navigation\");\n        }\n      } else {\n        // Ensure interaction is in progress\n        if (!this.browserStorage.getInteractionInProgress()) {\n          this.browserStorage.setInteractionInProgress(true);\n        }\n        await this.navigationClient.navigateExternal(logoutUri, navigationOptions);\n        return;\n      }\n    } catch (e) {\n      if (e instanceof AuthError) {\n        e.setCorrelationId(this.correlationId);\n        serverTelemetryManager.cacheFailedRequest(e);\n      }\n      this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Redirect, null, e);\n      this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);\n      throw e;\n    }\n    this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);\n  }\n  /**\r\n   * Use to get the redirectStartPage either from request or use current window\r\n   * @param requestStartPage\r\n   */\n  getRedirectStartPage(requestStartPage) {\n    const redirectStartPage = requestStartPage || window.location.href;\n    return UrlString.getAbsoluteUrl(redirectStartPage, getCurrentUri());\n  }\n}\nexport { RedirectClient };","map":{"version":3,"names":["getNavigationType","window","performance","getEntriesByType","undefined","navigationEntries","navigation","length","type","RedirectClient","StandardInteractionClient","constructor","config","storageImpl","browserCrypto","logger","eventHandler","navigationClient","performanceClient","nativeStorageImpl","nativeMessageHandler","correlationId","nativeStorage","acquireToken","request","validRequest","invokeAsync","initializeAuthorizationRequest","bind","PerformanceEvents","StandardInteractionClientInitializeAuthorizationRequest","InteractionType","Redirect","browserStorage","updateCacheEntries","state","nonce","authority","loginHint","account","serverTelemetryManager","initializeServerTelemetryManager","ApiId","acquireTokenRedirect","handleBackButton","event","persisted","verbose","cleanRequestByState","emitEvent","EventType","RESTORE_FROM_BFCACHE","authCodeRequest","initializeAuthorizationCodeRequest","StandardInteractionClientInitializeAuthorizationCodeRequest","authClient","createAuthCodeClient","StandardInteractionClientCreateAuthCodeClient","requestAuthority","requestAzureCloudOptions","azureCloudOptions","requestExtraQueryParameters","extraQueryParameters","interactionHandler","RedirectHandler","navigateUrl","getAuthCodeUrl","platformBroker","NativeMessageHandler","isPlatformBrokerAvailable","authenticationScheme","redirectStartPage","getRedirectStartPage","verbosePii","addEventListener","initiateAuthRequest","redirectTimeout","system","redirectNavigationTimeout","onRedirectNavigate","auth","e","AuthError","setCorrelationId","cacheFailedRequest","removeEventListener","handleRedirectPromise","hash","parentMeasurement","isInteractionInProgress","info","serverParams","responseString","getRedirectResponse","cleanRequestByInteractionType","errorCode","loginRequestUrl","getTemporaryCache","TemporaryCacheKeys","ORIGIN_URI","Constants","EMPTY_STRING","loginRequestUrlNormalized","UrlString","removeHashFromUrl","currentUrlNormalized","location","href","navigateToLoginRequestUrl","indexOf","replaceHash","handleHashResult","handleResponse","isInIframe","allowRedirectInIframe","setTemporaryCache","URL_HASH","navigationOptions","apiId","timeout","noHistory","processHashOnRedirect","homepage","getHomepage","warning","navigateInternal","userProvidedResponse","OIDCOptions","serverResponseType","ServerResponseType","QUERY","search","response","UrlUtils","getDeserializedResponse","validateInteractionType","error","errorMessage","clearHash","cachedHash","removeItem","generateCacheKey","createBrowserAuthError","noStateInHash","cachedRequest","getCachedRequest","accountId","nativeConnectionNotEstablished","nativeInteractionClient","NativeInteractionClient","acquireTokenPopup","userRequestState","ProtocolUtils","parseRequestState","prompt","finally","currentAuthority","getCachedAuthority","noCachedAuthorityError","ThrottlingUtils","removeThrottle","clientId","handleCodeResponse","logout","logoutRequest","validLogoutRequest","initializeLogoutRequest","LOGOUT_START","clearCacheOnLogout","protocolMode","ProtocolMode","OIDC","endSessionEndpoint","homeAccountId","removeAccount","LOGOUT_SUCCESS","logoutUri","getLogoutUri","navigate","getInteractionInProgress","setInteractionInProgress","navigateExternal","LOGOUT_FAILURE","LOGOUT_END","requestStartPage","getAbsoluteUrl","getCurrentUri"],"sources":["C:\\bytepantry\\frontend\\node_modules\\@azure\\msal-browser\\src\\interaction_client\\RedirectClient.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    CommonAuthorizationCodeRequest,\r\n    AuthorizationCodeClient,\r\n    UrlString,\r\n    AuthError,\r\n    ServerTelemetryManager,\r\n    Constants,\r\n    ProtocolUtils,\r\n    ServerAuthorizationCodeResponse,\r\n    ThrottlingUtils,\r\n    ICrypto,\r\n    Logger,\r\n    IPerformanceClient,\r\n    PerformanceEvents,\r\n    ProtocolMode,\r\n    invokeAsync,\r\n    ServerResponseType,\r\n    UrlUtils,\r\n    InProgressPerformanceEvent,\r\n} from \"@azure/msal-common/browser\";\r\nimport { StandardInteractionClient } from \"./StandardInteractionClient.js\";\r\nimport {\r\n    ApiId,\r\n    InteractionType,\r\n    TemporaryCacheKeys,\r\n} from \"../utils/BrowserConstants.js\";\r\nimport { RedirectHandler } from \"../interaction_handler/RedirectHandler.js\";\r\nimport * as BrowserUtils from \"../utils/BrowserUtils.js\";\r\nimport { EndSessionRequest } from \"../request/EndSessionRequest.js\";\r\nimport { EventType } from \"../event/EventType.js\";\r\nimport { NavigationOptions } from \"../navigation/NavigationOptions.js\";\r\nimport {\r\n    createBrowserAuthError,\r\n    BrowserAuthErrorCodes,\r\n} from \"../error/BrowserAuthError.js\";\r\nimport { RedirectRequest } from \"../request/RedirectRequest.js\";\r\nimport { NativeInteractionClient } from \"./NativeInteractionClient.js\";\r\nimport { NativeMessageHandler } from \"../broker/nativeBroker/NativeMessageHandler.js\";\r\nimport { BrowserConfiguration } from \"../config/Configuration.js\";\r\nimport { BrowserCacheManager } from \"../cache/BrowserCacheManager.js\";\r\nimport { EventHandler } from \"../event/EventHandler.js\";\r\nimport { INavigationClient } from \"../navigation/INavigationClient.js\";\r\nimport { EventError } from \"../event/EventMessage.js\";\r\nimport { AuthenticationResult } from \"../response/AuthenticationResult.js\";\r\nimport * as ResponseHandler from \"../response/ResponseHandler.js\";\r\n\r\nfunction getNavigationType(): NavigationTimingType | undefined {\r\n    if (\r\n        typeof window === \"undefined\" ||\r\n        typeof window.performance === \"undefined\" ||\r\n        typeof window.performance.getEntriesByType !== \"function\"\r\n    ) {\r\n        return undefined;\r\n    }\r\n\r\n    const navigationEntries = window.performance.getEntriesByType(\"navigation\");\r\n    const navigation = navigationEntries.length\r\n        ? (navigationEntries[0] as PerformanceNavigationTiming)\r\n        : undefined;\r\n    return navigation?.type;\r\n}\r\n\r\nexport class RedirectClient extends StandardInteractionClient {\r\n    protected nativeStorage: BrowserCacheManager;\r\n\r\n    constructor(\r\n        config: BrowserConfiguration,\r\n        storageImpl: BrowserCacheManager,\r\n        browserCrypto: ICrypto,\r\n        logger: Logger,\r\n        eventHandler: EventHandler,\r\n        navigationClient: INavigationClient,\r\n        performanceClient: IPerformanceClient,\r\n        nativeStorageImpl: BrowserCacheManager,\r\n        nativeMessageHandler?: NativeMessageHandler,\r\n        correlationId?: string\r\n    ) {\r\n        super(\r\n            config,\r\n            storageImpl,\r\n            browserCrypto,\r\n            logger,\r\n            eventHandler,\r\n            navigationClient,\r\n            performanceClient,\r\n            nativeMessageHandler,\r\n            correlationId\r\n        );\r\n        this.nativeStorage = nativeStorageImpl;\r\n    }\r\n\r\n    /**\r\n     * Redirects the page to the /authorize endpoint of the IDP\r\n     * @param request\r\n     */\r\n    async acquireToken(request: RedirectRequest): Promise<void> {\r\n        const validRequest = await invokeAsync(\r\n            this.initializeAuthorizationRequest.bind(this),\r\n            PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest,\r\n            this.logger,\r\n            this.performanceClient,\r\n            this.correlationId\r\n        )(request, InteractionType.Redirect);\r\n\r\n        this.browserStorage.updateCacheEntries(\r\n            validRequest.state,\r\n            validRequest.nonce,\r\n            validRequest.authority,\r\n            validRequest.loginHint || \"\",\r\n            validRequest.account || null\r\n        );\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(\r\n            ApiId.acquireTokenRedirect\r\n        );\r\n\r\n        const handleBackButton = (event: PageTransitionEvent) => {\r\n            // Clear temporary cache if the back button is clicked during the redirect flow.\r\n            if (event.persisted) {\r\n                this.logger.verbose(\r\n                    \"Page was restored from back/forward cache. Clearing temporary cache.\"\r\n                );\r\n                this.browserStorage.cleanRequestByState(validRequest.state);\r\n                this.eventHandler.emitEvent(\r\n                    EventType.RESTORE_FROM_BFCACHE,\r\n                    InteractionType.Redirect\r\n                );\r\n            }\r\n        };\r\n\r\n        try {\r\n            // Create auth code request and generate PKCE params\r\n            const authCodeRequest: CommonAuthorizationCodeRequest =\r\n                await invokeAsync(\r\n                    this.initializeAuthorizationCodeRequest.bind(this),\r\n                    PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest,\r\n                    this.logger,\r\n                    this.performanceClient,\r\n                    this.correlationId\r\n                )(validRequest);\r\n\r\n            // Initialize the client\r\n            const authClient: AuthorizationCodeClient = await invokeAsync(\r\n                this.createAuthCodeClient.bind(this),\r\n                PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,\r\n                this.logger,\r\n                this.performanceClient,\r\n                this.correlationId\r\n            )({\r\n                serverTelemetryManager,\r\n                requestAuthority: validRequest.authority,\r\n                requestAzureCloudOptions: validRequest.azureCloudOptions,\r\n                requestExtraQueryParameters: validRequest.extraQueryParameters,\r\n                account: validRequest.account,\r\n            });\r\n\r\n            // Create redirect interaction handler.\r\n            const interactionHandler = new RedirectHandler(\r\n                authClient,\r\n                this.browserStorage,\r\n                authCodeRequest,\r\n                this.logger,\r\n                this.performanceClient\r\n            );\r\n\r\n            // Create acquire token url.\r\n            const navigateUrl = await authClient.getAuthCodeUrl({\r\n                ...validRequest,\r\n                platformBroker: NativeMessageHandler.isPlatformBrokerAvailable(\r\n                    this.config,\r\n                    this.logger,\r\n                    this.nativeMessageHandler,\r\n                    request.authenticationScheme\r\n                ),\r\n            });\r\n\r\n            const redirectStartPage = this.getRedirectStartPage(\r\n                request.redirectStartPage\r\n            );\r\n            this.logger.verbosePii(`Redirect start page: ${redirectStartPage}`);\r\n\r\n            // Clear temporary cache if the back button is clicked during the redirect flow.\r\n            window.addEventListener(\"pageshow\", handleBackButton);\r\n\r\n            // Show the UI once the url has been created. Response will come back in the hash, which will be handled in the handleRedirectCallback function.\r\n            return await interactionHandler.initiateAuthRequest(navigateUrl, {\r\n                navigationClient: this.navigationClient,\r\n                redirectTimeout: this.config.system.redirectNavigationTimeout,\r\n                redirectStartPage: redirectStartPage,\r\n                onRedirectNavigate:\r\n                    request.onRedirectNavigate ||\r\n                    this.config.auth.onRedirectNavigate,\r\n            });\r\n        } catch (e) {\r\n            if (e instanceof AuthError) {\r\n                e.setCorrelationId(this.correlationId);\r\n                serverTelemetryManager.cacheFailedRequest(e);\r\n            }\r\n            window.removeEventListener(\"pageshow\", handleBackButton);\r\n            this.browserStorage.cleanRequestByState(validRequest.state);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if navigateToLoginRequestUrl is set, and:\r\n     * - if true, performs logic to cache and navigate\r\n     * - if false, handles hash string and parses response\r\n     * @param hash {string} url hash\r\n     * @param parentMeasurement {InProgressPerformanceEvent} parent measurement\r\n     */\r\n    async handleRedirectPromise(\r\n        hash: string = \"\",\r\n        parentMeasurement: InProgressPerformanceEvent\r\n    ): Promise<AuthenticationResult | null> {\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(\r\n            ApiId.handleRedirectPromise\r\n        );\r\n\r\n        try {\r\n            if (!this.browserStorage.isInteractionInProgress(true)) {\r\n                this.logger.info(\r\n                    \"handleRedirectPromise called but there is no interaction in progress, returning null.\"\r\n                );\r\n                return null;\r\n            }\r\n            const [serverParams, responseString] = this.getRedirectResponse(\r\n                hash || \"\"\r\n            );\r\n            if (!serverParams) {\r\n                // Not a recognized server response hash or hash not associated with a redirect request\r\n                this.logger.info(\r\n                    \"handleRedirectPromise did not detect a response as a result of a redirect. Cleaning temporary cache.\"\r\n                );\r\n                this.browserStorage.cleanRequestByInteractionType(\r\n                    InteractionType.Redirect\r\n                );\r\n\r\n                // Do not instrument \"no_server_response\" if user clicked back button\r\n                if (getNavigationType() !== \"back_forward\") {\r\n                    parentMeasurement.event.errorCode = \"no_server_response\";\r\n                } else {\r\n                    this.logger.verbose(\r\n                        \"Back navigation event detected. Muting no_server_response error\"\r\n                    );\r\n                }\r\n                return null;\r\n            }\r\n\r\n            // If navigateToLoginRequestUrl is true, get the url where the redirect request was initiated\r\n            const loginRequestUrl =\r\n                this.browserStorage.getTemporaryCache(\r\n                    TemporaryCacheKeys.ORIGIN_URI,\r\n                    true\r\n                ) || Constants.EMPTY_STRING;\r\n            const loginRequestUrlNormalized =\r\n                UrlString.removeHashFromUrl(loginRequestUrl);\r\n            const currentUrlNormalized = UrlString.removeHashFromUrl(\r\n                window.location.href\r\n            );\r\n\r\n            if (\r\n                loginRequestUrlNormalized === currentUrlNormalized &&\r\n                this.config.auth.navigateToLoginRequestUrl\r\n            ) {\r\n                // We are on the page we need to navigate to - handle hash\r\n                this.logger.verbose(\r\n                    \"Current page is loginRequestUrl, handling response\"\r\n                );\r\n\r\n                if (loginRequestUrl.indexOf(\"#\") > -1) {\r\n                    // Replace current hash with non-msal hash, if present\r\n                    BrowserUtils.replaceHash(loginRequestUrl);\r\n                }\r\n\r\n                const handleHashResult = await this.handleResponse(\r\n                    serverParams,\r\n                    serverTelemetryManager\r\n                );\r\n\r\n                return handleHashResult;\r\n            } else if (!this.config.auth.navigateToLoginRequestUrl) {\r\n                this.logger.verbose(\r\n                    \"NavigateToLoginRequestUrl set to false, handling response\"\r\n                );\r\n                return await this.handleResponse(\r\n                    serverParams,\r\n                    serverTelemetryManager\r\n                );\r\n            } else if (\r\n                !BrowserUtils.isInIframe() ||\r\n                this.config.system.allowRedirectInIframe\r\n            ) {\r\n                /*\r\n                 * Returned from authority using redirect - need to perform navigation before processing response\r\n                 * Cache the hash to be retrieved after the next redirect\r\n                 */\r\n                this.browserStorage.setTemporaryCache(\r\n                    TemporaryCacheKeys.URL_HASH,\r\n                    responseString,\r\n                    true\r\n                );\r\n                const navigationOptions: NavigationOptions = {\r\n                    apiId: ApiId.handleRedirectPromise,\r\n                    timeout: this.config.system.redirectNavigationTimeout,\r\n                    noHistory: true,\r\n                };\r\n\r\n                /**\r\n                 * Default behavior is to redirect to the start page and not process the hash now.\r\n                 * The start page is expected to also call handleRedirectPromise which will process the hash in one of the checks above.\r\n                 */\r\n                let processHashOnRedirect: boolean = true;\r\n                if (!loginRequestUrl || loginRequestUrl === \"null\") {\r\n                    // Redirect to home page if login request url is null (real null or the string null)\r\n                    const homepage = BrowserUtils.getHomepage();\r\n                    // Cache the homepage under ORIGIN_URI to ensure cached hash is processed on homepage\r\n                    this.browserStorage.setTemporaryCache(\r\n                        TemporaryCacheKeys.ORIGIN_URI,\r\n                        homepage,\r\n                        true\r\n                    );\r\n                    this.logger.warning(\r\n                        \"Unable to get valid login request url from cache, redirecting to home page\"\r\n                    );\r\n                    processHashOnRedirect =\r\n                        await this.navigationClient.navigateInternal(\r\n                            homepage,\r\n                            navigationOptions\r\n                        );\r\n                } else {\r\n                    // Navigate to page that initiated the redirect request\r\n                    this.logger.verbose(\r\n                        `Navigating to loginRequestUrl: ${loginRequestUrl}`\r\n                    );\r\n                    processHashOnRedirect =\r\n                        await this.navigationClient.navigateInternal(\r\n                            loginRequestUrl,\r\n                            navigationOptions\r\n                        );\r\n                }\r\n\r\n                // If navigateInternal implementation returns false, handle the hash now\r\n                if (!processHashOnRedirect) {\r\n                    return await this.handleResponse(\r\n                        serverParams,\r\n                        serverTelemetryManager\r\n                    );\r\n                }\r\n            }\r\n\r\n            return null;\r\n        } catch (e) {\r\n            if (e instanceof AuthError) {\r\n                (e as AuthError).setCorrelationId(this.correlationId);\r\n                serverTelemetryManager.cacheFailedRequest(e);\r\n            }\r\n            this.browserStorage.cleanRequestByInteractionType(\r\n                InteractionType.Redirect\r\n            );\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the response hash for a redirect request\r\n     * Returns null if interactionType in the state value is not \"redirect\" or the hash does not contain known properties\r\n     * @param hash\r\n     */\r\n    protected getRedirectResponse(\r\n        userProvidedResponse: string\r\n    ): [ServerAuthorizationCodeResponse | null, string] {\r\n        this.logger.verbose(\"getRedirectResponseHash called\");\r\n        // Get current location hash from window or cache.\r\n        let responseString = userProvidedResponse;\r\n        if (!responseString) {\r\n            if (\r\n                this.config.auth.OIDCOptions.serverResponseType ===\r\n                ServerResponseType.QUERY\r\n            ) {\r\n                responseString = window.location.search;\r\n            } else {\r\n                responseString = window.location.hash;\r\n            }\r\n        }\r\n        let response = UrlUtils.getDeserializedResponse(responseString);\r\n\r\n        if (response) {\r\n            try {\r\n                ResponseHandler.validateInteractionType(\r\n                    response,\r\n                    this.browserCrypto,\r\n                    InteractionType.Redirect\r\n                );\r\n            } catch (e) {\r\n                if (e instanceof AuthError) {\r\n                    this.logger.error(\r\n                        `Interaction type validation failed due to ${e.errorCode}: ${e.errorMessage}`\r\n                    );\r\n                }\r\n                return [null, \"\"];\r\n            }\r\n\r\n            BrowserUtils.clearHash(window);\r\n            this.logger.verbose(\r\n                \"Hash contains known properties, returning response hash\"\r\n            );\r\n            return [response, responseString];\r\n        }\r\n\r\n        const cachedHash = this.browserStorage.getTemporaryCache(\r\n            TemporaryCacheKeys.URL_HASH,\r\n            true\r\n        );\r\n        this.browserStorage.removeItem(\r\n            this.browserStorage.generateCacheKey(TemporaryCacheKeys.URL_HASH)\r\n        );\r\n\r\n        if (cachedHash) {\r\n            response = UrlUtils.getDeserializedResponse(cachedHash);\r\n            if (response) {\r\n                this.logger.verbose(\r\n                    \"Hash does not contain known properties, returning cached hash\"\r\n                );\r\n                return [response, cachedHash];\r\n            }\r\n        }\r\n\r\n        return [null, \"\"];\r\n    }\r\n\r\n    /**\r\n     * Checks if hash exists and handles in window.\r\n     * @param hash\r\n     * @param state\r\n     */\r\n    protected async handleResponse(\r\n        serverParams: ServerAuthorizationCodeResponse,\r\n        serverTelemetryManager: ServerTelemetryManager\r\n    ): Promise<AuthenticationResult> {\r\n        const state = serverParams.state;\r\n        if (!state) {\r\n            throw createBrowserAuthError(BrowserAuthErrorCodes.noStateInHash);\r\n        }\r\n\r\n        const cachedRequest = this.browserStorage.getCachedRequest(state);\r\n        this.logger.verbose(\"handleResponse called, retrieved cached request\");\r\n\r\n        if (serverParams.accountId) {\r\n            this.logger.verbose(\r\n                \"Account id found in hash, calling WAM for token\"\r\n            );\r\n            if (!this.nativeMessageHandler) {\r\n                throw createBrowserAuthError(\r\n                    BrowserAuthErrorCodes.nativeConnectionNotEstablished\r\n                );\r\n            }\r\n            const nativeInteractionClient = new NativeInteractionClient(\r\n                this.config,\r\n                this.browserStorage,\r\n                this.browserCrypto,\r\n                this.logger,\r\n                this.eventHandler,\r\n                this.navigationClient,\r\n                ApiId.acquireTokenPopup,\r\n                this.performanceClient,\r\n                this.nativeMessageHandler,\r\n                serverParams.accountId,\r\n                this.nativeStorage,\r\n                cachedRequest.correlationId\r\n            );\r\n            const { userRequestState } = ProtocolUtils.parseRequestState(\r\n                this.browserCrypto,\r\n                state\r\n            );\r\n            return nativeInteractionClient\r\n                .acquireToken({\r\n                    ...cachedRequest,\r\n                    state: userRequestState,\r\n                    prompt: undefined, // Server should handle the prompt, ideally native broker can do this part silently\r\n                })\r\n                .finally(() => {\r\n                    this.browserStorage.cleanRequestByState(state);\r\n                });\r\n        }\r\n\r\n        // Hash contains known properties - handle and return in callback\r\n        const currentAuthority = this.browserStorage.getCachedAuthority(state);\r\n        if (!currentAuthority) {\r\n            throw createBrowserAuthError(\r\n                BrowserAuthErrorCodes.noCachedAuthorityError\r\n            );\r\n        }\r\n\r\n        const authClient = await invokeAsync(\r\n            this.createAuthCodeClient.bind(this),\r\n            PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,\r\n            this.logger,\r\n            this.performanceClient,\r\n            this.correlationId\r\n        )({ serverTelemetryManager, requestAuthority: currentAuthority });\r\n\r\n        ThrottlingUtils.removeThrottle(\r\n            this.browserStorage,\r\n            this.config.auth.clientId,\r\n            cachedRequest\r\n        );\r\n        const interactionHandler = new RedirectHandler(\r\n            authClient,\r\n            this.browserStorage,\r\n            cachedRequest,\r\n            this.logger,\r\n            this.performanceClient\r\n        );\r\n        return interactionHandler.handleCodeResponse(serverParams, state);\r\n    }\r\n\r\n    /**\r\n     * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n     * Default behaviour is to redirect the user to `window.location.href`.\r\n     * @param logoutRequest\r\n     */\r\n    async logout(logoutRequest?: EndSessionRequest): Promise<void> {\r\n        this.logger.verbose(\"logoutRedirect called\");\r\n        const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(\r\n            ApiId.logout\r\n        );\r\n\r\n        try {\r\n            this.eventHandler.emitEvent(\r\n                EventType.LOGOUT_START,\r\n                InteractionType.Redirect,\r\n                logoutRequest\r\n            );\r\n\r\n            // Clear cache on logout\r\n            await this.clearCacheOnLogout(validLogoutRequest.account);\r\n\r\n            const navigationOptions: NavigationOptions = {\r\n                apiId: ApiId.logout,\r\n                timeout: this.config.system.redirectNavigationTimeout,\r\n                noHistory: false,\r\n            };\r\n\r\n            const authClient = await invokeAsync(\r\n                this.createAuthCodeClient.bind(this),\r\n                PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,\r\n                this.logger,\r\n                this.performanceClient,\r\n                this.correlationId\r\n            )({\r\n                serverTelemetryManager,\r\n                requestAuthority: logoutRequest && logoutRequest.authority,\r\n                requestExtraQueryParameters:\r\n                    logoutRequest?.extraQueryParameters,\r\n                account: (logoutRequest && logoutRequest.account) || undefined,\r\n            });\r\n\r\n            if (authClient.authority.protocolMode === ProtocolMode.OIDC) {\r\n                try {\r\n                    authClient.authority.endSessionEndpoint;\r\n                } catch {\r\n                    if (validLogoutRequest.account?.homeAccountId) {\r\n                        void this.browserStorage.removeAccount(\r\n                            validLogoutRequest.account?.homeAccountId\r\n                        );\r\n\r\n                        this.eventHandler.emitEvent(\r\n                            EventType.LOGOUT_SUCCESS,\r\n                            InteractionType.Redirect,\r\n                            validLogoutRequest\r\n                        );\r\n\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Create logout string and navigate user window to logout.\r\n            const logoutUri: string =\r\n                authClient.getLogoutUri(validLogoutRequest);\r\n\r\n            this.eventHandler.emitEvent(\r\n                EventType.LOGOUT_SUCCESS,\r\n                InteractionType.Redirect,\r\n                validLogoutRequest\r\n            );\r\n            // Check if onRedirectNavigate is implemented, and invoke it if so\r\n            if (\r\n                logoutRequest &&\r\n                typeof logoutRequest.onRedirectNavigate === \"function\"\r\n            ) {\r\n                const navigate = logoutRequest.onRedirectNavigate(logoutUri);\r\n\r\n                if (navigate !== false) {\r\n                    this.logger.verbose(\r\n                        \"Logout onRedirectNavigate did not return false, navigating\"\r\n                    );\r\n                    // Ensure interaction is in progress\r\n                    if (!this.browserStorage.getInteractionInProgress()) {\r\n                        this.browserStorage.setInteractionInProgress(true);\r\n                    }\r\n                    await this.navigationClient.navigateExternal(\r\n                        logoutUri,\r\n                        navigationOptions\r\n                    );\r\n                    return;\r\n                } else {\r\n                    // Ensure interaction is not in progress\r\n                    this.browserStorage.setInteractionInProgress(false);\r\n                    this.logger.verbose(\r\n                        \"Logout onRedirectNavigate returned false, stopping navigation\"\r\n                    );\r\n                }\r\n            } else {\r\n                // Ensure interaction is in progress\r\n                if (!this.browserStorage.getInteractionInProgress()) {\r\n                    this.browserStorage.setInteractionInProgress(true);\r\n                }\r\n                await this.navigationClient.navigateExternal(\r\n                    logoutUri,\r\n                    navigationOptions\r\n                );\r\n                return;\r\n            }\r\n        } catch (e) {\r\n            if (e instanceof AuthError) {\r\n                (e as AuthError).setCorrelationId(this.correlationId);\r\n                serverTelemetryManager.cacheFailedRequest(e);\r\n            }\r\n            this.eventHandler.emitEvent(\r\n                EventType.LOGOUT_FAILURE,\r\n                InteractionType.Redirect,\r\n                null,\r\n                e as EventError\r\n            );\r\n            this.eventHandler.emitEvent(\r\n                EventType.LOGOUT_END,\r\n                InteractionType.Redirect\r\n            );\r\n            throw e;\r\n        }\r\n\r\n        this.eventHandler.emitEvent(\r\n            EventType.LOGOUT_END,\r\n            InteractionType.Redirect\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Use to get the redirectStartPage either from request or use current window\r\n     * @param requestStartPage\r\n     */\r\n    protected getRedirectStartPage(requestStartPage?: string): string {\r\n        const redirectStartPage = requestStartPage || window.location.href;\r\n        return UrlString.getAbsoluteUrl(\r\n            redirectStartPage,\r\n            BrowserUtils.getCurrentUri()\r\n        );\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}