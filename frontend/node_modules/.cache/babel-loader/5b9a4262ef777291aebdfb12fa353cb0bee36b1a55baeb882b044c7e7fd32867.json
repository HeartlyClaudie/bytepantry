{"ast":null,"code":"/*! @azure/msal-browser v4.5.0 2025-02-26 */\n'use strict';\n\nimport { createNetworkError } from '@azure/msal-common/browser';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { HTTP_REQUEST_TYPE } from '../utils/BrowserConstants.mjs';\nimport { getRequestFailed, noNetworkConnectivity, failedToParseResponse, postRequestFailed, failedToBuildHeaders, failedToParseHeaders } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * This class implements the Fetch API for GET and POST requests. See more here: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\r\n */\nclass FetchClient {\n  /**\r\n   * Fetch Client for REST endpoints - Get request\r\n   * @param url\r\n   * @param headers\r\n   * @param body\r\n   */\n  async sendGetRequestAsync(url, options) {\n    let response;\n    let responseHeaders = {};\n    let responseStatus = 0;\n    const reqHeaders = getFetchHeaders(options);\n    try {\n      response = await fetch(url, {\n        method: HTTP_REQUEST_TYPE.GET,\n        headers: reqHeaders\n      });\n    } catch (e) {\n      throw createBrowserAuthError(window.navigator.onLine ? getRequestFailed : noNetworkConnectivity);\n    }\n    responseHeaders = getHeaderDict(response.headers);\n    try {\n      responseStatus = response.status;\n      return {\n        headers: responseHeaders,\n        body: await response.json(),\n        status: responseStatus\n      };\n    } catch (e) {\n      throw createNetworkError(createBrowserAuthError(failedToParseResponse), responseStatus, responseHeaders);\n    }\n  }\n  /**\r\n   * Fetch Client for REST endpoints - Post request\r\n   * @param url\r\n   * @param headers\r\n   * @param body\r\n   */\n  async sendPostRequestAsync(url, options) {\n    const reqBody = options && options.body || \"\";\n    const reqHeaders = getFetchHeaders(options);\n    let response;\n    let responseStatus = 0;\n    let responseHeaders = {};\n    try {\n      response = await fetch(url, {\n        method: HTTP_REQUEST_TYPE.POST,\n        headers: reqHeaders,\n        body: reqBody\n      });\n    } catch (e) {\n      throw createBrowserAuthError(window.navigator.onLine ? postRequestFailed : noNetworkConnectivity);\n    }\n    responseHeaders = getHeaderDict(response.headers);\n    try {\n      responseStatus = response.status;\n      return {\n        headers: responseHeaders,\n        body: await response.json(),\n        status: responseStatus\n      };\n    } catch (e) {\n      throw createNetworkError(createBrowserAuthError(failedToParseResponse), responseStatus, responseHeaders);\n    }\n  }\n}\n/**\r\n * Get Fetch API Headers object from string map\r\n * @param inputHeaders\r\n */\nfunction getFetchHeaders(options) {\n  try {\n    const headers = new Headers();\n    if (!(options && options.headers)) {\n      return headers;\n    }\n    const optionsHeaders = options.headers;\n    Object.entries(optionsHeaders).forEach(([key, value]) => {\n      headers.append(key, value);\n    });\n    return headers;\n  } catch (e) {\n    throw createBrowserAuthError(failedToBuildHeaders);\n  }\n}\n/**\r\n * Returns object representing response headers\r\n * @param headers\r\n * @returns\r\n */\nfunction getHeaderDict(headers) {\n  try {\n    const headerDict = {};\n    headers.forEach((value, key) => {\n      headerDict[key] = value;\n    });\n    return headerDict;\n  } catch (e) {\n    throw createBrowserAuthError(failedToParseHeaders);\n  }\n}\nexport { FetchClient };","map":{"version":3,"names":["FetchClient","sendGetRequestAsync","url","options","response","responseHeaders","responseStatus","reqHeaders","getFetchHeaders","fetch","method","HTTP_REQUEST_TYPE","GET","headers","e","createBrowserAuthError","window","navigator","onLine","getRequestFailed","noNetworkConnectivity","getHeaderDict","status","body","json","createNetworkError","failedToParseResponse","sendPostRequestAsync","reqBody","POST","postRequestFailed","Headers","optionsHeaders","Object","entries","forEach","key","value","append","failedToBuildHeaders","headerDict","failedToParseHeaders"],"sources":["C:\\bytepantry\\frontend\\node_modules\\@azure\\msal-browser\\src\\network\\FetchClient.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    INetworkModule,\r\n    NetworkRequestOptions,\r\n    NetworkResponse,\r\n    createNetworkError,\r\n} from \"@azure/msal-common/browser\";\r\nimport {\r\n    createBrowserAuthError,\r\n    BrowserAuthErrorCodes,\r\n} from \"../error/BrowserAuthError.js\";\r\nimport { HTTP_REQUEST_TYPE } from \"../utils/BrowserConstants.js\";\r\n\r\n/**\r\n * This class implements the Fetch API for GET and POST requests. See more here: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\r\n */\r\nexport class FetchClient implements INetworkModule {\r\n    /**\r\n     * Fetch Client for REST endpoints - Get request\r\n     * @param url\r\n     * @param headers\r\n     * @param body\r\n     */\r\n    async sendGetRequestAsync<T>(\r\n        url: string,\r\n        options?: NetworkRequestOptions\r\n    ): Promise<NetworkResponse<T>> {\r\n        let response: Response;\r\n        let responseHeaders: Record<string, string> = {};\r\n        let responseStatus = 0;\r\n        const reqHeaders = getFetchHeaders(options);\r\n        try {\r\n            response = await fetch(url, {\r\n                method: HTTP_REQUEST_TYPE.GET,\r\n                headers: reqHeaders,\r\n            });\r\n        } catch (e) {\r\n            throw createBrowserAuthError(\r\n                window.navigator.onLine\r\n                    ? BrowserAuthErrorCodes.getRequestFailed\r\n                    : BrowserAuthErrorCodes.noNetworkConnectivity\r\n            );\r\n        }\r\n\r\n        responseHeaders = getHeaderDict(response.headers);\r\n        try {\r\n            responseStatus = response.status;\r\n            return {\r\n                headers: responseHeaders,\r\n                body: (await response.json()) as T,\r\n                status: responseStatus,\r\n            };\r\n        } catch (e) {\r\n            throw createNetworkError(\r\n                createBrowserAuthError(\r\n                    BrowserAuthErrorCodes.failedToParseResponse\r\n                ),\r\n                responseStatus,\r\n                responseHeaders\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fetch Client for REST endpoints - Post request\r\n     * @param url\r\n     * @param headers\r\n     * @param body\r\n     */\r\n    async sendPostRequestAsync<T>(\r\n        url: string,\r\n        options?: NetworkRequestOptions\r\n    ): Promise<NetworkResponse<T>> {\r\n        const reqBody = (options && options.body) || \"\";\r\n        const reqHeaders = getFetchHeaders(options);\r\n\r\n        let response: Response;\r\n        let responseStatus = 0;\r\n        let responseHeaders: Record<string, string> = {};\r\n        try {\r\n            response = await fetch(url, {\r\n                method: HTTP_REQUEST_TYPE.POST,\r\n                headers: reqHeaders,\r\n                body: reqBody,\r\n            });\r\n        } catch (e) {\r\n            throw createBrowserAuthError(\r\n                window.navigator.onLine\r\n                    ? BrowserAuthErrorCodes.postRequestFailed\r\n                    : BrowserAuthErrorCodes.noNetworkConnectivity\r\n            );\r\n        }\r\n\r\n        responseHeaders = getHeaderDict(response.headers);\r\n        try {\r\n            responseStatus = response.status;\r\n            return {\r\n                headers: responseHeaders,\r\n                body: (await response.json()) as T,\r\n                status: responseStatus,\r\n            };\r\n        } catch (e) {\r\n            throw createNetworkError(\r\n                createBrowserAuthError(\r\n                    BrowserAuthErrorCodes.failedToParseResponse\r\n                ),\r\n                responseStatus,\r\n                responseHeaders\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Get Fetch API Headers object from string map\r\n * @param inputHeaders\r\n */\r\nfunction getFetchHeaders(options?: NetworkRequestOptions): Headers {\r\n    try {\r\n        const headers = new Headers();\r\n        if (!(options && options.headers)) {\r\n            return headers;\r\n        }\r\n        const optionsHeaders = options.headers;\r\n        Object.entries(optionsHeaders).forEach(([key, value]) => {\r\n            headers.append(key, value);\r\n        });\r\n        return headers;\r\n    } catch (e) {\r\n        throw createBrowserAuthError(\r\n            BrowserAuthErrorCodes.failedToBuildHeaders\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Returns object representing response headers\r\n * @param headers\r\n * @returns\r\n */\r\nfunction getHeaderDict(headers: Headers): Record<string, string> {\r\n    try {\r\n        const headerDict: Record<string, string> = {};\r\n        headers.forEach((value: string, key: string) => {\r\n            headerDict[key] = value;\r\n        });\r\n        return headerDict;\r\n    } catch (e) {\r\n        throw createBrowserAuthError(\r\n            BrowserAuthErrorCodes.failedToParseHeaders\r\n        );\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}