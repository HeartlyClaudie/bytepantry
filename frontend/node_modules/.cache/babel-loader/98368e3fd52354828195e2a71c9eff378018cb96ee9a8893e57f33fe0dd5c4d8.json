{"ast":null,"code":"/*! @azure/msal-browser v4.5.0 2025-02-26 */\n'use strict';\n\nimport { PerformanceEvents, JoseHeader } from '@azure/msal-common/browser';\nimport { base64Encode, urlEncode, urlEncodeArr } from '../encode/Base64Encode.mjs';\nimport { base64Decode } from '../encode/Base64Decode.mjs';\nimport { validateCryptoAvailable, createNewGuid, generateKeyPair, exportJwk, importJwk, sign, hashString } from './BrowserCrypto.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { AsyncMemoryStorage } from '../cache/AsyncMemoryStorage.mjs';\nimport { cryptoKeyNotFound } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * This class implements MSAL's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and\r\n * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).\r\n */\nclass CryptoOps {\n  constructor(logger, performanceClient, skipValidateSubtleCrypto) {\n    this.logger = logger;\n    // Browser crypto needs to be validated first before any other classes can be set.\n    validateCryptoAvailable(skipValidateSubtleCrypto ?? false);\n    this.cache = new AsyncMemoryStorage(this.logger);\n    this.performanceClient = performanceClient;\n  }\n  /**\r\n   * Creates a new random GUID - used to populate state and nonce.\r\n   * @returns string (GUID)\r\n   */\n  createNewGuid() {\n    return createNewGuid();\n  }\n  /**\r\n   * Encodes input string to base64.\r\n   * @param input\r\n   */\n  base64Encode(input) {\n    return base64Encode(input);\n  }\n  /**\r\n   * Decodes input string from base64.\r\n   * @param input\r\n   */\n  base64Decode(input) {\n    return base64Decode(input);\n  }\n  /**\r\n   * Encodes input string to base64 URL safe string.\r\n   * @param input\r\n   */\n  base64UrlEncode(input) {\n    return urlEncode(input);\n  }\n  /**\r\n   * Stringifies and base64Url encodes input public key\r\n   * @param inputKid\r\n   * @returns Base64Url encoded public key\r\n   */\n  encodeKid(inputKid) {\n    return this.base64UrlEncode(JSON.stringify({\n      kid: inputKid\n    }));\n  }\n  /**\r\n   * Generates a keypair, stores it and returns a thumbprint\r\n   * @param request\r\n   */\n  async getPublicKeyThumbprint(request) {\n    const publicKeyThumbMeasurement = this.performanceClient?.startMeasurement(PerformanceEvents.CryptoOptsGetPublicKeyThumbprint, request.correlationId);\n    // Generate Keypair\n    const keyPair = await generateKeyPair(CryptoOps.EXTRACTABLE, CryptoOps.POP_KEY_USAGES);\n    // Generate Thumbprint for Public Key\n    const publicKeyJwk = await exportJwk(keyPair.publicKey);\n    const pubKeyThumprintObj = {\n      e: publicKeyJwk.e,\n      kty: publicKeyJwk.kty,\n      n: publicKeyJwk.n\n    };\n    const publicJwkString = getSortedObjectString(pubKeyThumprintObj);\n    const publicJwkHash = await this.hashString(publicJwkString);\n    // Generate Thumbprint for Private Key\n    const privateKeyJwk = await exportJwk(keyPair.privateKey);\n    // Re-import private key to make it unextractable\n    const unextractablePrivateKey = await importJwk(privateKeyJwk, false, [\"sign\"]);\n    // Store Keypair data in keystore\n    await this.cache.setItem(publicJwkHash, {\n      privateKey: unextractablePrivateKey,\n      publicKey: keyPair.publicKey,\n      requestMethod: request.resourceRequestMethod,\n      requestUri: request.resourceRequestUri\n    });\n    if (publicKeyThumbMeasurement) {\n      publicKeyThumbMeasurement.end({\n        success: true\n      });\n    }\n    return publicJwkHash;\n  }\n  /**\r\n   * Removes cryptographic keypair from key store matching the keyId passed in\r\n   * @param kid\r\n   */\n  async removeTokenBindingKey(kid) {\n    await this.cache.removeItem(kid);\n    const keyFound = await this.cache.containsKey(kid);\n    return !keyFound;\n  }\n  /**\r\n   * Removes all cryptographic keys from IndexedDB storage\r\n   */\n  async clearKeystore() {\n    // Delete in-memory keystores\n    this.cache.clearInMemory();\n    /**\r\n     * There is only one database, so calling clearPersistent on asymmetric keystore takes care of\r\n     * every persistent keystore\r\n     */\n    try {\n      await this.cache.clearPersistent();\n      return true;\n    } catch (e) {\n      if (e instanceof Error) {\n        this.logger.error(`Clearing keystore failed with error: ${e.message}`);\n      } else {\n        this.logger.error(\"Clearing keystore failed with unknown error\");\n      }\n      return false;\n    }\n  }\n  /**\r\n   * Signs the given object as a jwt payload with private key retrieved by given kid.\r\n   * @param payload\r\n   * @param kid\r\n   */\n  async signJwt(payload, kid, shrOptions, correlationId) {\n    const signJwtMeasurement = this.performanceClient?.startMeasurement(PerformanceEvents.CryptoOptsSignJwt, correlationId);\n    const cachedKeyPair = await this.cache.getItem(kid);\n    if (!cachedKeyPair) {\n      throw createBrowserAuthError(cryptoKeyNotFound);\n    }\n    // Get public key as JWK\n    const publicKeyJwk = await exportJwk(cachedKeyPair.publicKey);\n    const publicKeyJwkString = getSortedObjectString(publicKeyJwk);\n    // Base64URL encode public key thumbprint with keyId only: BASE64URL({ kid: \"FULL_PUBLIC_KEY_HASH\" })\n    const encodedKeyIdThumbprint = urlEncode(JSON.stringify({\n      kid: kid\n    }));\n    // Generate header\n    const shrHeader = JoseHeader.getShrHeaderString({\n      ...shrOptions?.header,\n      alg: publicKeyJwk.alg,\n      kid: encodedKeyIdThumbprint\n    });\n    const encodedShrHeader = urlEncode(shrHeader);\n    // Generate payload\n    payload.cnf = {\n      jwk: JSON.parse(publicKeyJwkString)\n    };\n    const encodedPayload = urlEncode(JSON.stringify(payload));\n    // Form token string\n    const tokenString = `${encodedShrHeader}.${encodedPayload}`;\n    // Sign token\n    const encoder = new TextEncoder();\n    const tokenBuffer = encoder.encode(tokenString);\n    const signatureBuffer = await sign(cachedKeyPair.privateKey, tokenBuffer);\n    const encodedSignature = urlEncodeArr(new Uint8Array(signatureBuffer));\n    const signedJwt = `${tokenString}.${encodedSignature}`;\n    if (signJwtMeasurement) {\n      signJwtMeasurement.end({\n        success: true\n      });\n    }\n    return signedJwt;\n  }\n  /**\r\n   * Returns the SHA-256 hash of an input string\r\n   * @param plainText\r\n   */\n  async hashString(plainText) {\n    return hashString(plainText);\n  }\n}\nCryptoOps.POP_KEY_USAGES = [\"sign\", \"verify\"];\nCryptoOps.EXTRACTABLE = true;\nfunction getSortedObjectString(obj) {\n  return JSON.stringify(obj, Object.keys(obj).sort());\n}\nexport { CryptoOps };","map":{"version":3,"names":["CryptoOps","constructor","logger","performanceClient","skipValidateSubtleCrypto","validateCryptoAvailable","cache","AsyncMemoryStorage","createNewGuid","base64Encode","input","base64Decode","base64UrlEncode","urlEncode","encodeKid","inputKid","JSON","stringify","kid","getPublicKeyThumbprint","request","publicKeyThumbMeasurement","startMeasurement","PerformanceEvents","CryptoOptsGetPublicKeyThumbprint","correlationId","keyPair","generateKeyPair","EXTRACTABLE","POP_KEY_USAGES","publicKeyJwk","exportJwk","publicKey","pubKeyThumprintObj","e","kty","n","publicJwkString","getSortedObjectString","publicJwkHash","hashString","privateKeyJwk","privateKey","unextractablePrivateKey","importJwk","setItem","requestMethod","resourceRequestMethod","requestUri","resourceRequestUri","end","success","removeTokenBindingKey","removeItem","keyFound","containsKey","clearKeystore","clearInMemory","clearPersistent","Error","error","message","signJwt","payload","shrOptions","signJwtMeasurement","CryptoOptsSignJwt","cachedKeyPair","getItem","createBrowserAuthError","cryptoKeyNotFound","publicKeyJwkString","encodedKeyIdThumbprint","shrHeader","JoseHeader","getShrHeaderString","header","alg","encodedShrHeader","cnf","jwk","parse","encodedPayload","tokenString","encoder","TextEncoder","tokenBuffer","encode","signatureBuffer","sign","encodedSignature","urlEncodeArr","Uint8Array","signedJwt","plainText","obj","Object","keys","sort"],"sources":["C:\\bytepantry\\frontend\\node_modules\\@azure\\msal-browser\\src\\crypto\\CryptoOps.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    ICrypto,\r\n    IPerformanceClient,\r\n    JoseHeader,\r\n    Logger,\r\n    PerformanceEvents,\r\n    ShrOptions,\r\n    SignedHttpRequest,\r\n    SignedHttpRequestParameters,\r\n} from \"@azure/msal-common/browser\";\r\nimport {\r\n    base64Encode,\r\n    urlEncode,\r\n    urlEncodeArr,\r\n} from \"../encode/Base64Encode.js\";\r\nimport { base64Decode } from \"../encode/Base64Decode.js\";\r\nimport * as BrowserCrypto from \"./BrowserCrypto.js\";\r\nimport {\r\n    createBrowserAuthError,\r\n    BrowserAuthErrorCodes,\r\n} from \"../error/BrowserAuthError.js\";\r\nimport { AsyncMemoryStorage } from \"../cache/AsyncMemoryStorage.js\";\r\n\r\nexport type CachedKeyPair = {\r\n    publicKey: CryptoKey;\r\n    privateKey: CryptoKey;\r\n    requestMethod?: string;\r\n    requestUri?: string;\r\n};\r\n\r\n/**\r\n * This class implements MSAL's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and\r\n * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).\r\n */\r\nexport class CryptoOps implements ICrypto {\r\n    private logger: Logger;\r\n\r\n    /**\r\n     * CryptoOps can be used in contexts outside a PCA instance,\r\n     * meaning there won't be a performance manager available.\r\n     */\r\n    private performanceClient: IPerformanceClient | undefined;\r\n\r\n    private static POP_KEY_USAGES: Array<KeyUsage> = [\"sign\", \"verify\"];\r\n    private static EXTRACTABLE: boolean = true;\r\n    private cache: AsyncMemoryStorage<CachedKeyPair>;\r\n\r\n    constructor(\r\n        logger: Logger,\r\n        performanceClient?: IPerformanceClient,\r\n        skipValidateSubtleCrypto?: boolean\r\n    ) {\r\n        this.logger = logger;\r\n        // Browser crypto needs to be validated first before any other classes can be set.\r\n        BrowserCrypto.validateCryptoAvailable(\r\n            skipValidateSubtleCrypto ?? false\r\n        );\r\n        this.cache = new AsyncMemoryStorage<CachedKeyPair>(this.logger);\r\n        this.performanceClient = performanceClient;\r\n    }\r\n\r\n    /**\r\n     * Creates a new random GUID - used to populate state and nonce.\r\n     * @returns string (GUID)\r\n     */\r\n    createNewGuid(): string {\r\n        return BrowserCrypto.createNewGuid();\r\n    }\r\n\r\n    /**\r\n     * Encodes input string to base64.\r\n     * @param input\r\n     */\r\n    base64Encode(input: string): string {\r\n        return base64Encode(input);\r\n    }\r\n\r\n    /**\r\n     * Decodes input string from base64.\r\n     * @param input\r\n     */\r\n    base64Decode(input: string): string {\r\n        return base64Decode(input);\r\n    }\r\n\r\n    /**\r\n     * Encodes input string to base64 URL safe string.\r\n     * @param input\r\n     */\r\n    base64UrlEncode(input: string): string {\r\n        return urlEncode(input);\r\n    }\r\n\r\n    /**\r\n     * Stringifies and base64Url encodes input public key\r\n     * @param inputKid\r\n     * @returns Base64Url encoded public key\r\n     */\r\n    encodeKid(inputKid: string): string {\r\n        return this.base64UrlEncode(JSON.stringify({ kid: inputKid }));\r\n    }\r\n\r\n    /**\r\n     * Generates a keypair, stores it and returns a thumbprint\r\n     * @param request\r\n     */\r\n    async getPublicKeyThumbprint(\r\n        request: SignedHttpRequestParameters\r\n    ): Promise<string> {\r\n        const publicKeyThumbMeasurement =\r\n            this.performanceClient?.startMeasurement(\r\n                PerformanceEvents.CryptoOptsGetPublicKeyThumbprint,\r\n                request.correlationId\r\n            );\r\n\r\n        // Generate Keypair\r\n        const keyPair: CryptoKeyPair = await BrowserCrypto.generateKeyPair(\r\n            CryptoOps.EXTRACTABLE,\r\n            CryptoOps.POP_KEY_USAGES\r\n        );\r\n\r\n        // Generate Thumbprint for Public Key\r\n        const publicKeyJwk: JsonWebKey = await BrowserCrypto.exportJwk(\r\n            keyPair.publicKey\r\n        );\r\n\r\n        const pubKeyThumprintObj: JsonWebKey = {\r\n            e: publicKeyJwk.e,\r\n            kty: publicKeyJwk.kty,\r\n            n: publicKeyJwk.n,\r\n        };\r\n\r\n        const publicJwkString: string =\r\n            getSortedObjectString(pubKeyThumprintObj);\r\n        const publicJwkHash = await this.hashString(publicJwkString);\r\n\r\n        // Generate Thumbprint for Private Key\r\n        const privateKeyJwk: JsonWebKey = await BrowserCrypto.exportJwk(\r\n            keyPair.privateKey\r\n        );\r\n        // Re-import private key to make it unextractable\r\n        const unextractablePrivateKey: CryptoKey =\r\n            await BrowserCrypto.importJwk(privateKeyJwk, false, [\"sign\"]);\r\n\r\n        // Store Keypair data in keystore\r\n        await this.cache.setItem(publicJwkHash, {\r\n            privateKey: unextractablePrivateKey,\r\n            publicKey: keyPair.publicKey,\r\n            requestMethod: request.resourceRequestMethod,\r\n            requestUri: request.resourceRequestUri,\r\n        });\r\n\r\n        if (publicKeyThumbMeasurement) {\r\n            publicKeyThumbMeasurement.end({\r\n                success: true,\r\n            });\r\n        }\r\n\r\n        return publicJwkHash;\r\n    }\r\n\r\n    /**\r\n     * Removes cryptographic keypair from key store matching the keyId passed in\r\n     * @param kid\r\n     */\r\n    async removeTokenBindingKey(kid: string): Promise<boolean> {\r\n        await this.cache.removeItem(kid);\r\n        const keyFound = await this.cache.containsKey(kid);\r\n        return !keyFound;\r\n    }\r\n\r\n    /**\r\n     * Removes all cryptographic keys from IndexedDB storage\r\n     */\r\n    async clearKeystore(): Promise<boolean> {\r\n        // Delete in-memory keystores\r\n        this.cache.clearInMemory();\r\n\r\n        /**\r\n         * There is only one database, so calling clearPersistent on asymmetric keystore takes care of\r\n         * every persistent keystore\r\n         */\r\n        try {\r\n            await this.cache.clearPersistent();\r\n            return true;\r\n        } catch (e) {\r\n            if (e instanceof Error) {\r\n                this.logger.error(\r\n                    `Clearing keystore failed with error: ${e.message}`\r\n                );\r\n            } else {\r\n                this.logger.error(\r\n                    \"Clearing keystore failed with unknown error\"\r\n                );\r\n            }\r\n\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Signs the given object as a jwt payload with private key retrieved by given kid.\r\n     * @param payload\r\n     * @param kid\r\n     */\r\n    async signJwt(\r\n        payload: SignedHttpRequest,\r\n        kid: string,\r\n        shrOptions?: ShrOptions,\r\n        correlationId?: string\r\n    ): Promise<string> {\r\n        const signJwtMeasurement = this.performanceClient?.startMeasurement(\r\n            PerformanceEvents.CryptoOptsSignJwt,\r\n            correlationId\r\n        );\r\n        const cachedKeyPair = await this.cache.getItem(kid);\r\n\r\n        if (!cachedKeyPair) {\r\n            throw createBrowserAuthError(\r\n                BrowserAuthErrorCodes.cryptoKeyNotFound\r\n            );\r\n        }\r\n\r\n        // Get public key as JWK\r\n        const publicKeyJwk = await BrowserCrypto.exportJwk(\r\n            cachedKeyPair.publicKey\r\n        );\r\n        const publicKeyJwkString = getSortedObjectString(publicKeyJwk);\r\n        // Base64URL encode public key thumbprint with keyId only: BASE64URL({ kid: \"FULL_PUBLIC_KEY_HASH\" })\r\n        const encodedKeyIdThumbprint = urlEncode(JSON.stringify({ kid: kid }));\r\n        // Generate header\r\n        const shrHeader = JoseHeader.getShrHeaderString({\r\n            ...shrOptions?.header,\r\n            alg: publicKeyJwk.alg,\r\n            kid: encodedKeyIdThumbprint,\r\n        });\r\n\r\n        const encodedShrHeader = urlEncode(shrHeader);\r\n\r\n        // Generate payload\r\n        payload.cnf = {\r\n            jwk: JSON.parse(publicKeyJwkString),\r\n        };\r\n        const encodedPayload = urlEncode(JSON.stringify(payload));\r\n\r\n        // Form token string\r\n        const tokenString = `${encodedShrHeader}.${encodedPayload}`;\r\n\r\n        // Sign token\r\n        const encoder = new TextEncoder();\r\n        const tokenBuffer = encoder.encode(tokenString);\r\n        const signatureBuffer = await BrowserCrypto.sign(\r\n            cachedKeyPair.privateKey,\r\n            tokenBuffer\r\n        );\r\n        const encodedSignature = urlEncodeArr(new Uint8Array(signatureBuffer));\r\n\r\n        const signedJwt = `${tokenString}.${encodedSignature}`;\r\n\r\n        if (signJwtMeasurement) {\r\n            signJwtMeasurement.end({\r\n                success: true,\r\n            });\r\n        }\r\n\r\n        return signedJwt;\r\n    }\r\n\r\n    /**\r\n     * Returns the SHA-256 hash of an input string\r\n     * @param plainText\r\n     */\r\n    async hashString(plainText: string): Promise<string> {\r\n        return BrowserCrypto.hashString(plainText);\r\n    }\r\n}\r\n\r\nfunction getSortedObjectString(obj: object): string {\r\n    return JSON.stringify(obj, Object.keys(obj).sort());\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}