{"ast":null,"code":"/*! @azure/msal-browser v4.5.0 2025-02-26 */\n'use strict';\n\nimport { invoke, PerformanceEvents, invokeAsync, Constants } from '@azure/msal-common/browser';\nimport { generateHKDF, createNewGuid, generateBaseKey, encrypt, decrypt } from '../crypto/BrowserCrypto.mjs';\nimport { base64DecToArr } from '../encode/Base64Decode.mjs';\nimport { urlEncodeArr } from '../encode/Base64Encode.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { createBrowserConfigurationAuthError } from '../error/BrowserConfigurationAuthError.mjs';\nimport { SameSiteOptions, CookieStorage } from './CookieStorage.mjs';\nimport { MemoryStorage } from './MemoryStorage.mjs';\nimport { getAccountKeys, getTokenKeys } from './CacheHelpers.mjs';\nimport { StaticCacheKeys } from '../utils/BrowserConstants.mjs';\nimport { storageNotSupported } from '../error/BrowserConfigurationAuthErrorCodes.mjs';\nimport { uninitializedPublicClientApplication } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst ENCRYPTION_KEY = \"msal.cache.encryption\";\nconst BROADCAST_CHANNEL_NAME = \"msal.broadcast.cache\";\nclass LocalStorage {\n  constructor(clientId, logger, performanceClient) {\n    if (!window.localStorage) {\n      throw createBrowserConfigurationAuthError(storageNotSupported);\n    }\n    this.memoryStorage = new MemoryStorage();\n    this.initialized = false;\n    this.clientId = clientId;\n    this.logger = logger;\n    this.performanceClient = performanceClient;\n    this.broadcast = new BroadcastChannel(BROADCAST_CHANNEL_NAME);\n  }\n  async initialize(correlationId) {\n    this.initialized = true;\n    const cookies = new CookieStorage();\n    const cookieString = cookies.getItem(ENCRYPTION_KEY);\n    let parsedCookie = {\n      key: \"\",\n      id: \"\"\n    };\n    if (cookieString) {\n      try {\n        parsedCookie = JSON.parse(cookieString);\n      } catch (e) {}\n    }\n    if (parsedCookie.key && parsedCookie.id) {\n      // Encryption key already exists, import\n      const baseKey = invoke(base64DecToArr, PerformanceEvents.Base64Decode, this.logger, this.performanceClient, correlationId)(parsedCookie.key);\n      this.encryptionCookie = {\n        id: parsedCookie.id,\n        key: await invokeAsync(generateHKDF, PerformanceEvents.GenerateHKDF, this.logger, this.performanceClient, correlationId)(baseKey)\n      };\n      await invokeAsync(this.importExistingCache.bind(this), PerformanceEvents.ImportExistingCache, this.logger, this.performanceClient, correlationId)(correlationId);\n    } else {\n      // Encryption key doesn't exist or is invalid, generate a new one and clear existing cache\n      this.clear();\n      const id = createNewGuid();\n      const baseKey = await invokeAsync(generateBaseKey, PerformanceEvents.GenerateBaseKey, this.logger, this.performanceClient, correlationId)();\n      const keyStr = invoke(urlEncodeArr, PerformanceEvents.UrlEncodeArr, this.logger, this.performanceClient, correlationId)(new Uint8Array(baseKey));\n      this.encryptionCookie = {\n        id: id,\n        key: await invokeAsync(generateHKDF, PerformanceEvents.GenerateHKDF, this.logger, this.performanceClient, correlationId)(baseKey)\n      };\n      const cookieData = {\n        id: id,\n        key: keyStr\n      };\n      cookies.setItem(ENCRYPTION_KEY, JSON.stringify(cookieData), 0,\n      // Expiration - 0 means cookie will be cleared at the end of the browser session\n      true,\n      // Secure flag\n      SameSiteOptions.None // SameSite must be None to support iframed apps\n      );\n    }\n    // Register listener for cache updates in other tabs\n    this.broadcast.addEventListener(\"message\", this.updateCache.bind(this));\n  }\n  getItem(key) {\n    return window.localStorage.getItem(key);\n  }\n  getUserData(key) {\n    if (!this.initialized) {\n      throw createBrowserAuthError(uninitializedPublicClientApplication);\n    }\n    return this.memoryStorage.getItem(key);\n  }\n  setItem(key, value) {\n    window.localStorage.setItem(key, value);\n  }\n  async setUserData(key, value, correlationId) {\n    if (!this.initialized || !this.encryptionCookie) {\n      throw createBrowserAuthError(uninitializedPublicClientApplication);\n    }\n    const {\n      data,\n      nonce\n    } = await invokeAsync(encrypt, PerformanceEvents.Encrypt, this.logger, this.performanceClient, correlationId)(this.encryptionCookie.key, value, this.getContext(key));\n    const encryptedData = {\n      id: this.encryptionCookie.id,\n      nonce: nonce,\n      data: data\n    };\n    this.memoryStorage.setItem(key, value);\n    this.setItem(key, JSON.stringify(encryptedData));\n    // Notify other frames to update their in-memory cache\n    this.broadcast.postMessage({\n      key: key,\n      value: value,\n      context: this.getContext(key)\n    });\n  }\n  removeItem(key) {\n    if (this.memoryStorage.containsKey(key)) {\n      this.memoryStorage.removeItem(key);\n      this.broadcast.postMessage({\n        key: key,\n        value: null,\n        context: this.getContext(key)\n      });\n    }\n    window.localStorage.removeItem(key);\n  }\n  getKeys() {\n    return Object.keys(window.localStorage);\n  }\n  containsKey(key) {\n    return window.localStorage.hasOwnProperty(key);\n  }\n  /**\r\n   * Removes all known MSAL keys from the cache\r\n   */\n  clear() {\n    // Removes all remaining MSAL cache items\n    this.memoryStorage.clear();\n    const accountKeys = getAccountKeys(this);\n    accountKeys.forEach(key => this.removeItem(key));\n    const tokenKeys = getTokenKeys(this.clientId, this);\n    tokenKeys.idToken.forEach(key => this.removeItem(key));\n    tokenKeys.accessToken.forEach(key => this.removeItem(key));\n    tokenKeys.refreshToken.forEach(key => this.removeItem(key));\n    // Clean up anything left\n    this.getKeys().forEach(cacheKey => {\n      if (cacheKey.startsWith(Constants.CACHE_PREFIX) || cacheKey.indexOf(this.clientId) !== -1) {\n        this.removeItem(cacheKey);\n      }\n    });\n  }\n  /**\r\n   * Helper to decrypt all known MSAL keys in localStorage and save them to inMemory storage\r\n   * @returns\r\n   */\n  async importExistingCache(correlationId) {\n    if (!this.encryptionCookie) {\n      return;\n    }\n    let accountKeys = getAccountKeys(this);\n    accountKeys = await this.importArray(accountKeys, correlationId);\n    // Write valid account keys back to map\n    this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n    const tokenKeys = getTokenKeys(this.clientId, this);\n    tokenKeys.idToken = await this.importArray(tokenKeys.idToken, correlationId);\n    tokenKeys.accessToken = await this.importArray(tokenKeys.accessToken, correlationId);\n    tokenKeys.refreshToken = await this.importArray(tokenKeys.refreshToken, correlationId);\n    // Write valid token keys back to map\n    this.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));\n  }\n  /**\r\n   * Helper to decrypt and save cache entries\r\n   * @param key\r\n   * @returns\r\n   */\n  async getItemFromEncryptedCache(key, correlationId) {\n    if (!this.encryptionCookie) {\n      return null;\n    }\n    const rawCache = this.getItem(key);\n    if (!rawCache) {\n      return null;\n    }\n    let encObj;\n    try {\n      encObj = JSON.parse(rawCache);\n    } catch (e) {\n      // Not a valid encrypted object, remove\n      return null;\n    }\n    if (!encObj.id || !encObj.nonce || !encObj.data) {\n      // Data is not encrypted, likely from old version of MSAL. It must be removed because we don't know how old it is.\n      this.performanceClient.incrementFields({\n        unencryptedCacheCount: 1\n      }, correlationId);\n      return null;\n    }\n    if (encObj.id !== this.encryptionCookie.id) {\n      // Data was encrypted with a different key. It must be removed because it is from a previous session.\n      this.performanceClient.incrementFields({\n        encryptedCacheExpiredCount: 1\n      }, correlationId);\n      return null;\n    }\n    return invokeAsync(decrypt, PerformanceEvents.Decrypt, this.logger, this.performanceClient, correlationId)(this.encryptionCookie.key, encObj.nonce, this.getContext(key), encObj.data);\n  }\n  /**\r\n   * Helper to decrypt and save an array of cache keys\r\n   * @param arr\r\n   * @returns Array of keys successfully imported\r\n   */\n  async importArray(arr, correlationId) {\n    const importedArr = [];\n    const promiseArr = [];\n    arr.forEach(key => {\n      const promise = this.getItemFromEncryptedCache(key, correlationId).then(value => {\n        if (value) {\n          this.memoryStorage.setItem(key, value);\n          importedArr.push(key);\n        } else {\n          // If value is empty, unencrypted or expired remove\n          this.removeItem(key);\n        }\n      });\n      promiseArr.push(promise);\n    });\n    await Promise.all(promiseArr);\n    return importedArr;\n  }\n  /**\r\n   * Gets encryption context for a given cache entry. This is clientId for app specific entries, empty string for shared entries\r\n   * @param key\r\n   * @returns\r\n   */\n  getContext(key) {\n    let context = \"\";\n    if (key.includes(this.clientId)) {\n      context = this.clientId; // Used to bind encryption key to this appId\n    }\n    return context;\n  }\n  updateCache(event) {\n    this.logger.trace(\"Updating internal cache from broadcast event\");\n    const perfMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.LocalStorageUpdated);\n    perfMeasurement.add({\n      isBackground: true\n    });\n    const {\n      key,\n      value,\n      context\n    } = event.data;\n    if (!key) {\n      this.logger.error(\"Broadcast event missing key\");\n      perfMeasurement.end({\n        success: false,\n        errorCode: \"noKey\"\n      });\n      return;\n    }\n    if (context && context !== this.clientId) {\n      this.logger.trace(`Ignoring broadcast event from clientId: ${context}`);\n      perfMeasurement.end({\n        success: false,\n        errorCode: \"contextMismatch\"\n      });\n      return;\n    }\n    if (!value) {\n      this.memoryStorage.removeItem(key);\n      this.logger.verbose(\"Removed item from internal cache\");\n    } else {\n      this.memoryStorage.setItem(key, value);\n      this.logger.verbose(\"Updated item in internal cache\");\n    }\n    perfMeasurement.end({\n      success: true\n    });\n  }\n}\nexport { LocalStorage };","map":{"version":3,"names":["ENCRYPTION_KEY","BROADCAST_CHANNEL_NAME","LocalStorage","constructor","clientId","logger","performanceClient","window","localStorage","createBrowserConfigurationAuthError","storageNotSupported","memoryStorage","MemoryStorage","initialized","broadcast","BroadcastChannel","initialize","correlationId","cookies","CookieStorage","cookieString","getItem","parsedCookie","key","id","JSON","parse","e","baseKey","invoke","base64DecToArr","PerformanceEvents","Base64Decode","encryptionCookie","invokeAsync","generateHKDF","GenerateHKDF","importExistingCache","bind","ImportExistingCache","clear","createNewGuid","generateBaseKey","GenerateBaseKey","keyStr","urlEncodeArr","UrlEncodeArr","Uint8Array","cookieData","setItem","stringify","SameSiteOptions","None","addEventListener","updateCache","getUserData","createBrowserAuthError","uninitializedPublicClientApplication","value","setUserData","data","nonce","encrypt","Encrypt","getContext","encryptedData","postMessage","context","removeItem","containsKey","getKeys","Object","keys","hasOwnProperty","accountKeys","getAccountKeys","forEach","tokenKeys","getTokenKeys","idToken","accessToken","refreshToken","cacheKey","startsWith","Constants","CACHE_PREFIX","indexOf","importArray","StaticCacheKeys","ACCOUNT_KEYS","TOKEN_KEYS","getItemFromEncryptedCache","rawCache","encObj","incrementFields","unencryptedCacheCount","encryptedCacheExpiredCount","decrypt","Decrypt","arr","importedArr","promiseArr","promise","then","push","Promise","all","includes","event","trace","perfMeasurement","startMeasurement","LocalStorageUpdated","add","isBackground","error","end","success","errorCode","verbose"],"sources":["C:\\bytepantry\\frontend\\node_modules\\@azure\\msal-browser\\src\\cache\\LocalStorage.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    Constants,\r\n    TokenKeys,\r\n    IPerformanceClient,\r\n    invokeAsync,\r\n    PerformanceEvents,\r\n    Logger,\r\n    invoke,\r\n} from \"@azure/msal-common/browser\";\r\nimport {\r\n    createNewGuid,\r\n    decrypt,\r\n    encrypt,\r\n    generateBaseKey,\r\n    generateHKDF,\r\n} from \"../crypto/BrowserCrypto.js\";\r\nimport { base64DecToArr } from \"../encode/Base64Decode.js\";\r\nimport { urlEncodeArr } from \"../encode/Base64Encode.js\";\r\nimport {\r\n    BrowserAuthErrorCodes,\r\n    createBrowserAuthError,\r\n} from \"../error/BrowserAuthError.js\";\r\nimport {\r\n    BrowserConfigurationAuthErrorCodes,\r\n    createBrowserConfigurationAuthError,\r\n} from \"../error/BrowserConfigurationAuthError.js\";\r\nimport { CookieStorage, SameSiteOptions } from \"./CookieStorage.js\";\r\nimport { IWindowStorage } from \"./IWindowStorage.js\";\r\nimport { MemoryStorage } from \"./MemoryStorage.js\";\r\nimport { getAccountKeys, getTokenKeys } from \"./CacheHelpers.js\";\r\nimport { StaticCacheKeys } from \"../utils/BrowserConstants.js\";\r\n\r\nconst ENCRYPTION_KEY = \"msal.cache.encryption\";\r\nconst BROADCAST_CHANNEL_NAME = \"msal.broadcast.cache\";\r\n\r\ntype EncryptionCookie = {\r\n    id: string;\r\n    key: CryptoKey;\r\n};\r\n\r\ntype EncryptedData = {\r\n    id: string;\r\n    nonce: string;\r\n    data: string;\r\n};\r\n\r\nexport class LocalStorage implements IWindowStorage<string> {\r\n    private clientId: string;\r\n    private initialized: boolean;\r\n    private memoryStorage: MemoryStorage<string>;\r\n    private performanceClient: IPerformanceClient;\r\n    private logger: Logger;\r\n    private encryptionCookie?: EncryptionCookie;\r\n    private broadcast: BroadcastChannel;\r\n\r\n    constructor(\r\n        clientId: string,\r\n        logger: Logger,\r\n        performanceClient: IPerformanceClient\r\n    ) {\r\n        if (!window.localStorage) {\r\n            throw createBrowserConfigurationAuthError(\r\n                BrowserConfigurationAuthErrorCodes.storageNotSupported\r\n            );\r\n        }\r\n        this.memoryStorage = new MemoryStorage<string>();\r\n        this.initialized = false;\r\n        this.clientId = clientId;\r\n        this.logger = logger;\r\n        this.performanceClient = performanceClient;\r\n        this.broadcast = new BroadcastChannel(BROADCAST_CHANNEL_NAME);\r\n    }\r\n\r\n    async initialize(correlationId: string): Promise<void> {\r\n        this.initialized = true;\r\n\r\n        const cookies = new CookieStorage();\r\n        const cookieString = cookies.getItem(ENCRYPTION_KEY);\r\n        let parsedCookie = { key: \"\", id: \"\" };\r\n        if (cookieString) {\r\n            try {\r\n                parsedCookie = JSON.parse(cookieString);\r\n            } catch (e) {}\r\n        }\r\n        if (parsedCookie.key && parsedCookie.id) {\r\n            // Encryption key already exists, import\r\n            const baseKey = invoke(\r\n                base64DecToArr,\r\n                PerformanceEvents.Base64Decode,\r\n                this.logger,\r\n                this.performanceClient,\r\n                correlationId\r\n            )(parsedCookie.key);\r\n            this.encryptionCookie = {\r\n                id: parsedCookie.id,\r\n                key: await invokeAsync(\r\n                    generateHKDF,\r\n                    PerformanceEvents.GenerateHKDF,\r\n                    this.logger,\r\n                    this.performanceClient,\r\n                    correlationId\r\n                )(baseKey),\r\n            };\r\n            await invokeAsync(\r\n                this.importExistingCache.bind(this),\r\n                PerformanceEvents.ImportExistingCache,\r\n                this.logger,\r\n                this.performanceClient,\r\n                correlationId\r\n            )(correlationId);\r\n        } else {\r\n            // Encryption key doesn't exist or is invalid, generate a new one and clear existing cache\r\n            this.clear();\r\n            const id = createNewGuid();\r\n            const baseKey = await invokeAsync(\r\n                generateBaseKey,\r\n                PerformanceEvents.GenerateBaseKey,\r\n                this.logger,\r\n                this.performanceClient,\r\n                correlationId\r\n            )();\r\n            const keyStr = invoke(\r\n                urlEncodeArr,\r\n                PerformanceEvents.UrlEncodeArr,\r\n                this.logger,\r\n                this.performanceClient,\r\n                correlationId\r\n            )(new Uint8Array(baseKey));\r\n            this.encryptionCookie = {\r\n                id: id,\r\n                key: await invokeAsync(\r\n                    generateHKDF,\r\n                    PerformanceEvents.GenerateHKDF,\r\n                    this.logger,\r\n                    this.performanceClient,\r\n                    correlationId\r\n                )(baseKey),\r\n            };\r\n\r\n            const cookieData = {\r\n                id: id,\r\n                key: keyStr,\r\n            };\r\n\r\n            cookies.setItem(\r\n                ENCRYPTION_KEY,\r\n                JSON.stringify(cookieData),\r\n                0, // Expiration - 0 means cookie will be cleared at the end of the browser session\r\n                true, // Secure flag\r\n                SameSiteOptions.None // SameSite must be None to support iframed apps\r\n            );\r\n        }\r\n\r\n        // Register listener for cache updates in other tabs\r\n        this.broadcast.addEventListener(\"message\", this.updateCache.bind(this));\r\n    }\r\n\r\n    getItem(key: string): string | null {\r\n        return window.localStorage.getItem(key);\r\n    }\r\n\r\n    getUserData(key: string): string | null {\r\n        if (!this.initialized) {\r\n            throw createBrowserAuthError(\r\n                BrowserAuthErrorCodes.uninitializedPublicClientApplication\r\n            );\r\n        }\r\n        return this.memoryStorage.getItem(key);\r\n    }\r\n\r\n    setItem(key: string, value: string): void {\r\n        window.localStorage.setItem(key, value);\r\n    }\r\n\r\n    async setUserData(\r\n        key: string,\r\n        value: string,\r\n        correlationId: string\r\n    ): Promise<void> {\r\n        if (!this.initialized || !this.encryptionCookie) {\r\n            throw createBrowserAuthError(\r\n                BrowserAuthErrorCodes.uninitializedPublicClientApplication\r\n            );\r\n        }\r\n\r\n        const { data, nonce } = await invokeAsync(\r\n            encrypt,\r\n            PerformanceEvents.Encrypt,\r\n            this.logger,\r\n            this.performanceClient,\r\n            correlationId\r\n        )(this.encryptionCookie.key, value, this.getContext(key));\r\n        const encryptedData: EncryptedData = {\r\n            id: this.encryptionCookie.id,\r\n            nonce: nonce,\r\n            data: data,\r\n        };\r\n\r\n        this.memoryStorage.setItem(key, value);\r\n        this.setItem(key, JSON.stringify(encryptedData));\r\n\r\n        // Notify other frames to update their in-memory cache\r\n        this.broadcast.postMessage({\r\n            key: key,\r\n            value: value,\r\n            context: this.getContext(key),\r\n        });\r\n    }\r\n\r\n    removeItem(key: string): void {\r\n        if (this.memoryStorage.containsKey(key)) {\r\n            this.memoryStorage.removeItem(key);\r\n            this.broadcast.postMessage({\r\n                key: key,\r\n                value: null,\r\n                context: this.getContext(key),\r\n            });\r\n        }\r\n        window.localStorage.removeItem(key);\r\n    }\r\n\r\n    getKeys(): string[] {\r\n        return Object.keys(window.localStorage);\r\n    }\r\n\r\n    containsKey(key: string): boolean {\r\n        return window.localStorage.hasOwnProperty(key);\r\n    }\r\n\r\n    /**\r\n     * Removes all known MSAL keys from the cache\r\n     */\r\n    clear(): void {\r\n        // Removes all remaining MSAL cache items\r\n        this.memoryStorage.clear();\r\n\r\n        const accountKeys = getAccountKeys(this);\r\n        accountKeys.forEach((key) => this.removeItem(key));\r\n        const tokenKeys = getTokenKeys(this.clientId, this);\r\n        tokenKeys.idToken.forEach((key) => this.removeItem(key));\r\n        tokenKeys.accessToken.forEach((key) => this.removeItem(key));\r\n        tokenKeys.refreshToken.forEach((key) => this.removeItem(key));\r\n\r\n        // Clean up anything left\r\n        this.getKeys().forEach((cacheKey: string) => {\r\n            if (\r\n                cacheKey.startsWith(Constants.CACHE_PREFIX) ||\r\n                cacheKey.indexOf(this.clientId) !== -1\r\n            ) {\r\n                this.removeItem(cacheKey);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Helper to decrypt all known MSAL keys in localStorage and save them to inMemory storage\r\n     * @returns\r\n     */\r\n    private async importExistingCache(correlationId: string): Promise<void> {\r\n        if (!this.encryptionCookie) {\r\n            return;\r\n        }\r\n\r\n        let accountKeys = getAccountKeys(this);\r\n        accountKeys = await this.importArray(accountKeys, correlationId);\r\n        // Write valid account keys back to map\r\n        this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\r\n\r\n        const tokenKeys: TokenKeys = getTokenKeys(this.clientId, this);\r\n        tokenKeys.idToken = await this.importArray(\r\n            tokenKeys.idToken,\r\n            correlationId\r\n        );\r\n        tokenKeys.accessToken = await this.importArray(\r\n            tokenKeys.accessToken,\r\n            correlationId\r\n        );\r\n        tokenKeys.refreshToken = await this.importArray(\r\n            tokenKeys.refreshToken,\r\n            correlationId\r\n        );\r\n        // Write valid token keys back to map\r\n        this.setItem(\r\n            `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`,\r\n            JSON.stringify(tokenKeys)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Helper to decrypt and save cache entries\r\n     * @param key\r\n     * @returns\r\n     */\r\n    private async getItemFromEncryptedCache(\r\n        key: string,\r\n        correlationId: string\r\n    ): Promise<string | null> {\r\n        if (!this.encryptionCookie) {\r\n            return null;\r\n        }\r\n\r\n        const rawCache = this.getItem(key);\r\n        if (!rawCache) {\r\n            return null;\r\n        }\r\n\r\n        let encObj: EncryptedData;\r\n        try {\r\n            encObj = JSON.parse(rawCache);\r\n        } catch (e) {\r\n            // Not a valid encrypted object, remove\r\n            return null;\r\n        }\r\n\r\n        if (!encObj.id || !encObj.nonce || !encObj.data) {\r\n            // Data is not encrypted, likely from old version of MSAL. It must be removed because we don't know how old it is.\r\n            this.performanceClient.incrementFields(\r\n                { unencryptedCacheCount: 1 },\r\n                correlationId\r\n            );\r\n            return null;\r\n        }\r\n\r\n        if (encObj.id !== this.encryptionCookie.id) {\r\n            // Data was encrypted with a different key. It must be removed because it is from a previous session.\r\n            this.performanceClient.incrementFields(\r\n                { encryptedCacheExpiredCount: 1 },\r\n                correlationId\r\n            );\r\n            return null;\r\n        }\r\n\r\n        return invokeAsync(\r\n            decrypt,\r\n            PerformanceEvents.Decrypt,\r\n            this.logger,\r\n            this.performanceClient,\r\n            correlationId\r\n        )(\r\n            this.encryptionCookie.key,\r\n            encObj.nonce,\r\n            this.getContext(key),\r\n            encObj.data\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Helper to decrypt and save an array of cache keys\r\n     * @param arr\r\n     * @returns Array of keys successfully imported\r\n     */\r\n    private async importArray(\r\n        arr: Array<string>,\r\n        correlationId: string\r\n    ): Promise<Array<string>> {\r\n        const importedArr: Array<string> = [];\r\n        const promiseArr: Array<Promise<void>> = [];\r\n        arr.forEach((key) => {\r\n            const promise = this.getItemFromEncryptedCache(\r\n                key,\r\n                correlationId\r\n            ).then((value) => {\r\n                if (value) {\r\n                    this.memoryStorage.setItem(key, value);\r\n                    importedArr.push(key);\r\n                } else {\r\n                    // If value is empty, unencrypted or expired remove\r\n                    this.removeItem(key);\r\n                }\r\n            });\r\n            promiseArr.push(promise);\r\n        });\r\n\r\n        await Promise.all(promiseArr);\r\n        return importedArr;\r\n    }\r\n\r\n    /**\r\n     * Gets encryption context for a given cache entry. This is clientId for app specific entries, empty string for shared entries\r\n     * @param key\r\n     * @returns\r\n     */\r\n    private getContext(key: string): string {\r\n        let context = \"\";\r\n        if (key.includes(this.clientId)) {\r\n            context = this.clientId; // Used to bind encryption key to this appId\r\n        }\r\n\r\n        return context;\r\n    }\r\n\r\n    private updateCache(event: MessageEvent): void {\r\n        this.logger.trace(\"Updating internal cache from broadcast event\");\r\n        const perfMeasurement = this.performanceClient.startMeasurement(\r\n            PerformanceEvents.LocalStorageUpdated\r\n        );\r\n        perfMeasurement.add({ isBackground: true });\r\n\r\n        const { key, value, context } = event.data;\r\n        if (!key) {\r\n            this.logger.error(\"Broadcast event missing key\");\r\n            perfMeasurement.end({ success: false, errorCode: \"noKey\" });\r\n            return;\r\n        }\r\n\r\n        if (context && context !== this.clientId) {\r\n            this.logger.trace(\r\n                `Ignoring broadcast event from clientId: ${context}`\r\n            );\r\n            perfMeasurement.end({\r\n                success: false,\r\n                errorCode: \"contextMismatch\",\r\n            });\r\n            return;\r\n        }\r\n\r\n        if (!value) {\r\n            this.memoryStorage.removeItem(key);\r\n            this.logger.verbose(\"Removed item from internal cache\");\r\n        } else {\r\n            this.memoryStorage.setItem(key, value);\r\n            this.logger.verbose(\"Updated item in internal cache\");\r\n        }\r\n        perfMeasurement.end({ success: true });\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}